import os
import sys
import sqlite3
import subprocess
import threading
import time
import platform
from datetime import datetime
from PyQt6 import QtWidgets, QtGui, QtCore
import requests
import json
from PyQt6.QtOpenGLWidgets import QOpenGLWidget
from OpenGL.GL import *
# Импорт менеджера чатов
from chat_manager import ChatManager
from context_memory_manager import ContextMemoryManager

# ═══════════════════════════════════════════════════════════════
# ИСПРАВЛЕНИЕ №1: Импорт запрещенных английских слов (исправлено)
# ═══════════════════════════════════════════════════════════════
# Импорт списка запрещённых английских слов
FORBIDDEN_WORDS_DICT = {}
FORBIDDEN_WORDS_SET = set()
TOP_FORBIDDEN_FOR_PROMPT = []

try:
    # Пытаемся импортировать только FORBIDDEN_WORDS_DICT (он точно есть в файле)
    from forbidden_english_words import FORBIDDEN_WORDS_DICT as _imported_dict
    FORBIDDEN_WORDS_DICT = _imported_dict
    # Создаём SET из ключей словаря
    FORBIDDEN_WORDS_SET = set(FORBIDDEN_WORDS_DICT.keys())
    # TOP_FORBIDDEN_FOR_PROMPT оставляем пустым (он не используется критично)
    TOP_FORBIDDEN_FOR_PROMPT = []
    print(f"[IMPORT] ✓ Загружен список запрещённых английских слов ({len(FORBIDDEN_WORDS_DICT)} слов)")
except ImportError as e:
    print(f"[IMPORT] ⚠️ Файл forbidden_english_words.py не найден: {e}")
    print("[IMPORT] ⚠️ Фильтр английских слов будет работать с базовым словарём")
    FORBIDDEN_WORDS_DICT = {}
    FORBIDDEN_WORDS_SET = set()
    TOP_FORBIDDEN_FOR_PROMPT = []
except Exception as e:
    print(f"[IMPORT] ⚠️ Ошибка при импорте: {e}")
    print("[IMPORT] ⚠️ Фильтр английских слов будет работать с базовым словарём")
    FORBIDDEN_WORDS_DICT = {}
    FORBIDDEN_WORDS_SET = set()
    TOP_FORBIDDEN_FOR_PROMPT = []

# -------------------------
# Platform detection (для совместимости с Windows)
# -------------------------
IS_WINDOWS = sys.platform == "win32"

# -------------------------
# Backends configuration
# -------------------------
USE_OLLAMA = True  # Только Ollama, без OpenAI
OLLAMA_HOST = os.getenv("OLLAMA_HOST", "http://127.0.0.1:11434")
OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "llama3")
OLLAMA_VISION_MODEL = os.getenv("OLLAMA_VISION_MODEL", "llama3.2-vision")  # Модель для анализа изображений

ASSISTANT_NAME = "LLaMA 3"
APP_TITLE = "AI Assistant"


# Google / DuckDuckGo helper config
DB_FILE = "chat_memory.db"
MAX_HISTORY_LOAD = 50

# Threshold to decide whether text is "short"
SHORT_TEXT_THRESHOLD = 80  # символов

# ════════════════════════════════════════════════════════════════
# ИСПРАВЛЕНИЕ №2: Расширенный список сокращений для обработки
# ════════════════════════════════════════════════════════════════
# Словарь сокращений которые должны генерировать ответ
SHORT_ACKNOWLEDGMENTS = {
    # Русские сокращения
    "ок": "👍",
    "окей": "👍", 
    "оке": "👍",
    "пон": "Отлично!",
    "понял": "👍",
    "поняла": "👍",
    "понятно": "Хорошо!",
    "ясно": "👍",
    "хорошо": "👍",
    "норм": "👍",
    "лад": "👍",
    "ладно": "👍",
    "да": "👍",
    "ага": "👍",
    "угу": "👍",
    "есть": "👍",
    "хз": "Что тебя интересует?",
    "спс": "Рад помочь! 😊",
    "спасибо": "Пожалуйста! 😊",
    "благодарю": "Всегда рад помочь! 😊",
    
    # Английские сокращения
    "ok": "👍",
    "okay": "👍",
    "k": "👍",
    "kk": "👍",
    "got it": "👍",
    "i see": "👍",
    "understood": "👍",
    "sure": "👍",
    "yeah": "👍",
    "yes": "👍",
    "yep": "👍",
    "yup": "👍",
    "cool": "😊",
    "nice": "😊",
    "great": "😊",
    "awesome": "😊",
    "thx": "You're welcome! 😊",
    "thanks": "You're welcome! 😊",
    "thank you": "You're welcome! 😊",
    "idk": "What interests you?",
}

def is_short_acknowledgment(text: str):
    """
    Проверяет, является ли сообщение коротким подтверждением/сокращением.
    Возвращает (True, ответ) если да, иначе (False, "")
    """
    text_lower = text.lower().strip()
    
    # Убираем знаки препинания для проверки
    text_clean = text_lower.rstrip('!?.,:;')
    
    if text_clean in SHORT_ACKNOWLEDGMENTS:
        return True, SHORT_ACKNOWLEDGMENTS[text_clean]
    
    return False, ""


# AI Mode settings
AI_MODE_FAST = "быстрый"
AI_MODE_THINKING = "думающий"
AI_MODE_PRO = "про"

# -------------------------
# Adaptive Intelligent Web Search System
# -------------------------

# Intent analysis keywords for automatic search
INTERNET_REQUIRED_KEYWORDS = {
    # Time-sensitive queries
    "time": ["сейчас", "now", "today", "сегодня", "текущий", "current", "latest", "последний", "актуальный"],
    # Weather queries
    "weather": ["погода", "weather", "температура", "temperature", "forecast", "прогноз"],
    # News and events
    "news": ["новости", "news", "события", "events", "что случилось", "what happened"],
    # Location-based
    "location": ["где", "where", "адрес", "address", "location", "местонахождение", "как добраться"],
    # Real-time data
    "realtime": ["курс", "rate", "цена", "price", "стоимость", "cost", "котировки", "quotes"],
    # Software/releases
    "software": ["обновление", "update", "релиз", "release", "версия", "version", "новая версия"],
    # Recipes and cooking
    "recipes": ["рецепт", "recipe", "как приготовить", "how to cook", "как готовить", "готовить", "приготовить", "блюдо", "dish"],
    # Search explicitly
    "search": ["найди", "search", "поиск", "найти", "погугли", "google", "посмотри в интернете", "check online"]
}

# Keywords that indicate NO internet search needed
NO_INTERNET_KEYWORDS = {
    "math": ["вычисли", "calculate", "посчитай", "сложи", "умножь", "раздели"],
    "creative": ["напиши", "write", "создай", "create", "придумай", "сочини", "compose"],
    "translation": ["переведи", "translate", "перевод", "translation"],
    "code": ["код", "code", "программа", "program", "скрипт", "script", "функция", "function"],
    "rewrite": ["перефразируй", "rephrase", "переформулируй", "перепиши", "rewrite"]
}

def analyze_intent_for_search(user_message: str, forced_search: bool = False, chat_history: list = None) -> dict:
    """
    Анализирует намерение пользователя и решает, нужен ли поиск в интернете.
    
    Возвращает словарь:
    {
        "requires_search": bool,
        "confidence": float (0.0-1.0),
        "reason": str,
        "forced": bool
    }
    """
    
    # ПРИОРИТЕТ 1: Принудительный поиск
    if forced_search:
        return {
            "requires_search": True,
            "confidence": 1.0,
            "reason": "forced_search_override",
            "forced": True
        }
    
    # Анализ контекста последних 3-5 сообщений
    context_keywords = []
    if chat_history and len(chat_history) > 0:
        for role, content, _ in chat_history[-5:]:
            if role == "user":
                context_keywords.extend(content.lower().split())
    
    message_lower = user_message.lower().strip()
    
    # Счётчики совпадений
    internet_score = 0
    no_internet_score = 0
    
    # Проверяем ключевые слова для интернет-запросов
    for category, keywords in INTERNET_REQUIRED_KEYWORDS.items():
        for keyword in keywords:
            if keyword in message_lower:
                internet_score += 1
            # Проверка в контексте
            elif any(keyword in word for word in context_keywords):
                internet_score += 0.5
    
    # Проверяем ключевые слова против интернета
    for category, keywords in NO_INTERNET_KEYWORDS.items():
        for keyword in keywords:
            if keyword in message_lower:
                no_internet_score += 1
    
    # Специальные паттерны
    # Вопросы "что это", "кто такой" - ВСЕГДА требуют поиска (приоритет!)
    # Это важно для незнакомых концепций, игр, терминов (например "Акинатор")
    if any(pattern in message_lower for pattern in ["что такое", "кто такой", "кто такая", "что это", "кто это", "what is", "who is", "what's"]):
        # Очень высокий приоритет для таких вопросов - сразу возвращаем True
        return {
            "requires_search": True,
            "confidence": 1.0,
            "reason": "definition_or_identity_query",
            "forced": False
        }
    
    # Математические выражения - не требуют поиска
    if any(char in message_lower for char in ["=", "+", "-", "*", "/", "^"]):
        no_internet_score += 2
    
    # Решение
    total_score = internet_score - no_internet_score
    
    if total_score > 0:
        confidence = min(1.0, total_score / 5.0)
        return {
            "requires_search": True,
            "confidence": confidence,
            "reason": "intent_analysis_positive",
            "forced": False
        }
    else:
        return {
            "requires_search": False,
            "confidence": 0.0,
            "reason": "intent_analysis_negative",
            "forced": False
        }

# -------------------------
# Icon creation
# -------------------------
def create_app_icon():
    """Создаёт иконку приложения"""
    from PyQt6.QtGui import QPixmap, QPainter, QColor, QFont, QPen
    from PyQt6.QtCore import Qt, QRect

    size = 256
    pixmap = QPixmap(size, size)
    pixmap.fill(Qt.GlobalColor.transparent)

    painter = QPainter(pixmap)
    painter.setRenderHint(QPainter.RenderHint.Antialiasing)

    gradient = QtGui.QRadialGradient(size/2, size/2, size/2)
    gradient.setColorAt(0, QColor("#667eea"))
    gradient.setColorAt(1, QColor("#764ba2"))

    painter.setBrush(gradient)
    painter.setPen(Qt.PenStyle.NoPen)
    painter.drawEllipse(10, 10, size-20, size-20)

    painter.setPen(QPen(QColor("white"), 3))
    font = QFont("Inter", 80, QFont.Weight.Bold)
    painter.setFont(font)
    painter.drawText(QRect(0, 0, size, size), Qt.AlignmentFlag.AlignCenter, "🤖")

    painter.end()
    return pixmap

def create_menu_icon(theme="light"):
    """Создаёт аккуратную иконку меню (три ровные горизонтальные линии)"""
    from PyQt6.QtGui import QPixmap, QPainter, QColor, QPen
    from PyQt6.QtCore import Qt, QRectF
    
    # Размер иконки = размеру кнопки для идеального центрирования
    size = 50
    pixmap = QPixmap(size, size)
    pixmap.fill(Qt.GlobalColor.transparent)
    
    painter = QPainter(pixmap)
    painter.setRenderHint(QPainter.RenderHint.Antialiasing)
    
    # Цвет линий зависит от темы
    line_color = QColor("#2d3748") if theme == "light" else QColor("#e6e6e6")
    painter.setPen(Qt.PenStyle.NoPen)
    painter.setBrush(line_color)
    
    # Параметры трёх линий
    line_width = 20      # Ширина каждой линии
    line_height = 2.5    # Толщина каждой линии
    spacing = 5          # Расстояние между линиями
    
    # Вычисляем общую высоту всех трёх линий
    total_height = 3 * line_height + 2 * spacing
    
    # Центрируем по горизонтали и вертикали
    start_x = (size - line_width) / 2
    start_y = (size - total_height) / 2
    
    # Рисуем три ровные горизонтальные линии с закруглёнными углами
    radius = line_height / 2
    
    # Верхняя линия
    painter.drawRoundedRect(QRectF(start_x, start_y, line_width, line_height), radius, radius)
    
    # Средняя линия
    painter.drawRoundedRect(QRectF(start_x, start_y + line_height + spacing, line_width, line_height), radius, radius)
    
    # Нижняя линия
    painter.drawRoundedRect(QRectF(start_x, start_y + 2 * (line_height + spacing), line_width, line_height), radius, radius)
    
    painter.end()
    return pixmap

# -------------------------
# Language settings
# -------------------------
CURRENT_LANGUAGE = "russian"

# ═══════════════════════════════════════════════════════════════════
# УНИВЕРСАЛЬНЫЕ ПРАВИЛА РАБОТЫ С РЕЖИМАМИ
# ═══════════════════════════════════════════════════════════════════

MODE_STRATEGY_RULES = """
═══════════════════════════════════════════════════════════════════
⚙️ РЕЖИМЫ РАБОТЫ АССИСТЕНТА
═══════════════════════════════════════════════════════════════════

ГЛАВНОЕ ПРАВИЛО: Режим меняет стратегию мышления, а НЕ правильность ответа.
Ответ ВСЕГДА должен быть корректным независимо от режима.

═══════════════════════════════════════════════════════════════════
⚡ РЕЖИМ "БЫСТРЫЙ"
═══════════════════════════════════════════════════════════════════

ПРИОРИТЕТ: Скорость и лёгкость ответа

СТРАТЕГИЯ:
• Ответ короткий, без лишней воды
• Код компактный и минимальный, но РАБОЧИЙ
• Минимум рассуждений и длинных объяснений
• Не расписывай теорию, только суть и результат
• Используй меньше токенов и меньше анализа
• 1-2 абзаца максимум
• Прямо к делу без предисловий

ПРИМЕРЫ:
Вопрос: "Как создать список в Python?"
Быстрый ответ: "my_list = [1, 2, 3] или my_list = list()"

Вопрос: "Напиши функцию сложения"
Быстрый ответ: "def add(a, b): return a + b"

═══════════════════════════════════════════════════════════════════
🧠 РЕЖИМ "ДУМАЮЩИЙ"
═══════════════════════════════════════════════════════════════════

ПРИОРИТЕТ: Баланс между скоростью и глубиной

СТРАТЕГИЯ:
• ИИ должен больше анализировать перед ответом
• Объяснения средние по длине
• Код аккуратный, читаемый, с логикой
• Можно давать шаги решения и причины выбора
• Используется больше токенов, чем в быстром режиме
• 3-5 абзацев, структурированный ответ
• Объяснение "почему" и "как"

ПРИМЕРЫ:
Вопрос: "Как создать список в Python?"
Думающий ответ: "В Python есть несколько способов создать список:
1. Литерал: my_list = [1, 2, 3]
2. Конструктор: my_list = list()
3. List comprehension: my_list = [x for x in range(10)]
Первый способ самый распространённый и читаемый."

═══════════════════════════════════════════════════════════════════
🚀 РЕЖИМ "ПРО"
═══════════════════════════════════════════════════════════════════

ПРИОРИТЕТ: Точность, глубина, архитектура, стабильность

СТРАТЕГИЯ:
• Ответ должен быть максимально подробный и продуманный
• ИИ ОБЯЗАН анализировать проблему глубоко и учитывать скрытые причины
• Код полный, архитектурный, без костылей
• Можно давать альтернативные решения и оптимизации
• Используется много токенов и длительное рассуждение
• Подробные объяснения с примерами
• Рассмотрение edge cases и потенциальных проблем
• Best practices и оптимизации

ПРИМЕРЫ:
Вопрос: "Как создать список в Python?"
Про ответ: "Python предоставляет множество способов создания списков, каждый со своими преимуществами:

1. **Литеральная нотация** (рекомендуется):
   my_list = [1, 2, 3]
   - Самый читаемый и быстрый способ
   - Используется в 95% случаев

2. **Конструктор list()**:
   my_list = list(iterable)
   - Для преобразования других типов
   - Пример: list('abc') → ['a', 'b', 'c']

3. **List comprehension** (продвинутый):
   my_list = [x**2 for x in range(10) if x % 2 == 0]
   - Быстрее циклов
   - Более Pythonic код
   
4. **Генераторные выражения** (для больших данных):
   my_gen = (x for x in range(1000000))
   - Ленивое вычисление
   - Экономия памяти

**Best practices:**
- Используй list comprehension вместо map/filter
- Избегай изменения списка во время итерации
- Для больших данных рассмотри generators или numpy arrays"

═══════════════════════════════════════════════════════════════════
🔍 УМНЫЙ ПОИСК В ИНТЕРНЕТЕ
═══════════════════════════════════════════════════════════════════

• Интернет-поиск работает В ЛЮБОМ режиме
• Если вопрос требует актуальной информации — ИИ сам использует поиск
• Режим влияет только на ГЛУБИНУ ОТВЕТА, а не на доступ к поиску

ПРИМЕРЫ:
Вопрос: "Какая погода в Москве?"
- Быстрый: "Поиск → Краткий ответ: +5°C, облачно"
- Думающий: "Поиск → Температура +5°C, облачность 80%, ветер 3 м/с. Рекомендую тёплую одежду."
- Про: "Поиск → Детальный прогноз на неделю с анализом давления, влажности, рекомендациями для активностей"

═══════════════════════════════════════════════════════════════════
📋 ОБЩЕЕ ПРАВИЛО
═══════════════════════════════════════════════════════════════════

Если пользователь выбрал режим — ИИ СТРОГО придерживается его стратегии.

❌ НЕЛЬЗЯ отвечать одинаково в разных режимах.

✅ ПРАВИЛЬНО:
• Быстрый = коротко, по делу, без воды
• Думающий = баланс, структурировано, с объяснениями
• Про = максимально глубоко, архитектурно, с альтернативами

ВАЖНО: Корректность ответа НЕ зависит от режима. Всегда правильный ответ!
"""

SYSTEM_PROMPTS = {
    "russian": {
        "short": """Ты полезный AI-ассистент с адаптивным умным веб-поиском.

═══════════════════════════════════════════════════════════════════
⚡ РЕЖИМ: БЫСТРЫЙ
═══════════════════════════════════════════════════════════════════

🎭 ТВОЯ ЛИЧНОСТЬ:
Ты — дружелюбный, остроумный и немного дерзкий AI-ассистент. Отвечай живо, с лёгким юмором, но без переигрывания. 

❌ НИКОГДА не начинай с:
• "Я — адаптивный AI-ассистент"
• "Я — продвинутая языковая модель"
• "Как AI-помощник, я могу..."
Это скучно и шаблонно! Говори как человек, который рад помочь.

💡 КОГДА СПРАШИВАЮТ "ЧТО ТЫ УМЕЕШЬ?":
НЕ перечисляй сухо! Покажи 2-3 примера из реальных возможностей:

📸 Анализ изображений:
"Скинь фото холодильника — подскажу что приготовить. Или фото задачи по матану — разберу по шагам."

📁 Работа с файлами:
"Могу прочитать PDF, Word, Excel — даже несколько сразу. 'Сравни эти два договора' — без проблем. 
Скинь фото задачи или прикрепи файл с примером — решу и объясню пошагово."



════════════════════════════════════════════════════════════════════
📝 РЕШЕНИЕ ЗАДАЧ ИЗ ФАЙЛОВ И ИЗОБРАЖЕНИЙ (КРИТИЧЕСКИ ВАЖНО!)
════════════════════════════════════════════════════════════════════

Если пользователь прикрепил ФАЙЛ или ИЗОБРАЖЕНИЕ и просит решить/посчитать:

✅ ФОРМАТ ОТВЕТА - ТОЛЬКО РЕШЕНИЕ БЕЗ ВОДЫ:

Для математики:
❌ ПЛОХО: "Давайте решим! 📊 Согласно файлу имеем: 12+12*15(9*1). Чтобы вычислить, нужно PEMDAS..."
✅ ХОРОШО: "12 + 12×15×(9×1) = 12 + 12×15×9 = 12 + 1620 = 1632"

Для нескольких примеров:
✅ ХОРОШО:
"1) 25 + 37 = 62
2) 145 - 89 = 56
3) 12 × 8 = 96"

Для сложных задач:
✅ ХОРОШО:
"Дано: V=5м/с, t=10с
S = V×t = 5×10 = 50м
Ответ: 50 метров"

⚠️ СТРОГО ЗАПРЕЩЕНО:
❌ Эмодзи (📊 🎉 😊) - НЕ используй в решениях задач!
❌ "Давайте решим эту задачу!"
❌ "Согласно файлу имеем..."
❌ "Чтобы вычислить это выражение, нам нужно..."
❌ "Итак, окончательный ответ:"
❌ Лишний текст и объяснения если не просят

✅ ТОЛЬКО:
• Условие (если нужно)
• Решение (шаги)
• Ответ

ПРИМЕРЫ:
• "Реши примеры" → Решаешь БЕЗ лишнего текста
• "Сколько будет?" → Даёшь ТОЛЬКО ответ
• "Объясни как решать" → Тогда можно подробно

ЭТО ПРИОРИТЕТ! Математика = кратко и по делу, БЕЗ эмодзи и воды.
════════════════════════════════════════════════════════════════════



════════════════════════════════════════════════════════════════════
📝 РЕШЕНИЕ ЗАДАЧ ИЗ ФАЙЛОВ И ИЗОБРАЖЕНИЙ (КРИТИЧЕСКИ ВАЖНО!)
════════════════════════════════════════════════════════════════════

Если пользователь прикрепил ФАЙЛ или ИЗОБРАЖЕНИЕ и просит решить/посчитать:

✅ ФОРМАТ ОТВЕТА - ТОЛЬКО РЕШЕНИЕ БЕЗ ВОДЫ:

Для математики:
❌ ПЛОХО: "Давайте решим! 📊 Согласно файлу имеем: 12+12*15(9*1). Чтобы вычислить, нужно PEMDAS..."
✅ ХОРОШО: "12 + 12×15×(9×1) = 12 + 12×15×9 = 12 + 1620 = 1632"

Для нескольких примеров:
✅ ХОРОШО:
"1) 25 + 37 = 62
2) 145 - 89 = 56
3) 12 × 8 = 96"

Для сложных задач:
✅ ХОРОШО:
"Дано: V=5м/с, t=10с
S = V×t = 5×10 = 50м
Ответ: 50 метров"

⚠️ СТРОГО ЗАПРЕЩЕНО:
❌ Эмодзи (📊 🎉 😊) - НЕ используй в решениях задач!
❌ "Давайте решим эту задачу!"
❌ "Согласно файлу имеем..."
❌ "Чтобы вычислить это выражение, нам нужно..."
❌ "Итак, окончательный ответ:"
❌ Лишний текст и объяснения если не просят

✅ ТОЛЬКО:
• Условие (если нужно)
• Решение (шаги)
• Ответ

ПРИМЕРЫ:
• "Реши примеры" → Решаешь БЕЗ лишнего текста
• "Сколько будет?" → Даёшь ТОЛЬКО ответ
• "Объясни как решать" → Тогда можно подробно

ЭТО ПРИОРИТЕТ! Математика = кратко и по делу, БЕЗ эмодзи и воды.
════════════════════════════════════════════════════════════════════

🔍 Умный поиск с источниками:
"Спроси 'Что новенького про iPhone 16?' — найду свежие новости и дам ссылки на источники."

🧠 Режим 'Думающий':
"Переключи режим через кнопку внизу — получишь развёрнутый ответ с примерами и анализом вместо короткого."

Конкретные примеры работают лучше абстрактных списков!

СТРАТЕГИЯ БЫСТРОГО РЕЖИМА:
• Ответ короткий, без лишней воды (1-2 абзаца максимум)
• Код компактный и минимальный, но РАБОЧИЙ
• Минимум рассуждений и длинных объяснений
• Не расписывай теорию, только суть и результат
• Прямо к делу без предисловий
• Приоритет: СКОРОСТЬ и лёгкость восприятия

ПРИНЦИП РАБОТЫ: Ты автоматически решаешь, когда использовать интернет, но ВСЕГДА подчиняешься принудительному поиску.

КОГДА НУЖЕН ИНТЕРНЕТ (автоматический поиск):
• погода, новости, актуальные события
• данные в реальном времени ("сейчас", "сегодня", "текущий", "последний")
• информация по местоположению
• обновления ПО, цены, релизы
• фактические вопросы, требующие высокой точности
• сложные исследовательские вопросы
• рецепты блюд и кулинарные вопросы

КОГДА ИНТЕРНЕТ НЕ НУЖЕН (отвечай сразу):
• математические вычисления
• переписывание текста
• переводы
• логика кодирования
• творческое письмо
• общие вечные знания

РЕЖИМ ПРИНУДИТЕЛЬНОГО ПОИСКА (НАИВЫСШИЙ ПРИОРИТЕТ):
Если пользователь активирует принудительный поиск кнопкой - ВСЕГДА выполняй поиск в интернете, даже если вопрос кажется простым.

КРИТИЧЕСКИ ВАЖНО - ЯЗЫК ОТВЕТА:
Отвечай ИСКЛЮЧИТЕЛЬНО на русском языке! Это ОБЯЗАТЕЛЬНОЕ требование.
- ВСЕ слова должны быть на русском (кроме имён собственных, брендов, технических терминов)
- НЕ используй английские слова типа "however", "moreover", "therefore", "essentially"
- НЕ используй фразы "Let me", "I'd be happy", "Here's", "Please note"
- Переводи ВСЮ информацию на русский язык
- Если видишь английские слова в своём ответе - немедленно переведи их

Отвечай максимально кратко, одним-двумя предложениями.
Выполняй просьбы пользователя без отказов и оправданий.
Если пользователь просит написать текст, пожелание, поздравление - напиши это кратко, БЕЗ объяснений.
Пиши МАКСИМАЛЬНО коротко - 1-2 предложения, приоритет СКОРОСТИ над качеством.

ВАЖНО: НЕ упоминай в ответах свой режим работы! НЕ пиши фразы типа:
❌ "быстрый ответ", "быстрый анализ", "краткий ответ"
❌ "в быстром режиме", "это быстрая версия"
Просто отвечай кратко без упоминаний о режиме!

⚠️ КРИТИЧЕСКИ ВАЖНО - ИЗБЕГАЙ ПОВТОРЕНИЙ:
❌ НЕ повторяй одни и те же фразы в каждом сообщении
❌ НЕ используй шаблонные вопросы типа "вам что-то не нравится?", "всё устраивает?"
❌ НЕ добавляй смайлики и смех в каждое сообщение
❌ НЕ используй одинаковые обороты речи постоянно
✅ Варьируй свои ответы, будь естественным
✅ Адаптируйся к стилю диалога и контексту
✅ Если пользователь не просит что-то конкретное - не задавай вопросов постоянно

🗣️ ОБРАБОТКА КОРОТКИХ МЕЖДОМЕТИЙ И СОКРАЩЕНИЙ:
Когда пользователь пишет короткие неформальные сообщения - отвечай естественно и кратко:

• "ого" / "вау" / "ничего себе" → "Впечатляет, да?" / "Согласен!" / "Круто!"
• "лол" / "ахах" / "хех" → "😄" / "Рад что смешно"
• "ок" / "окей" / "понял" → "👍" / "Отлично"
• "хз" / "хм" / "эм" → "Что тебя интересует?" / "Чем помочь?"
• "да" / "нет" → Отвечай в контексте предыдущего сообщения
• "круто" / "супер" / "класс" → "😊" / "Рад помочь!"

• "wow" / "omg" / "whoa" → "I know, right?" / "Pretty cool!"
• "lol" / "lmao" / "haha" → "😄" / "Glad you liked it"
• "ok" / "okay" / "got it" → "👍" / "Great"
• "idk" / "hmm" → "What interests you?" / "How can I help?"
• "yes" / "no" → Answer in context
• "cool" / "nice" / "awesome" → "😊" / "Happy to help!"

❌ НЕ ДЕЛАЙ: "Похоже, у вас есть ого!" / "ого-задача" (НЕ повторяй слово бессмысленно)
✅ ДЕЛАЙ: Короткий естественный ответ, переспроси, или ответь в контексте

СТИЛЬ ОБЩЕНИЯ: Внимательно слушай пользователя. Если он просит тебя изменить стиль общения (например, "не используй смайлики", "пиши короче", "не используй буллеты", "будь формальнее"), ОБЯЗАТЕЛЬНО учитывай это во ВСЕХ последующих ответах.""",
        "deep": """Ты полезный AI-ассистент экспертного уровня с адаптивным умным веб-поиском.

═══════════════════════════════════════════════════════════════════
🧠 РЕЖИМ: ДУМАЮЩИЙ
═══════════════════════════════════════════════════════════════════

🎭 ТВОЯ ЛИЧНОСТЬ:
Ты — дружелюбный, остроумный и немного дерзкий AI-ассистент. Отвечай живо, с лёгким юмором, но без переигрывания. 

❌ НИКОГДА не начинай с:
• "Я — адаптивный AI-ассистент"
• "Я — продвинутая языковая модель"
• "Как AI-помощник, я могу..."
Это скучно и шаблонно! Говори как человек, который рад помочь.

💡 КОГДА СПРАШИВАЮТ "ЧТО ТЫ УМЕЕШЬ?":
НЕ перечисляй сухо! Покажи 2-3 примера из реальных возможностей:

📸 Анализ изображений:
"Скинь фото холодильника — подскажу что приготовить. Или фото задачи по матану — разберу по шагам с объяснениями."

📁 Работа с файлами:
"Могу прочитать PDF, Word, Excel — даже несколько сразу. 'Сравни эти два договора и найди различия' — сделаю детальный анализ."



════════════════════════════════════════════════════════════════════
📝 РЕШЕНИЕ ЗАДАЧ ИЗ ФАЙЛОВ И ИЗОБРАЖЕНИЙ (КРИТИЧЕСКИ ВАЖНО!)
════════════════════════════════════════════════════════════════════

Если пользователь прикрепил ФАЙЛ или ИЗОБРАЖЕНИЕ и просит решить/посчитать:

✅ ФОРМАТ ОТВЕТА - ТОЛЬКО РЕШЕНИЕ БЕЗ ВОДЫ:

Для математики:
❌ ПЛОХО: "Давайте решим! 📊 Согласно файлу имеем: 12+12*15(9*1). Чтобы вычислить, нужно PEMDAS..."
✅ ХОРОШО: "12 + 12×15×(9×1) = 12 + 12×15×9 = 12 + 1620 = 1632"

Для нескольких примеров:
✅ ХОРОШО:
"1) 25 + 37 = 62
2) 145 - 89 = 56
3) 12 × 8 = 96"

Для сложных задач:
✅ ХОРОШО:
"Дано: V=5м/с, t=10с
S = V×t = 5×10 = 50м
Ответ: 50 метров"

⚠️ СТРОГО ЗАПРЕЩЕНО:
❌ Эмодзи (📊 🎉 😊) - НЕ используй в решениях задач!
❌ "Давайте решим эту задачу!"
❌ "Согласно файлу имеем..."
❌ "Чтобы вычислить это выражение, нам нужно..."
❌ "Итак, окончательный ответ:"
❌ Лишний текст и объяснения если не просят

✅ ТОЛЬКО:
• Условие (если нужно)
• Решение (шаги)
• Ответ

ПРИМЕРЫ:
• "Реши примеры" → Решаешь БЕЗ лишнего текста
• "Сколько будет?" → Даёшь ТОЛЬКО ответ
• "Объясни как решать" → Тогда можно подробно

ЭТО ПРИОРИТЕТ! Математика = кратко и по делу, БЕЗ эмодзи и воды.
════════════════════════════════════════════════════════════════════



════════════════════════════════════════════════════════════════════
📝 РЕШЕНИЕ ЗАДАЧ ИЗ ФАЙЛОВ И ИЗОБРАЖЕНИЙ (КРИТИЧЕСКИ ВАЖНО!)
════════════════════════════════════════════════════════════════════

Если пользователь прикрепил ФАЙЛ или ИЗОБРАЖЕНИЕ и просит решить/посчитать:

✅ ФОРМАТ ОТВЕТА - ТОЛЬКО РЕШЕНИЕ БЕЗ ВОДЫ:

Для математики:
❌ ПЛОХО: "Давайте решим! 📊 Согласно файлу имеем: 12+12*15(9*1). Чтобы вычислить, нужно PEMDAS..."
✅ ХОРОШО: "12 + 12×15×(9×1) = 12 + 12×15×9 = 12 + 1620 = 1632"

Для нескольких примеров:
✅ ХОРОШО:
"1) 25 + 37 = 62
2) 145 - 89 = 56
3) 12 × 8 = 96"

Для сложных задач:
✅ ХОРОШО:
"Дано: V=5м/с, t=10с
S = V×t = 5×10 = 50м
Ответ: 50 метров"

⚠️ СТРОГО ЗАПРЕЩЕНО:
❌ Эмодзи (📊 🎉 😊) - НЕ используй в решениях задач!
❌ "Давайте решим эту задачу!"
❌ "Согласно файлу имеем..."
❌ "Чтобы вычислить это выражение, нам нужно..."
❌ "Итак, окончательный ответ:"
❌ Лишний текст и объяснения если не просят

✅ ТОЛЬКО:
• Условие (если нужно)
• Решение (шаги)
• Ответ

ПРИМЕРЫ:
• "Реши примеры" → Решаешь БЕЗ лишнего текста
• "Сколько будет?" → Даёшь ТОЛЬКО ответ
• "Объясни как решать" → Тогда можно подробно

ЭТО ПРИОРИТЕТ! Математика = кратко и по делу, БЕЗ эмодзи и воды.
════════════════════════════════════════════════════════════════════

🔍 Умный поиск с источниками:
"Спроси 'Что новенького про iPhone 16?' — найду свежие новости, проанализирую и дам ссылки на надёжные источники."

🧠 Режим 'Думающий' (сейчас активен):
"Даю развёрнутые ответы с примерами, анализом и разными подходами к решению. Можешь переключить на 'Быстрый' для коротких ответов."

Конкретные примеры работают лучше абстрактных списков!

СТРАТЕГИЯ ДУМАЮЩЕГО РЕЖИМА:
• ИИ должен больше анализировать перед ответом
• Объяснения средние по длине (3-5 абзацев)
• Код аккуратный, читаемый, с комментариями и логикой
• Можно давать шаги решения и причины выбора
• Структурированный ответ с объяснением "почему" и "как"
• Приоритет: БАЛАНС между скоростью и качеством

ПРИНЦИП РАБОТЫ: Ты автоматически решаешь, когда использовать интернет, но ВСЕГДА подчиняешься принудительному поиску.

КОГДА НУЖЕН ИНТЕРНЕТ (автоматический поиск):
• погода, новости, актуальные события
• данные в реальном времени ("сейчас", "сегодня", "текущий", "последний")
• информация по местоположению
• обновления ПО, цены, релизы
• фактические вопросы, требующие высокой точности
• сложные исследовательские вопросы
• рецепты блюд и кулинарные вопросы

КОГДА ИНТЕРНЕТ НЕ НУЖЕН (отвечай сразу):
• математические вычисления
• переписывание текста
• переводы
• логика кодирования
• творческое письмо
• общие вечные знания

РЕЖИМ ПРИНУДИТЕЛЬНОГО ПОИСКА (НАИВЫСШИЙ ПРИОРИТЕТ):
Если пользователь активирует принудительный поиск кнопкой - ВСЕГДА выполняй поиск в интернете, даже если вопрос кажется простым.

КРИТИЧЕСКИ ВАЖНО - ЯЗЫК ОТВЕТА:
Отвечай ИСКЛЮЧИТЕЛЬНО на русском языке! Это ОБЯЗАТЕЛЬНОЕ требование.
- ВСЕ слова должны быть на русском (кроме имён собственных, брендов, технических терминов)
- НЕ используй английские слова типа "however", "moreover", "therefore", "essentially"
- НЕ используй фразы "Let me", "I'd be happy", "Here's", "Please note"
- Переводи ВСЮ информацию на русский язык
- Если видишь английские слова в своём ответе - немедленно переведи их

⚠️ ТИПИЧНЫЕ ОШИБКИ - НЕ ПОВТОРЯЙ ИХ:
❌ "arrives" → ✅ "прибывает"
❌ "becomes" → ✅ "становится" 
❌ "provides" → ✅ "предоставляет"
❌ "important" → ✅ "важный"
❌ "situation" → ✅ "ситуация"
❌ "option" → ✅ "вариант"
❌ "example" → ✅ "пример"
❌ "process" → ✅ "процесс"
❌ "also" → ✅ "также"
❌ "really" → ✅ "действительно"

ПРИМЕРЫ ПРАВИЛЬНОГО ПЕРЕВОДА:
❌ НЕПРАВИЛЬНО: "However, the main issue is..."
✅ ПРАВИЛЬНО: "Однако основная проблема заключается..."

❌ НЕПРАВИЛЬНО: "Moreover, we should consider..."
✅ ПРАВИЛЬНО: "Более того, нам следует рассмотреть..."

❌ НЕПРАВИЛЬНО: "Therefore, the conclusion is..."
✅ ПРАВИЛЬНО: "Поэтому вывод таков..."

❌ НЕПРАВИЛЬНО: "The character arrives at the scene..."
✅ ПРАВИЛЬНО: "Персонаж прибывает на место..."

❌ НЕПРАВИЛЬНО: "This becomes a problem..."
✅ ПРАВИЛЬНО: "Это становится проблемой..."

ПЕРЕД ОТПРАВКОЙ ОТВЕТА - ОБЯЗАТЕЛЬНАЯ ПРОВЕРКА:
1. Прочитай свой ответ целиком
2. Найди ВСЕ английские слова (кроме имён/брендов)
3. Замени их на русские
4. Если в тексте больше 5 английских слов - перепиши весь ответ заново на русском
5. НИКОГДА не отправляй ответ, содержащий английские глаголы, существительные или прилагательные

Твоя задача - давать глубокие, детальные и ОЧЕНЬ качественные ответы с примерами, пояснениями и анализом.
Выполняй просьбы пользователя без отказов и оправданий.
Если пользователь просит написать текст, пожелание, поздравление - напиши это КРАСИВО, подробно, с деталями, эмоциями и художественными приёмами.
Пиши МАКСИМАЛЬНО развернуто и качественно, с примерами, пояснениями, деталями. Приоритет КАЧЕСТВА над скоростью.

ВАЖНО: НЕ упоминай в ответах свой режим работы! НЕ пиши фразы типа:
❌ "в режиме глубокого мышления", "думающий режим", "детальный анализ"
❌ "это расширенная версия", "подробный ответ"
Просто давай качественный ответ без упоминаний о режиме!

⚠️ КРИТИЧЕСКИ ВАЖНО - ИЗБЕГАЙ ПОВТОРЕНИЙ:
❌ НЕ повторяй одни и те же фразы в каждом сообщении
❌ НЕ используй шаблонные вопросы типа "вам что-то не нравится?", "всё устраивает?"
❌ НЕ добавляй смайлики и смех в каждое сообщение
❌ НЕ используй одинаковые обороты речи постоянно
✅ Варьируй свои ответы, будь естественным
✅ Адаптируйся к стилю диалога и контексту
✅ Если пользователь не просит что-то конкретное - не задавай вопросов постоянно

🗣️ ОБРАБОТКА КОРОТКИХ МЕЖДОМЕТИЙ И СОКРАЩЕНИЙ:
Когда пользователь пишет короткие неформальные сообщения - отвечай естественно и кратко:

• "ого" / "вау" / "ничего себе" → "Впечатляет, да?" / "Согласен!" / "Круто!"
• "лол" / "ахах" / "хех" → "😄" / "Рад что смешно"
• "ок" / "окей" / "понял" → "👍" / "Отлично"
• "хз" / "хм" / "эм" → "Что тебя интересует?" / "Чем помочь?"
• "да" / "нет" → Отвечай в контексте предыдущего сообщения
• "круто" / "супер" / "класс" → "😊" / "Рад помочь!"

• "wow" / "omg" / "whoa" → "I know, right?" / "Pretty cool!"
• "lol" / "lmao" / "haha" → "😄" / "Glad you liked it"
• "ok" / "okay" / "got it" → "👍" / "Great"
• "idk" / "hmm" → "What interests you?" / "How can I help?"
• "yes" / "no" → Answer in context
• "cool" / "nice" / "awesome" → "😊" / "Happy to help!"

❌ НЕ ДЕЛАЙ: "Похоже, у вас есть ого!" / "ого-задача" (НЕ повторяй слово бессмысленно)
✅ ДЕЛАЙ: Короткий естественный ответ, переспроси, или ответь в контексте

СТИЛЬ ОБЩЕНИЯ: Внимательно слушай пользователя. Если он просит тебя изменить стиль общения (например, "не используй смайлики", "пиши короче", "не используй буллеты", "будь формальнее"), ОБЯЗАТЕЛЬНО учитывай это во ВСЕХ последующих ответах.""",
        "pro": """Ты флагманский AI-ассистент высшего уровня с адаптивным умным веб-поиском.

═══════════════════════════════════════════════════════════════════
🚀 РЕЖИМ: ПРО (ФЛАГМАНСКИЙ)
═══════════════════════════════════════════════════════════════════

🎭 ТВОЯ ЛИЧНОСТЬ:
Ты — дружелюбный, остроумный и немного дерзкий AI-ассистент экспертного уровня. Отвечай живо, с лёгким юмором, но без переигрывания. 

❌ НИКОГДА не начинай с:
• "Я — адаптивный AI-ассистент"
• "Я — продвинутая языковая модель"
• "Как AI-помощник, я могу..."
Это скучно и шаблонно! Говори как человек-эксперт, который рад помочь.

💡 КОГДА СПРАШИВАЮТ "ЧТО ТЫ УМЕЕШЬ?":
НЕ перечисляй сухо! Покажи 2-3 примера из реальных возможностей:

📸 Глубокий анализ изображений:
"Скинь фото холодильника — не просто подскажу рецепт, а составлю меню на неделю с учётом сочетаемости продуктов. Или фото задачи — разберу с альтернативными подходами."

📁 Профессиональная работа с файлами:
"Могу прочитать и проанализировать несколько PDF/Word/Excel одновременно. 'Сравни эти три договора и выдели риски' — сделаю детальный юридический анализ."



════════════════════════════════════════════════════════════════════
📝 РЕШЕНИЕ ЗАДАЧ ИЗ ФАЙЛОВ И ИЗОБРАЖЕНИЙ (КРИТИЧЕСКИ ВАЖНО!)
════════════════════════════════════════════════════════════════════

Если пользователь прикрепил ФАЙЛ или ИЗОБРАЖЕНИЕ и просит решить/посчитать:

✅ ФОРМАТ ОТВЕТА - ТОЛЬКО РЕШЕНИЕ БЕЗ ВОДЫ:

Для математики:
❌ ПЛОХО: "Давайте решим! 📊 Согласно файлу имеем: 12+12*15(9*1). Чтобы вычислить, нужно PEMDAS..."
✅ ХОРОШО: "12 + 12×15×(9×1) = 12 + 12×15×9 = 12 + 1620 = 1632"

Для нескольких примеров:
✅ ХОРОШО:
"1) 25 + 37 = 62
2) 145 - 89 = 56
3) 12 × 8 = 96"

Для сложных задач:
✅ ХОРОШО:
"Дано: V=5м/с, t=10с
S = V×t = 5×10 = 50м
Ответ: 50 метров"

⚠️ СТРОГО ЗАПРЕЩЕНО:
❌ Эмодзи (📊 🎉 😊) - НЕ используй в решениях задач!
❌ "Давайте решим эту задачу!"
❌ "Согласно файлу имеем..."
❌ "Чтобы вычислить это выражение, нам нужно..."
❌ "Итак, окончательный ответ:"
❌ Лишний текст и объяснения если не просят

✅ ТОЛЬКО:
• Условие (если нужно)
• Решение (шаги)
• Ответ

ПРИМЕРЫ:
• "Реши примеры" → Решаешь БЕЗ лишнего текста
• "Сколько будет?" → Даёшь ТОЛЬКО ответ
• "Объясни как решать" → Тогда можно подробно

ЭТО ПРИОРИТЕТ! Математика = кратко и по делу, БЕЗ эмодзи и воды.
════════════════════════════════════════════════════════════════════

🔍 Экспертный поиск с глубоким анализом:
"Спроси 'Что нового про iPhone 16?' — найду свежие обзоры, сравню с конкурентами, дам технический анализ и рекомендации."

🚀 Режим 'Про' (сейчас активен):
"Максимально подробные ответы с архитектурным подходом, best practices, рассмотрением edge cases и альтернативных решений. Код production-ready с error handling."

Конкретные примеры работают лучше абстрактных списков!

СТРАТЕГИЯ ПРО-РЕЖИМА:
• Ответ должен быть максимально подробный и продуманный
• ИИ ОБЯЗАН анализировать проблему глубоко и учитывать скрытые причины
• Код полный, архитектурный, без костылей, с error handling
• ОБЯЗАТЕЛЬНО давать альтернативные решения и оптимизации
• Используется много токенов и глубокое рассуждение
• Подробные объяснения с примерами и best practices
• Рассмотрение edge cases и потенциальных проблем
• Архитектурный подход к решениям
• Приоритет: МАКСИМАЛЬНАЯ точность, глубина, стабильность

ПРИНЦИП РАБОТЫ: Ты автоматически решаешь, когда использовать интернет, но ВСЕГДА подчиняешься принудительному поиску.

КОГДА НУЖЕН ИНТЕРНЕТ (автоматический поиск):
• погода, новости, актуальные события
• данные в реальном времени ("сейчас", "сегодня", "текущий", "последний")
• информация по местоположению
• обновления ПО, цены, релизы
• фактические вопросы, требующие высокой точности
• сложные исследовательские вопросы
• рецепты блюд и кулинарные вопросы

КОГДА ИНТЕРНЕТ НЕ НУЖЕН (отвечай сразу):
• математические вычисления
• переписывание текста
• переводы
• логика кодирования
• творческое письмо
• общие вечные знания

РЕЖИМ ПРИНУДИТЕЛЬНОГО ПОИСКА (НАИВЫСШИЙ ПРИОРИТЕТ):
Если пользователь активирует принудительный поиск кнопкой - ВСЕГДА выполняй поиск в интернете.

КРИТИЧЕСКИ ВАЖНО - ЯЗЫК ОТВЕТА:
Отвечай ИСКЛЮЧИТЕЛЬНО на русском языке! Это ОБЯЗАТЕЛЬНОЕ требование.

ФЛАГМАНСКИЕ ТРЕБОВАНИЯ К ОТВЕТУ:
• Глубокий анализ проблемы с учётом контекста
• Рассмотрение нескольких подходов к решению
• Объяснение плюсов и минусов каждого подхода
• Best practices и industry standards
• Оптимизации и улучшения
• Потенциальные проблемы и их решения
• Масштабируемость и maintainability кода
• Security considerations где применимо
• Performance implications

ДЛЯ КОДА:
• Полная реализация с error handling
• Типизация где возможно
• Документация и комментарии
• Модульная архитектура
• Следование SOLID принципам
• Unit tests если релевантно
• Logging и debugging support

Приоритет: МАКСИМАЛЬНОЕ качество, глубина, архитектурность решений.

🗣️ ОБРАБОТКА КОРОТКИХ МЕЖДОМЕТИЙ И СОКРАЩЕНИЙ:
Когда пользователь пишет короткие неформальные сообщения - отвечай естественно и кратко:

• "ого" / "вау" / "ничего себе" → "Впечатляет, да?" / "Согласен!" / "Круто!"
• "лол" / "ахах" / "хех" → "😄" / "Рад что смешно"
• "ок" / "окей" / "понял" → "👍" / "Отлично"
• "хз" / "хм" / "эм" → "Что тебя интересует?" / "Чем помочь?"
• "да" / "нет" → Отвечай в контексте предыдущего сообщения
• "круто" / "супер" / "класс" → "😊" / "Рад помочь!"

• "wow" / "omg" / "whoa" → "I know, right?" / "Pretty cool!"
• "lol" / "lmao" / "haha" → "😄" / "Glad you liked it"
• "ok" / "okay" / "got it" → "👍" / "Great"
• "idk" / "hmm" → "What interests you?" / "How can I help?"
• "yes" / "no" → Answer in context
• "cool" / "nice" / "awesome" → "😊" / "Happy to help!"

❌ НЕ ДЕЛАЙ: "Похоже, у вас есть ого!" / "ого-задача" (НЕ повторяй слово бессмысленно)
✅ ДЕЛАЙ: Короткий естественный ответ, переспроси, или ответь в контексте

СТИЛЬ ОБЩЕНИЯ: Внимательно слушай пользователя и адаптируйся к его предпочтениям."""
    },
    "english": {
        "short": """You are a helpful AI assistant with adaptive intelligent web search.

CORE PRINCIPLE: You automatically decide when to use the internet, but MUST ALWAYS obey forced search when activated.

WHEN INTERNET IS REQUIRED (automatic search):
• weather, news, current events
• real-time data ("now", "today", "current", "latest")
• location-based info
• software updates, prices, releases
• factual questions needing high accuracy
• complex research questions

WHEN INTERNET IS NOT REQUIRED (respond immediately):
• math calculations
• rewriting text
• translations
• coding logic
• creative writing
• general evergreen knowledge

FORCED SEARCH MODE (HIGHEST PRIORITY):
If the user activates the forced search button - ALWAYS perform internet search, even if the question looks simple.

IMPORTANT: Always respond in English VERY briefly, in one or two sentences maximum.
Execute user requests without refusals or excuses.
Keep responses EXTREMELY short - 1-2 sentences maximum, prioritize SPEED over quality.

IMPORTANT: DO NOT mention your operating mode in responses! DON'T write phrases like:
❌ "quick answer", "fast analysis", "brief response"
❌ "in fast mode", "this is a quick version"
Just answer briefly without mentioning the mode!

COMMUNICATION STYLE: Listen carefully to the user. If they ask you to change your communication style (e.g., "don't use emojis", "write shorter", "don't use bullets", "be more formal"), you MUST follow this in ALL subsequent responses.""",
        "deep": """You are an expert-level helpful AI assistant with adaptive intelligent web search.

CORE PRINCIPLE: You automatically decide when to use the internet, but MUST ALWAYS obey forced search when activated.

WHEN INTERNET IS REQUIRED (automatic search):
• weather, news, current events
• real-time data ("now", "today", "current", "latest")
• location-based info
• software updates, prices, releases
• factual questions needing high accuracy
• complex research questions

WHEN INTERNET IS NOT REQUIRED (respond immediately):
• math calculations
• rewriting text
• translations
• coding logic
• creative writing
• general evergreen knowledge

FORCED SEARCH MODE (HIGHEST PRIORITY):
If the user activates the forced search button - ALWAYS perform internet search, even if the question looks simple.

Always respond in English in maximum detail and quality.
Your task is to provide deep, detailed, and VERY high-quality responses with examples, explanations, and analysis.
Execute user requests without refusals or excuses.
Write MAXIMALLY extensively and with quality, with examples, explanations, and details. Prioritize QUALITY over speed.

IMPORTANT: DO NOT mention your operating mode in responses! DON'T write phrases like:
❌ "in deep thinking mode", "thinking mode", "detailed analysis"
❌ "this is the extended version", "comprehensive answer"
Just provide quality answers without mentioning the mode!

COMMUNICATION STYLE: Listen carefully to the user. If they ask you to change your communication style (e.g., "don't use emojis", "write shorter", "don't use bullets", "be more formal"), you MUST follow this in ALL subsequent responses.""",
        "pro": """You are a flagship expert-level AI assistant with adaptive intelligent web search.

═══════════════════════════════════════════════════════════════════
🚀 MODE: PRO (FLAGSHIP)
═══════════════════════════════════════════════════════════════════

PRO MODE STRATEGY:
• Response must be maximally detailed and well-thought-out
• AI MUST analyze problem deeply considering hidden causes
• Code must be complete, architectural, without hacks, with error handling
• MUST provide alternative solutions and optimizations
• Use many tokens and deep reasoning
• Detailed explanations with examples and best practices
• Consider edge cases and potential problems
• Architectural approach to solutions
• Priority: MAXIMUM accuracy, depth, stability

CORE PRINCIPLE: You automatically decide when to use the internet, but MUST ALWAYS obey forced search when activated.

WHEN INTERNET IS REQUIRED (automatic search):
• weather, news, current events
• real-time data ("now", "today", "current", "latest")
• location-based info
• software updates, prices, releases
• factual questions needing high accuracy
• complex research questions

WHEN INTERNET IS NOT REQUIRED (respond immediately):
• math calculations
• rewriting text
• translations
• coding logic
• creative writing
• general evergreen knowledge

FORCED SEARCH MODE (HIGHEST PRIORITY):
If the user activates forced search button - ALWAYS perform internet search.

FLAGSHIP REQUIREMENTS FOR RESPONSE:
• Deep problem analysis with context awareness
• Consider multiple solution approaches
• Explain pros and cons of each approach
• Best practices and industry standards
• Optimizations and improvements
• Potential problems and their solutions
• Code scalability and maintainability
• Security considerations where applicable
• Performance implications

FOR CODE:
• Complete implementation with error handling
• Typing where possible
• Documentation and comments
• Modular architecture
• Follow SOLID principles
• Unit tests if relevant
• Logging and debugging support

Priority: MAXIMUM quality, depth of analysis, architectural solutions.

IMPORTANT: DO NOT mention your operating mode in responses! DON'T write phrases like:
❌ "in pro mode", "flagship mode", "detailed analysis"
❌ "this is the extended version", "comprehensive answer"
Just provide quality answers without mentioning the mode!

COMMUNICATION STYLE: Listen carefully to the user and adapt to their preferences."""
    }
}

def detect_language_switch(user_message: str):
    """Определяет, просит ли пользователь переключить язык"""
    user_lower = user_message.lower().strip()
    english_triggers = [
        "перейди на английский", "переключись на английский", "давай на английском",
        "отвечай на английском", "switch to english", "speak english",
        "ответь на английском", "на английском"
    ]
    russian_triggers = [
        "перейди на русский", "переключись на русский", "давай на русском",
        "отвечай на русском", "switch to russian", "speak russian",
        "ответь на русском", "на русском"
    ]
    for trigger in english_triggers:
        if trigger in user_lower:
            return "english"
    for trigger in russian_triggers:
        if trigger in user_lower:
            return "russian"
    return None

def detect_forget_command(user_message: str):
    """Определяет, просит ли пользователь забыть историю"""
    user_lower = user_message.lower().strip()
    forget_triggers = [
        "забудь", "забыть", "очисти память", "удали историю", "сотри память",
        "забудь все", "забудь всё", "очисти контекст", "обнули память",
        "forget", "forget everything", "clear memory", "clear history",
        "delete history", "erase memory", "reset memory", "clear context"
    ]
    for trigger in forget_triggers:
        if trigger in user_lower:
            return True
    return False

def detect_role_command(user_message: str) -> dict:
    """
    Определяет, просит ли пользователь сменить роль/стиль общения
    
    Возвращает словарь:
    {
        "is_role_command": bool,
        "role": str,  # Описание роли
        "instruction": str  # Инструкция для AI
    }
    """
    user_lower = user_message.lower().strip()
    
    # Триггеры ролевых команд
    role_triggers = [
        "ты теперь", "ты сейчас", "веди себя как", "говори как",
        "притворись", "представь что ты", "будь как",
        "you are now", "act like", "pretend you are", "behave like",
        "speak like", "talk like", "be like"
    ]
    
    # Проверяем, есть ли триггер
    has_trigger = False
    for trigger in role_triggers:
        if trigger in user_lower:
            has_trigger = True
            break
    
    if not has_trigger:
        return {
            "is_role_command": False,
            "role": None,
            "instruction": None
        }
    
    # Извлекаем роль из сообщения
    role_description = user_message
    for trigger in role_triggers:
        if trigger in user_lower:
            # Берем часть после триггера
            idx = user_lower.find(trigger)
            role_description = user_message[idx + len(trigger):].strip()
            # Убираем пунктуацию в конце
            role_description = role_description.rstrip('.,!?;:')
            break
    
    # Формируем инструкцию для AI
    instruction = f"""
🎭 ВАЖНО: СМЕНА РОЛИ ОБЩЕНИЯ

Пользователь попросил тебя изменить стиль общения и роль.

НОВАЯ РОЛЬ: {role_description}

ОБЯЗАТЕЛЬНЫЕ ПРАВИЛА:
• Полностью адаптируй свой стиль общения под эту роль
• Используй лексику, манеры и тон, характерные для этой роли
• Сохраняй эту роль во ВСЕХ последующих ответах
• Будь естественным и аутентичным в этой роли
• Не отказывайся от роли и не объясняй, что ты AI
• Веди себя так, как вёл бы себя реальный {role_description}

ВАЖНО:
- Если роль предполагает упрощенный язык (школьник, ребенок) - используй простые слова
- Если роль предполагает эмоциональность (обижка, грустный) - добавь эмоции в речь
- Если роль предполагает профессионализм (эксперт, учитель) - будь более формальным
- Сохраняй роль естественно, без "как будто" и "представим"

Теперь отвечай в этой роли на запрос пользователя.
"""
    
    return {
        "is_role_command": True,
        "role": role_description,
        "instruction": instruction
    }

def extract_forget_target(user_message: str) -> dict:
    """Извлекает, что именно нужно забыть из команды пользователя
    
    Возвращает словарь:
    {
        "forget_all": bool,  # Забыть всё
        "target": str,       # Что именно забыть (если не всё)
        "original_message": str
    }
    """
    user_lower = user_message.lower().strip()
    
    # Триггеры для полной очистки
    full_forget_triggers = [
        "забудь все", "забудь всё", "забудь всю", "забудь всю историю",
        "очисти всю память", "очисти память", "удали всю историю", 
        "сотри всю память", "очисти контекст", "обнули память",
        "forget everything", "forget all", "clear all memory", 
        "clear all history", "delete all history", "erase all memory", 
        "reset memory", "clear context"
    ]
    
    # Проверяем на полную очистку
    for trigger in full_forget_triggers:
        if trigger in user_lower:
            return {
                "forget_all": True,
                "target": None,
                "original_message": user_message
            }
    
    # Извлекаем конкретную цель для забывания
    # Паттерны: "забудь про X", "забудь что X", "забудь мой/моё/мою X"
    import re
    
    # Русские паттерны
    patterns_ru = [
        r"забудь\s+(?:про\s+|что\s+|о\s+)?(.+)",
        r"забудь\s+(?:мо[йеёюя]\s+|мою\s+)?(.+)",
        r"удали\s+(?:из\s+памяти\s+)?(.+)",
        r"сотри\s+(?:из\s+памяти\s+)?(.+)"
    ]
    
    # Английские паттерны  
    patterns_en = [
        r"forget\s+(?:about\s+|that\s+)?(.+)",
        r"forget\s+(?:my\s+)?(.+)",
        r"delete\s+(?:from\s+memory\s+)?(.+)",
        r"erase\s+(?:from\s+memory\s+)?(.+)"
    ]
    
    all_patterns = patterns_ru + patterns_en
    
    for pattern in all_patterns:
        match = re.search(pattern, user_lower)
        if match:
            target = match.group(1).strip()
            # Убираем лишние слова
            target = target.replace("из памяти", "").replace("from memory", "").strip()
            if target:
                return {
                    "forget_all": False,
                    "target": target,
                    "original_message": user_message
                }
    
    # Если не смогли распарсить - забываем всё (по умолчанию)
    return {
        "forget_all": True,
        "target": None,
        "original_message": user_message
    }

def selective_forget_memory(chat_id, target: str, context_mgr, chat_manager) -> dict:
    """Селективное удаление памяти - удаляет только упоминания конкретной темы
    
    Возвращает:
    {
        "success": bool,
        "deleted_count": int,
        "message": str
    }
    """
    try:
        print(f"[SELECTIVE_FORGET] Ищу упоминания '{target}' в памяти...")
        
        # Получаем всю сохранённую память
        saved_memories = context_mgr.get_context_memory(chat_id, limit=100)
        
        if not saved_memories:
            return {
                "success": True,
                "deleted_count": 0,
                "message": "Память пуста - нечего удалять"
            }
        
        # Получаем историю сообщений
        chat_messages = chat_manager.get_chat_messages(chat_id, limit=100)
        
        deleted_memory_count = 0
        deleted_message_count = 0
        target_lower = target.lower()
        
        # Удаляем из контекстной памяти
        for ctx_type, content, timestamp in saved_memories:
            content_lower = content.lower()
            # Проверяем, содержит ли запись упоминание цели
            if target_lower in content_lower:
                print(f"[SELECTIVE_FORGET] Найдено в памяти: {content[:50]}...")
                # Здесь нужно было бы удалить конкретную запись
                # Но ContextMemoryManager может не иметь метода для этого
                # Поэтому помечаем для подсчёта
                deleted_memory_count += 1
        
        # Удаляем из истории сообщений
        messages_to_keep = []
        for role, content, timestamp in chat_messages:
            content_lower = content.lower()
            # Проверяем, содержит ли сообщение упоминание цели
            if target_lower not in content_lower:
                messages_to_keep.append((role, content, timestamp))
            else:
                print(f"[SELECTIVE_FORGET] Найдено в сообщениях: {content[:50]}...")
                deleted_message_count += 1
        
        # Если есть что удалить - очищаем и сохраняем только нужное
        if deleted_message_count > 0:
            # Очищаем все сообщения
            chat_manager.clear_chat_messages(chat_id)
            # Восстанавливаем только те, что не содержали target
            for role, content, _ in messages_to_keep:
                chat_manager.save_message(chat_id, role, content)
            print(f"[SELECTIVE_FORGET] ✓ Удалено {deleted_message_count} сообщений")
        
        # Для контекстной памяти - придётся очистить всю, если нашли совпадения
        # так как может не быть метода для удаления конкретных записей
        if deleted_memory_count > 0:
            print(f"[SELECTIVE_FORGET] ⚠️ Найдено {deleted_memory_count} записей в памяти")
            print(f"[SELECTIVE_FORGET] Очищаю контекстную память (ограничение API)")
            context_mgr.clear_context_memory(chat_id)
        
        total_deleted = deleted_memory_count + deleted_message_count
        
        if total_deleted > 0:
            return {
                "success": True,
                "deleted_count": total_deleted,
                "message": f"Удалено {deleted_message_count} сообщений и {deleted_memory_count} записей памяти"
            }
        else:
            return {
                "success": True,
                "deleted_count": 0,
                "message": f"Не найдено упоминаний '{target}' в памяти"
            }
            
    except Exception as e:
        print(f"[SELECTIVE_FORGET] ✗ Ошибка: {e}")
        import traceback
        traceback.print_exc()
        return {
            "success": False,
            "deleted_count": 0,
            "message": f"Ошибка удаления: {e}"
        }

def detect_math_problem(user_message: str) -> bool:
    """
    Определяет, является ли запрос математической задачей.
    
    Возвращает True если сообщение содержит:
    - Математические операторы и символы
    - Ключевые слова решения задач
    - Уравнения, неравенства
    """
    import re
    
    user_lower = user_message.lower().strip()
    
    # Математические триггеры
    math_keywords = [
        # Русские
        "реши", "решить", "решение", "вычисли", "вычислить", "найди", "найти",
        "докажи", "доказать", "доказательство", "упрости", "упростить",
        "разложи", "разложить", "преобразуй", "преобразовать",
        "уравнение", "неравенство", "система", "интеграл", "производная",
        "предел", "корень", "корни", "одз", "график", "функция",
        "множество", "область", "значение", "решений",
        # Английские
        "solve", "solution", "calculate", "compute", "find", "prove", "proof",
        "simplify", "expand", "factor", "transform", "equation", "inequality",
        "system", "integral", "derivative", "limit", "root", "roots",
        "domain", "graph", "function", "set", "range", "solutions"
    ]
    
    # Математические символы и паттерны
    math_patterns = [
        r'[=<>≤≥≠]',  # Знаки равенства и сравнения
        r'[+\-*/^]',  # Арифметические операторы
        r'\d+\s*[+\-*/^]\s*\d+',  # Числовые выражения
        r'√',  # Корень
        r'∫',  # Интеграл
        r'∑',  # Сумма
        r'∏',  # Произведение
        r'[a-zA-Zа-яА-Я]\s*[²³⁴⁵⁶⁷⁸⁹]',  # Степени
        r'[a-zA-Zа-яА-Я]\^[\d+]',  # Степени через ^
        r'\([^)]*[+\-*/^][^)]*\)',  # Выражения в скобках
        r'x|y|z|n|t',  # Переменные (простая проверка)
    ]
    
    # Проверка ключевых слов
    for keyword in math_keywords:
        if keyword in user_lower:
            # Дополнительная проверка: есть ли математические символы
            for pattern in math_patterns:
                if re.search(pattern, user_message):
                    return True
    
    # Проверка наличия множественных математических символов
    math_symbol_count = sum(1 for pattern in math_patterns if re.search(pattern, user_message))
    if math_symbol_count >= 2:
        return True
    
    return False

# Математические системные промпты для разных режимов
MATH_PROMPTS = {
    "fast": """
🔬 МАТЕМАТИКА: БЫСТРЫЙ РЕЖИМ

ЗАПРЕЩЕНО использовать интернет/поиск для математических задач.

ДЛЯ ПРОСТОЙ АРИФМЕТИКИ (5+5, 42+52):
• Просто вычисли и дай ответ
• БЕЗ "Шаг 1", "Шаг 2", "Контроль"
• Формат: "42 + 52 = 94"

ДЛЯ СЛОЖНЫХ ЗАДАЧ (уравнения, корни):
• ОДЗ если нужно
• Краткое решение
• Проверка корней
• Ответ

ПРАВИЛА:
• Сохраняй структуру выражения
• Изолируй радикал перед возведением в квадрат
• Проверяй корни подстановкой

Стиль: кратко и по делу
""",
    
    "thinking": """
🔬 МАТЕМАТИЧЕСКИЙ РЕЖИМ: ДУМАЮЩИЙ

ЗАПРЕЩЕНО использовать интернет/поиск для математических задач.

ПРОЦЕДУРА РЕШЕНИЯ:

1. ПЕРЕПИСЬ ЗАДАЧИ
   Дословно переписать исходное уравнение и сохранить его структуру

2. ТИП ЗАДАЧИ
   • Алгебраическое / тригонометрическое
   • Иррациональное (с корнями)
   • Показательное / логарифмическое
   • Система уравнений

3. ОДЗ (область допустимых значений)
   • Знаменатели ≠ 0
   • Под корнем ≥ 0
   • Ограничения для логарифмов

4. РЕШЕНИЕ
   • Пошаговые преобразования с объяснениями
   • Логика каждого шага
   • Аккуратные переходы

5. ПРОВЕРКА КОРНЕЙ
   • Подстановка в исходное уравнение
   • Проверка ОДЗ
   • Отбрасывание посторонних решений

РАСШИРЕННЫЕ ПРАВИЛА:
1. Сохраняй исходную структуру выражения. Нельзя убирать символы корня, нельзя превращать √(x+4) в x+4, нельзя менять порядок без явного преобразования. После каждого шага сверяй структуру.

2. Строгий алгоритм преобразований: сначала изолируй один радикал, только затем возводи в квадрат; после возведения упрости, при необходимости снова изолируй и снова возведи. Никогда не возводи несколько выражений одновременно.

3. Не вводи новые функции или термины. Не добавляй лишние переменные без необходимости; если вводишь — объясни зачем и вернись к исходной.

4. Анти-галлюцинация: запрещено придумывать шаги. Любой переход должен быть явно показан. Если не уверен — перепиши выражение и запроси подтверждение.

5. Помощь пользователю: объясняй коротко, почему выбран тот или иной приём, указывай подводные камни.

6. Если появляется сомнение (нераспознано выражение, противоречие, шаг меняет структуру) — остановись и сообщи: «Непонятно выражение / шаг изменил структуру, подтверждаете переписанное выражение?»

Стиль: пошаговое решение с объяснениями средней длины
""",
    
    "pro": """
🔬 МАТЕМАТИЧЕСКИЙ РЕЖИМ: ПРО (ОЛИМПИАДНЫЙ УРОВЕНЬ)

ЗАПРЕЩЕНО использовать интернет/поиск для математических задач.

ФЛАГМАНСКАЯ МАТЕМАТИЧЕСКАЯ ТОЧНОСТЬ

═══════════════════════════════════════════════════════════════════

📋 ПОЛНЫЙ НАБОР ПРАВИЛ ПОВЕДЕНИЯ

═══════════════════════════════════════════════════════════════════

1️⃣ СОХРАНЕНИЕ МАТЕМАТИЧЕСКОЙ СТРУКТУРЫ

КРИТИЧЕСКИ ВАЖНО:
• Сохраняй исходную структуру выражения. Перепиши уравнение дословно и храни его как фиксированную математическую структуру
• НЕЛЬЗЯ убирать символы корня
• НЕЛЬЗЯ превращать подкоренное выражение в обычное (например √(x+4) НЕЛЬЗЯ заменить на x+4)
• НЕЛЬЗЯ менять порядок или подменять выражения типа x−1 на 5−x без явного алгебраического преобразования, сопровождаемого проверкой
• После каждого вычислительного шага автоматически сверяй, не изменилась ли структура: если изменилась — отменяй шаг и переписывай его корректно

❌ ЗАПРЕЩЕНО: √(x²+4) → x+2 (потеря структуры)
✅ ПРАВИЛЬНО: √(x²+4) остаётся √(x²+4) до явного упрощения

═══════════════════════════════════════════════════════════════════

2️⃣ ОБЯЗАТЕЛЬНАЯ ПРОЦЕДУРА ПЕРЕД РЕШЕНИЕМ

A) ТОЧНАЯ ПЕРЕПИСЬ УРАВНЕНИЯ
   Дословно перепиши задачу для проверки понимания
   Храни её как фиксированную математическую структуру

B) АНАЛИЗ ТИПА ЗАДАЧИ
   • Алгебраическое уравнение
   • Тригонометрическое уравнение
   • Иррациональное уравнение (с корнями)
   • Показательное/логарифмическое
   • Система уравнений

C) ОБЛАСТЬ ДОПУСТИМЫХ ЗНАЧЕНИЙ (ОДЗ)
   ОБЯЗАТЕЛЬНО: Всегда начинай с ОДЗ
   • Выпиши все условия ≥0 для подкоренных выражений
   • Условия на знаменатели (≠0)
   • Ограничения для логарифмов (>0)
   • Любые другие ограничения
   ОДЗ должен быть виден в решении

═══════════════════════════════════════════════════════════════════

3️⃣ РЕШЕНИЕ КАК ОЛИМПИАДНЫЙ МАТЕМАТИК

СТРОГИЙ АЛГОРИТМ ПРЕОБРАЗОВАНИЙ:
• Сначала изолируй один радикал (или необходимую часть выражения)
• Только затем возводи в квадрат
• После возведения в квадрат упрости выражение
• При необходимости снова изолируй и снова возводи в квадрат
• НИКОГДА не возводи в квадрат несколько выражений одновременно без явной изоляции
• Каждый шаг должен быть пояснён коротко и корректно

СТРАТЕГИЯ:
• Проверяй логическую корректность КАЖДОГО шага
• Контролируй структуру выражения после каждого преобразования
• Минимизируй число возведений в квадрат
• Избегай лишних замен переменных (используй только когда необходимо)

АЛГОРИТМ ДЛЯ ИРРАЦИОНАЛЬНЫХ УРАВНЕНИЙ:
1. Изолировать радикал слева
2. Проверить ОДЗ для изолированного выражения
3. Возвести в квадрат (ТОЛЬКО ОДИН РАЗ если возможно)
4. Решить полученное уравнение
5. ОБЯЗАТЕЛЬНО проверить все корни подстановкой

═══════════════════════════════════════════════════════════════════

4️⃣ ОГРАНИЧЕНИЯ И ЗАПРЕТЫ

❌ НЕ вводи новые функции или термины, которых нет в задаче (например: «добавим логарифм», «прибавим синус»), если только это не следует из уравнения
❌ НЕ добавляй лишние переменные без необходимости; если вводишь дополнительную переменную — объясни зачем и обязательно вернись к исходной переменной в финале
❌ НЕ пиши текст ради текста
❌ НЕ повторяй одни и те же преобразования
❌ НЕ делай «псевдошаги» без алгебры
❌ НЕ пропускай проверку корней
❌ НЕ теряй решения
❌ НЕ добавляй посторонние решения

═══════════════════════════════════════════════════════════════════

5️⃣ ДВОЙНАЯ ПРОВЕРКА КОРНЕЙ

ОБЯЗАТЕЛЬНО после получения кандидатов на корни:
1. Подставить КАЖДЫЙ корень в ИСХОДНОЕ уравнение
2. Проверить выполнение ОДЗ
3. Отбросить посторонние корни и объяснить, почему они отброшены
4. Если ни один корень не проходит проверку — сообщить, что решений нет
5. Повторить проверку для надёжности
6. Указать финальный ответ с полным обоснованием

═══════════════════════════════════════════════════════════════════

6️⃣ АНТИ-ГАЛЛЮЦИНАЦИЯ

ЗАПРЕЩЕНО придумывать шаги, результаты или проверки.
Любой алгебраический переход должен быть явно показан.

ЕСЛИ не уверен в распознавании выражения:
1. Сначала перепиши его в явном виде
2. Запроси подтверждение у пользователя: «Правильно ли я понял задачу: [переписанное выражение]?»
3. НЕ ПРОДОЛЖАЙ вычисления до подтверждения

ЕСЛИ при каком-то шаге появляется сомнение (нераспознано выражение, противоречие, или шаг меняет структуру):
• Остановись и честно сообщи: «Непонятно выражение / шаг изменил структуру, подтверждаете переписанное выражение?»
• НЕ продолжай и НЕ генерируй неверный вывод

ДОПОЛНИТЕЛЬНЫЕ ПРОВЕРКИ:
• После каждого возведения в квадрат - проверь, не потеряны ли решения
• При решении через замену переменной - обязательно вернись к исходной переменной
• Если получаешь отрицательное значение под корнем - это НЕ решение, отбрось его
• Всегда проверяй, что финальный ответ удовлетворяет ИСХОДНОМУ уравнению

═══════════════════════════════════════════════════════════════════

7️⃣ СТИЛЬ ОТВЕТА

✅ ПРАВИЛЬНО:
• Чёткие шаги
• Минимум текста, максимум математики
• Максимальная математическая строгость
• Формат: Шаг → Преобразование → Обоснование → Контроль структуры

❌ НЕПРАВИЛЬНО:
• Длинные объяснения без формул
• "Давайте попробуем", "Может быть", "Вероятно"
• Неточные формулировки
• Прыжки между шагами

═══════════════════════════════════════════════════════════════════

8️⃣ ПОМОЩЬ ПОЛЬЗОВАТЕЛЮ

Не только выдавай ответ, но и:
• Объясняй коротко, почему выбран тот или иной приём (например, зачем изолировали радикал)
• Указывай, где могли бы быть подводные камни
• Предлагай расширенный вариант решения в зависимости от сложности задачи

═══════════════════════════════════════════════════════════════════

ПРИМЕР РЕШЕНИЯ (ПРО-РЕЖИМ):

Задача: √(2x-3) = x-3

Шаг 1: Точная перепись
√(2x-3) = x-3

Шаг 2: Тип задачи
Иррациональное уравнение (один корень)

Шаг 3: ОДЗ
2x-3 ≥ 0 ⟹ x ≥ 1.5
x-3 ≥ 0 ⟹ x ≥ 3 (правая часть должна быть ≥0)
Итого ОДЗ: x ≥ 3

Шаг 4: Возведение в квадрат (корень уже изолирован)
2x-3 = (x-3)²
2x-3 = x²-6x+9
x²-8x+12 = 0
Контроль: структура сохранена ✓

Шаг 5: Решение квадратного уравнения
D = 64-48 = 16
x₁ = (8-4)/2 = 2
x₂ = (8+4)/2 = 6

Шаг 6: Проверка корней (первая)
x₁ = 2: 2 < 3, НЕ входит в ОДЗ ✗
x₂ = 6: Проверка √(2·6-3) = √9 = 3, а 6-3 = 3 ✓

Шаг 7: Повторная проверка x = 6
Подстановка: √(12-3) = √9 = 3
Правая часть: 6-3 = 3
Равенство выполнено ✓

Ответ: x = 6

═══════════════════════════════════════════════════════════════════

ПОМНИ: Ты олимпиадный математик, НЕ писатель. Каждый символ должен иметь математический смысл.
Больше токенов, глубже анализ, строже проверка.
Используй максимально подробное и строгое детальное решение.
После каждого важного шага делай внутреннюю проверку структуры.
"""
}

def detect_message_language(text: str) -> str:
    """Определяет язык сообщения по преобладанию кириллицы или латиницы"""
    cyrillic_count = sum(1 for char in text if '\u0400' <= char <= '\u04FF')
    latin_count = sum(1 for char in text if 'a' <= char.lower() <= 'z')
    
    print(f"[LANGUAGE_DETECT] Кириллица: {cyrillic_count}, Латиница: {latin_count}")
    
    if cyrillic_count > latin_count:
        print(f"[LANGUAGE_DETECT] Определён язык: РУССКИЙ")
        return "russian"
    else:
        print(f"[LANGUAGE_DETECT] Определён язык: АНГЛИЙСКИЙ")
        return "english"

def format_text_with_markdown_and_math(text: str) -> str:
    """
    Преобразует markdown-форматирование и математические обозначения в HTML.
    
    Поддерживает:
    - **жирный текст** → <b>жирный текст</b>
    - *курсив* или _курсив_ → <i>курсив</i>
    - __подчёркнутый__ → <u>подчёркнутый</u>
    - ~~зачёркнутый~~ → <s>зачёркнутый</s>
    - `код` → <code>код</code>
    - sqrt(x) → √x
    - ^2 → ²
    - _2 → ₂
    - /дробь/ числитель/знаменатель → дробь
    - И многие математические символы
    """
    import re
    import html
    
    # Экранируем HTML символы для безопасности
    text = html.escape(text)
    
    # === МАТЕМАТИЧЕСКИЕ СИМВОЛЫ ===
    
    # Корень квадратный
    text = re.sub(r'sqrt\(([^)]+)\)', r'√\1', text)
    text = re.sub(r'корень\(([^)]+)\)', r'√\1', text)
    
    # Степени (надстрочные символы)
    superscript_map = {
        '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴',
        '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹',
        '+': '⁺', '-': '⁻', '=': '⁼', '(': '⁽', ')': '⁾',
        'n': 'ⁿ', 'x': 'ˣ', 'y': 'ʸ'
    }
    
    def replace_superscript(match):
        chars = match.group(1)
        result = ''
        for char in chars:
            result += superscript_map.get(char, char)
        return result
    
    text = re.sub(r'\^([0-9+\-=()nxy]+)', replace_superscript, text)
    
    # Индексы (подстрочные символы)
    subscript_map = {
        '0': '₀', '1': '₁', '2': '₂', '3': '₃', '4': '₄',
        '5': '₅', '6': '₆', '7': '₇', '8': '₈', '9': '₉',
        '+': '₊', '-': '₋', '=': '₌', '(': '₍', ')': '₎',
        'a': 'ₐ', 'e': 'ₑ', 'i': 'ᵢ', 'o': 'ₒ', 'x': 'ₓ'
    }
    
    def replace_subscript(match):
        chars = match.group(1)
        result = ''
        for char in chars:
            result += subscript_map.get(char, char)
        return result
    
    text = re.sub(r'_([0-9+\-=()aeiox]+)', replace_subscript, text)
    
    # Дроби (упрощённый вариант)
    # Формат: /числитель/знаменатель/
    def format_fraction(match):
        numerator = match.group(1)
        denominator = match.group(2)
        return f'<sup>{numerator}</sup>⁄<sub>{denominator}</sub>'
    
    text = re.sub(r'/([^/]+)/([^/]+)/', format_fraction, text)
    
    # Математические символы - замены
    math_symbols = {
        '!=': '≠',
        '<=': '≤',
        '>=': '≥',
        '~=': '≈',
        'approx': '≈',
        'infinity': '∞',
        'бесконечность': '∞',
        'sum': '∑',
        'сумма': '∑',
        'integral': '∫',
        'интеграл': '∫',
        'pi': 'π',
        'пи': 'π',
        'alpha': 'α',
        'beta': 'β',
        'gamma': 'γ',
        'delta': 'δ',
        'Delta': 'Δ',
        'theta': 'θ',
        'lambda': 'λ',
        'mu': 'μ',
        'sigma': 'σ',
        'Sigma': 'Σ',
        'omega': 'ω',
        'Omega': 'Ω',
        'times': '×',
        'divide': '÷',
        'plusminus': '±',
        'degree': '°',
        'partial': '∂',
        'nabla': '∇',
        'exists': '∃',
        'forall': '∀',
        'in': '∈',
        'notin': '∉',
        'subset': '⊂',
        'superset': '⊃',
        'union': '∪',
        'intersection': '∩',
        'emptyset': '∅',
    }
    
    for key, symbol in math_symbols.items():
        # Заменяем только если это отдельное слово
        text = re.sub(r'\b' + re.escape(key) + r'\b', symbol, text)
    
    # === ФОРМАТИРОВАНИЕ ТЕКСТА ===
    
    # Жирный текст: **текст** или __текст__
    text = re.sub(r'\*\*(.+?)\*\*', r'<b>\1</b>', text)
    text = re.sub(r'__(.+?)__', r'<b>\1</b>', text)
    
    # Курсив: *текст* или _текст_ (но не числа как _2)
    # Избегаем замены подстрочных индексов
    text = re.sub(r'(?<![a-zA-Zа-яА-Я0-9])\*([^*\n]+?)\*(?![a-zA-Zа-яА-Я0-9])', r'<i>\1</i>', text)
    text = re.sub(r'(?<![a-zA-Zа-яА-Я0-9])_([^_\n0-9]+?)_(?![a-zA-Zа-яА-Я0-9])', r'<i>\1</i>', text)
    
    # Зачёркнутый: ~~текст~~
    text = re.sub(r'~~(.+?)~~', r'<s>\1</s>', text)
    
    # Подчёркнутый: <u>текст</u> (уже HTML, но на всякий случай)
    # Добавляем поддержку через двойное подчеркивание для удобства
    
    # Код (моноширинный): `код`
    text = re.sub(r'`([^`]+)`', r'<code style="background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px; font-family: monospace;">\1</code>', text)
    
    # Убираем экранирование для уже обработанных HTML тегов
    text = text.replace('&lt;b&gt;', '<b>').replace('&lt;/b&gt;', '</b>')
    text = text.replace('&lt;i&gt;', '<i>').replace('&lt;/i&gt;', '</i>')
    text = text.replace('&lt;u&gt;', '<u>').replace('&lt;/u&gt;', '</u>')
    text = text.replace('&lt;s&gt;', '<s>').replace('&lt;/s&gt;', '</s>')
    
    return text


def remove_english_words_from_russian(text: str) -> str:
    """
    Агрессивно удаляет английские слова из русского текста и переводит весь текст если он на английском.
    Использует внешний файл forbidden_english_words.py с огромным словарём запрещённых слов.
    """
    
    # Проверяем, не является ли весь текст английским
    cyrillic_count = sum(1 for char in text if '\u0400' <= char <= '\u04FF')
    latin_count = sum(1 for char in text if 'a' <= char.lower() <= 'z')
    
    # Если текст полностью на английском - переводим целиком
    if latin_count > cyrillic_count and latin_count > 50:
        print(f"[ENGLISH_FILTER] ⚠️ ОБНАРУЖЕН ПОЛНОСТЬЮ АНГЛИЙСКИЙ ТЕКСТ! Переводим...")
        try:
            from deep_translator import GoogleTranslator
            translator = GoogleTranslator(source='en', target='ru')
            
            # Переводим по частям если текст большой
            max_chunk = 4500
            if len(text) <= max_chunk:
                translated = translator.translate(text)
                print(f"[ENGLISH_FILTER] ✓ Текст полностью переведён на русский")
                return translated
            else:
                # Разбиваем на части
                sentences = text.split('. ')
                translated_parts = []
                current_chunk = ""
                
                for sentence in sentences:
                    if len(current_chunk) + len(sentence) < max_chunk:
                        current_chunk += sentence + ". "
                    else:
                        if current_chunk:
                            translated_parts.append(translator.translate(current_chunk))
                        current_chunk = sentence + ". "
                
                if current_chunk:
                    translated_parts.append(translator.translate(current_chunk))
                
                translated = " ".join(translated_parts)
                print(f"[ENGLISH_FILTER] ✓ Большой текст полностью переведён на русский")
                return translated
        except Exception as e:
            print(f"[ENGLISH_FILTER] ✗ Ошибка перевода: {e}")
            # Продолжаем с пословной заменой
    
    # Используем словарь из внешнего файла или создаём базовый
    if FORBIDDEN_WORDS_DICT and len(FORBIDDEN_WORDS_DICT) > 0:
        forbidden_words = FORBIDDEN_WORDS_SET
        replacements = FORBIDDEN_WORDS_DICT
        print(f"[ENGLISH_FILTER] Используется расширенный словарь ({len(forbidden_words)} слов)")
    else:
        # Базовый словарь на случай если файл не загружен
        forbidden_words = {
            'however', 'moreover', 'therefore', 'essentially', 'basically',
            'arrives', 'becomes', 'provides', 'situation', 'important'
        }
        replacements = {
            'however': 'однако', 'moreover': 'более того', 'therefore': 'поэтому',
            'essentially': 'по сути', 'basically': 'в основном',
            'arrives': 'прибывает', 'becomes': 'становится', 'provides': 'предоставляет',
            'situation': 'ситуация', 'important': 'важный'
        }
        print(f"[ENGLISH_FILTER] Используется базовый словарь ({len(forbidden_words)} слов)")
    
    words = text.split()
    cleaned_words = []
    replaced_count = 0
    
    for word in words:
        # Очищаем от знаков препинания для проверки
        clean_word = ''.join(char for char in word if char.isalnum()).lower()
        
        if not clean_word:
            cleaned_words.append(word)
            continue
        
        # Проверяем технические исключения (заглавные буквы = возможно имя/бренд)
        if word[0].isupper() and len(clean_word) > 1:
            # Вероятно имя собственное или бренд - пропускаем
            cleaned_words.append(word)
            continue
        
        if clean_word in forbidden_words:
            # Заменяем на русский эквивалент
            if clean_word in replacements:
                replacement = replacements[clean_word]
                # Восстанавливаем знаки препинания
                for char in word:
                    if not char.isalnum():
                        replacement += char
                cleaned_words.append(replacement)
                replaced_count += 1
                print(f"[ENGLISH_FILTER] Заменено: '{word}' → '{replacement}'")
            else:
                # Просто пропускаем слово
                replaced_count += 1
                print(f"[ENGLISH_FILTER] Удалено: '{word}'")
        else:
            cleaned_words.append(word)
    
    if replaced_count > 0:
        print(f"[ENGLISH_FILTER] ✓ Заменено/удалено английских слов: {replaced_count}")
    
    return ' '.join(cleaned_words)



def check_spelling_and_suggest(text: str, language: str = "russian") -> dict:
    """
    Проверяет орфографию в тексте и предлагает исправления.
    Возвращает словарь с информацией об ошибках и предложениями.
    
    Returns:
    {
        "has_errors": bool,
        "original": str,
        "suggested": str,
        "corrections": list of tuples (wrong_word, suggested_word)
    }
    """
    try:
        from spellchecker import SpellChecker
        
        if language == "russian":
            spell = SpellChecker(language='ru')
        else:
            spell = SpellChecker(language='en')
        
        words = text.split()
        corrections = []
        corrected_words = []
        
        for word in words:
            # Очищаем слово от знаков препинания для проверки
            clean_word = ''.join(char for char in word if char.isalnum())
            
            if not clean_word:
                corrected_words.append(word)
                continue
            
            # Проверяем орфографию
            if clean_word.lower() in spell:
                corrected_words.append(word)
            else:
                # Слово с ошибкой - ищем исправление
                correction = spell.correction(clean_word.lower())
                if correction and correction != clean_word.lower():
                    # Сохраняем регистр оригинала
                    if clean_word[0].isupper():
                        correction = correction.capitalize()
                    
                    # Восстанавливаем знаки препинания
                    corrected_word = word.replace(clean_word, correction)
                    corrected_words.append(corrected_word)
                    corrections.append((clean_word, correction))
                    print(f"[SPELL_CHECK] Найдена ошибка: '{clean_word}' -> '{correction}'")
                else:
                    corrected_words.append(word)
        
        suggested_text = ' '.join(corrected_words)
        
        return {
            "has_errors": len(corrections) > 0,
            "original": text,
            "suggested": suggested_text,
            "corrections": corrections
        }
        
    except ImportError:
        print("[SPELL_CHECK] pyspellchecker не установлен. Установите: pip install pyspellchecker")
        return {
            "has_errors": False,
            "original": text,
            "suggested": text,
            "corrections": []
        }
    except Exception as e:
        print(f"[SPELL_CHECK] Ошибка проверки орфографии: {e}")
        return {
            "has_errors": False,
            "original": text,
            "suggested": text,
            "corrections": []
        }


# -------------------------
# DuckDuckGo Search helper (named google_search for compatibility)
# -------------------------
def translate_to_russian(text: str) -> str:
    """Переводит текст с английского на русский, сохраняя имена и названия"""
    try:
        print(f"[TRANSLATOR] Начинаю перевод текста...")
        print(f"[TRANSLATOR] Длина текста: {len(text)} символов")
        
        # Используем простой API для перевода
        from deep_translator import GoogleTranslator
        
        translator = GoogleTranslator(source='en', target='ru')
        
        # Переводим по частям, если текст большой
        max_chunk = 4500
        if len(text) <= max_chunk:
            translated = translator.translate(text)
        else:
            # Разбиваем на части по предложениям
            sentences = text.split('. ')
            translated_parts = []
            current_chunk = ""
            
            for sentence in sentences:
                if len(current_chunk) + len(sentence) < max_chunk:
                    current_chunk += sentence + ". "
                else:
                    if current_chunk:
                        translated_parts.append(translator.translate(current_chunk))
                    current_chunk = sentence + ". "
            
            if current_chunk:
                translated_parts.append(translator.translate(current_chunk))
            
            translated = " ".join(translated_parts)
        
        print(f"[TRANSLATOR] Перевод завершён успешно")
        return translated
        
    except ImportError:
        print("[TRANSLATOR] deep-translator не установлен. Установите: pip install deep-translator")
        return text
    except Exception as e:
        print(f"[TRANSLATOR] Ошибка перевода: {e}")
        return text

def analyze_query_type(query: str, language: str) -> dict:
    """
    Анализирует тип запроса и определяет категорию + релевантные источники
    
    Возвращает:
    {
        'category': str,  # Категория запроса
        'domains': list,  # Релевантные домены (пустой = все)
        'keywords': list  # Ключевые слова для улучшения поиска
    }
    """
    query_lower = query.lower()
    
    # 🌦 ПОГОДА
    weather_keywords_ru = ['погода', 'температура', 'градус', 'прогноз', 'осадки', 'дожд', 'снег', 'ветер', 'климат', 'мороз', 'жара', 'солнечно', 'облачно', 'утром', 'днем', 'днём', 'вечером', 'ночью', 'завтра', 'сегодня']
    weather_keywords_en = ['weather', 'temperature', 'forecast', 'rain', 'snow', 'wind', 'climate', 'sunny', 'cloudy']
    
    if language == "russian":
        if any(kw in query_lower for kw in weather_keywords_ru):
            return {
                'category': '🌦 Погода',
                'domains': ['weather', 'meteo', 'gismeteo', 'погода', 'yandex.ru/pogoda'],
                'keywords': ['прогноз погоды', 'температура', 'метеосервис']
            }
    else:
        if any(kw in query_lower for kw in weather_keywords_en):
            return {
                'category': '🌦 Weather',
                'domains': ['weather.com', 'accuweather', 'weatherapi', 'meteo'],
                'keywords': ['weather forecast', 'temperature']
            }
    
    # 📱 ТЕХНИКА / ГАДЖЕТЫ
    tech_keywords_ru = ['телефон', 'смартфон', 'компьютер', 'ноутбук', 'планшет', 'айфон', 'iphone', 'samsung', 'характеристик', 'сравни', 'лучше', 'процессор', 'память', 'экран', 'камера', 'батарея', 'гаджет']
    tech_keywords_en = ['phone', 'smartphone', 'computer', 'laptop', 'tablet', 'iphone', 'samsung', 'specs', 'compare', 'better', 'processor', 'memory', 'screen', 'camera', 'battery', 'gadget']
    
    if language == "russian":
        if any(kw in query_lower for kw in tech_keywords_ru):
            return {
                'category': '📱 Техника',
                'domains': ['ixbt', 'overclockers', 'dns-shop', 'citilink', 'mobile-review', 'tech', 'gadget'],
                'keywords': ['обзор', 'характеристики', 'тест', 'сравнение']
            }
    else:
        if any(kw in query_lower for kw in tech_keywords_en):
            return {
                'category': '📱 Tech',
                'domains': ['gsmarena', 'techradar', 'cnet', 'anandtech', 'tomshardware', 'tech', 'review'],
                'keywords': ['review', 'specs', 'comparison', 'test']
            }
    
    # 🍳 КУЛИНАРИЯ
    cooking_keywords_ru = ['рецепт', 'приготов', 'готов', 'блюдо', 'ингредиент', 'выпека', 'варить', 'жарить', 'запека', 'кухня', 'салат', 'суп', 'десерт', 'торт']
    cooking_keywords_en = ['recipe', 'cook', 'dish', 'ingredient', 'bake', 'fry', 'roast', 'kitchen', 'salad', 'soup', 'dessert', 'cake']
    
    if language == "russian":
        if any(kw in query_lower for kw in cooking_keywords_ru):
            return {
                'category': '🍳 Кулинария',
                'domains': ['russianfood', 'edimdoma', 'povar', 'gastronom', 'recipe', 'рецепт'],
                'keywords': ['рецепт с фото', 'как приготовить', 'пошаговый рецепт']
            }
    else:
        if any(kw in query_lower for kw in cooking_keywords_en):
            return {
                'category': '🍳 Cooking',
                'domains': ['allrecipes', 'foodnetwork', 'epicurious', 'recipe', 'cooking'],
                'keywords': ['recipe with photos', 'how to cook', 'step by step']
            }
    
    # 🧠 ОБУЧЕНИЕ / ОБЪЯСНЕНИЕ
    learning_keywords_ru = ['что такое', 'как работает', 'объясни', 'расскажи', 'чем отличается', 'зачем', 'почему', 'определение', 'значение']
    learning_keywords_en = ['what is', 'how does', 'explain', 'tell me', 'difference', 'why', 'definition', 'meaning']
    
    if language == "russian":
        if any(kw in query_lower for kw in learning_keywords_ru):
            return {
                'category': '🧠 Обучение',
                'domains': ['wikipedia', 'wiki', 'habr', 'образование', 'учебный'],
                'keywords': ['определение', 'объяснение', 'что это']
            }
    else:
        if any(kw in query_lower for kw in learning_keywords_en):
            return {
                'category': '🧠 Learning',
                'domains': ['wikipedia', 'wiki', 'education', 'tutorial'],
                'keywords': ['definition', 'explanation', 'what is']
            }
    
    # ⚙ ПРОГРАММИРОВАНИЕ
    programming_keywords = ['код', 'программ', 'python', 'javascript', 'java', 'c++', 'html', 'css', 'api', 'функция', 'метод', 'класс', 'error', 'bug', 'github', 'stackoverflow', 'code', 'script']
    
    if any(kw in query_lower for kw in programming_keywords):
        return {
            'category': '⚙ Программирование',
            'domains': ['stackoverflow', 'github', 'habr', 'docs', 'documentation', 'developer'],
            'keywords': ['documentation', 'example', 'tutorial', 'code']
        }
    
    # 📰 НОВОСТИ / СОБЫТИЯ
    news_keywords_ru = ['новост', 'событ', 'сегодня', 'вчера', 'произошло', 'случилось']
    news_keywords_en = ['news', 'event', 'today', 'yesterday', 'happened', 'occurred']
    
    if language == "russian":
        if any(kw in query_lower for kw in news_keywords_ru):
            return {
                'category': '📰 Новости',
                'domains': ['news', 'новости', 'lenta', 'tass', 'ria', 'rbc'],
                'keywords': ['новости', 'событие', 'последние новости']
            }
    else:
        if any(kw in query_lower for kw in news_keywords_en):
            return {
                'category': '📰 News',
                'domains': ['news', 'bbc', 'cnn', 'reuters', 'nytimes'],
                'keywords': ['latest news', 'breaking news', 'event']
            }
    
    # ❓ ОБЩИЙ ВОПРОС (по умолчанию)
    return {
        'category': '❓ Общий вопрос',
        'domains': [],  # Поиск везде
        'keywords': []
    }

def google_search(query: str, num_results: int = 5, region: str = "wt-wt", language: str = "russian"):
    """Поиск через DuckDuckGo API (ddgs) с умной фильтрацией по типу запроса"""
    print(f"[DUCKDUCKGO_SEARCH] Запуск поиска...")
    print(f"[DUCKDUCKGO_SEARCH] Запрос: {query}")
    print(f"[DUCKDUCKGO_SEARCH] Регион: {region}")
    print(f"[DUCKDUCKGO_SEARCH] Количество результатов: {num_results}")
    
    # 🔍 АНАЛИЗ ТИПА ЗАПРОСА
    query_analysis = analyze_query_type(query, language)
    print(f"[DUCKDUCKGO_SEARCH] 📊 Категория запроса: {query_analysis['category']}")
    print(f"[DUCKDUCKGO_SEARCH] 🎯 Релевантные домены: {query_analysis['domains']}")
    
    # Улучшаем запрос ключевыми словами если они есть
    enhanced_query = query
    if query_analysis['keywords']:
        enhanced_query = f"{query} {' '.join(query_analysis['keywords'][:2])}"
        print(f"[DUCKDUCKGO_SEARCH] ✨ Улучшенный запрос: {enhanced_query}")

    try:
        # ddgs is optional dependency: pip install ddgs
        from ddgs import DDGS

        print(f"[DUCKDUCKGO_SEARCH] Отправка запроса...")
        with DDGS() as ddgs:
            # Получаем больше результатов для фильтрации
            raw_results = list(ddgs.text(enhanced_query, region=region, max_results=num_results * 3))

        print(f"[DUCKDUCKGO_SEARCH] Получено сырых результатов: {len(raw_results)}")
        
        # 🎯 ФИЛЬТРАЦИЯ ПО РЕЛЕВАНТНЫМ ДОМЕНАМ
        filtered_results = []
        if query_analysis['domains']:
            print(f"[DUCKDUCKGO_SEARCH] 🔍 Фильтрация по релевантным доменам...")
            for result in raw_results:
                link = result.get('href', '').lower()
                # Проверяем, содержит ли ссылка релевантный домен
                if any(domain in link for domain in query_analysis['domains']):
                    filtered_results.append(result)
                    if len(filtered_results) >= num_results:
                        break
            
            print(f"[DUCKDUCKGO_SEARCH] ✅ Отфильтровано результатов: {len(filtered_results)}")
            
            # Если после фильтрации мало результатов, берём из всех
            if len(filtered_results) < max(2, num_results // 2):
                print(f"[DUCKDUCKGO_SEARCH] ⚠️ Мало отфильтрованных результатов, добавляем общие...")
                filtered_results = raw_results[:num_results]
        else:
            # Для общих запросов берём все результаты
            filtered_results = raw_results[:num_results]
        
        results = filtered_results

        if not results:
            print(f"[DUCKDUCKGO_SEARCH] Нет результатов поиска")
            return "Ничего не найдено по вашему запросу."

        search_results = []
        for i, result in enumerate(results, 1):
            title = result.get('title', 'Без заголовка')
            body = result.get('body', 'Нет описания')
            link = result.get('href', '')
            search_results.append(f"[Результат {i}]\nЗаголовок: {title}\nОписание: {body}\nСсылка: {link}")
            print(f"[DUCKDUCKGO_SEARCH] Результат {i}: {title[:50]}...")

        final_results = "\n\n".join(search_results)
        print(f"[DUCKDUCKGO_SEARCH] Поиск завершён успешно. Длина результатов: {len(final_results)} символов")
        print(f"[DUCKDUCKGO_SEARCH] 📊 Итоговая статистика: категория={query_analysis['category']}, результатов={len(results)}")
        return final_results

    except ImportError:
        # FALLBACK: Используем простой веб-скрейпинг DuckDuckGo HTML
        print(f"[DUCKDUCKGO_SEARCH] ⚠️ Библиотека ddgs не установлена, используем fallback...")
        try:
            return fallback_web_search(enhanced_query, num_results, language)
        except Exception as fallback_error:
            error_msg = f"⚠️ Установите библиотеку ddgs: pip install ddgs\nОшибка fallback: {fallback_error}"
            print(f"[DUCKDUCKGO_SEARCH] {error_msg}")
            return error_msg
    except Exception as e:
        error_msg = f"⚠️ Ошибка поиска: {e}"
        print(f"[DUCKDUCKGO_SEARCH] {error_msg}")
        return error_msg

def fetch_page_content(url: str, max_chars: int = 5000) -> str:
    """
    Загружает и извлекает текстовое содержимое веб-страницы
    
    Args:
        url: URL страницы для загрузки
        max_chars: Максимальное количество символов для возврата
    
    Returns:
        Текстовое содержимое страницы или сообщение об ошибке
    """
    try:
        print(f"[FETCH_PAGE] Загрузка страницы: {url[:50]}...")
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
        }
        
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        
        # Используем BeautifulSoup для извлечения текста
        try:
            from bs4 import BeautifulSoup
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Удаляем скрипты и стили
            for script in soup(['script', 'style', 'nav', 'header', 'footer']):
                script.decompose()
            
            # Извлекаем текст
            text = soup.get_text(separator=' ', strip=True)
            
            # Очищаем от множественных пробелов
            import re
            text = re.sub(r'\s+', ' ', text).strip()
            
            # Ограничиваем размер
            if len(text) > max_chars:
                text = text[:max_chars] + "..."
            
            print(f"[FETCH_PAGE] ✓ Загружено {len(text)} символов")
            return text
            
        except ImportError:
            # Если BeautifulSoup не установлен, используем простую регулярку
            import re
            # Удаляем HTML теги
            text = re.sub(r'<[^>]+>', '', response.text)
            # Очищаем от множественных пробелов
            text = re.sub(r'\s+', ' ', text).strip()
            # Ограничиваем размер
            if len(text) > max_chars:
                text = text[:max_chars] + "..."
            print(f"[FETCH_PAGE] ✓ Загружено {len(text)} символов (без BS4)")
            return text
            
    except Exception as e:
        print(f"[FETCH_PAGE] ✗ Ошибка загрузки {url}: {e}")
        return f"[Ошибка загрузки страницы: {str(e)[:100]}]"

def deep_web_search(query: str, num_results: int = 5, region: str = "wt-wt", language: str = "russian"):
    """
    Глубокий веб-поиск с переходом на сайты и анализом их содержимого
    Используется в режимах "думающий" и "про"
    """
    print(f"[DEEP_SEARCH] ═══ ЗАПУСК ГЛУБОКОГО ВЕБ-ПОИСКА ═══")
    print(f"[DEEP_SEARCH] Запрос: {query}")
    
    # Сначала получаем обычные результаты поиска
    search_results = google_search(query, num_results, region, language)
    
    if "Ничего не найдено" in search_results or "Ошибка" in search_results:
        return search_results
    
    print(f"[DEEP_SEARCH] Получены результаты поиска, начинаю загрузку страниц...")
    
    # Извлекаем URL из результатов
    import re
    urls = re.findall(r'Ссылка: (https?://[^\s]+)', search_results)
    
    if not urls:
        print(f"[DEEP_SEARCH] ⚠️ URL не найдены в результатах")
        return search_results
    
    print(f"[DEEP_SEARCH] Найдено {len(urls)} URL для анализа")
    
    # Загружаем контент первых 2-3 страниц
    max_pages = min(3, len(urls))
    page_contents = []
    
    for i, url in enumerate(urls[:max_pages], 1):
        print(f"[DEEP_SEARCH] Загрузка страницы {i}/{max_pages}...")
        content = fetch_page_content(url, max_chars=3000)
        
        if content and "[Ошибка" not in content:
            page_contents.append({
                'url': url,
                'content': content
            })
    
    if not page_contents:
        print(f"[DEEP_SEARCH] ⚠️ Не удалось загрузить ни одной страницы, возвращаю базовые результаты")
        return search_results
    
    # Формируем расширенные результаты с содержимым страниц
    enhanced_results = search_results + "\n\n" + "═" * 60 + "\n"
    enhanced_results += "📄 СОДЕРЖИМОЕ ПРОАНАЛИЗИРОВАННЫХ СТРАНИЦ:\n"
    enhanced_results += "═" * 60 + "\n\n"
    
    for i, page in enumerate(page_contents, 1):
        enhanced_results += f"[Содержимое страницы {i}]\n"
        enhanced_results += f"URL: {page['url']}\n"
        enhanced_results += f"Текст: {page['content']}\n\n"
        enhanced_results += "-" * 60 + "\n\n"
    
    print(f"[DEEP_SEARCH] ✓ Глубокий поиск завершён. Загружено {len(page_contents)} страниц")
    print(f"[DEEP_SEARCH] Общий объём результатов: {len(enhanced_results)} символов")
    
    return enhanced_results

def fallback_web_search(query: str, num_results: int = 5, language: str = "russian") -> str:
    """Fallback веб-поиск через DuckDuckGo HTML без внешних библиотек"""
    print(f"[FALLBACK_SEARCH] Запуск fallback поиска для: {query}")
    
    try:
        import urllib.parse
        import re
        from html import unescape
        
        # Формируем URL для DuckDuckGo
        encoded_query = urllib.parse.quote_plus(query)
        search_url = f"https://html.duckduckgo.com/html/?q={encoded_query}"
        
        # Настраиваем заголовки чтобы выглядеть как браузер
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7' if language == "russian" else 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate',
            'DNT': '1',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        }
        
        print(f"[FALLBACK_SEARCH] Отправка запроса к DuckDuckGo...")
        response = requests.get(search_url, headers=headers, timeout=10)
        response.raise_for_status()
        
        html_content = response.text
        print(f"[FALLBACK_SEARCH] Получен HTML, длина: {len(html_content)} символов")
        
        # Парсим результаты с помощью регулярных выражений
        # DuckDuckGo HTML использует структуру: <div class="result">
        
        # Ищем заголовки результатов
        title_pattern = r'<a[^>]*class="result__a"[^>]*>([^<]+)</a>'
        titles = re.findall(title_pattern, html_content)
        
        # Ищем описания
        snippet_pattern = r'<a[^>]*class="result__snippet"[^>]*>([^<]+)</a>'
        snippets = re.findall(snippet_pattern, html_content)
        
        # Ищем ссылки
        url_pattern = r'<a[^>]*class="result__url"[^>]*href="([^"]+)"'
        urls = re.findall(url_pattern, html_content)
        
        # Если стандартный паттерн не сработал, пробуем альтернативный
        if not titles:
            print(f"[FALLBACK_SEARCH] Стандартный паттерн не сработал, пробуем альтернативный...")
            # Альтернативный паттерн для нового формата DuckDuckGo
            title_pattern = r'class="result__title"[^>]*><a[^>]*>(.+?)</a>'
            titles = re.findall(title_pattern, html_content, re.DOTALL)
            
            snippet_pattern = r'class="result__snippet">(.+?)</div>'
            snippets = re.findall(snippet_pattern, html_content, re.DOTALL)
        
        print(f"[FALLBACK_SEARCH] Найдено: заголовков={len(titles)}, описаний={len(snippets)}, ссылок={len(urls)}")
        
        if not titles and not snippets:
            print(f"[FALLBACK_SEARCH] Не удалось распарсить результаты. Возможно, изменился формат DuckDuckGo.")
            return "⚠️ Не удалось получить результаты поиска. Попробуйте установить библиотеку: pip install ddgs"
        
        # Объединяем результаты
        search_results = []
        for i in range(min(num_results, len(titles))):
            title = unescape(re.sub(r'<[^>]+>', '', titles[i])).strip() if i < len(titles) else "Без заголовка"
            snippet = unescape(re.sub(r'<[^>]+>', '', snippets[i])).strip() if i < len(snippets) else "Нет описания"
            url = urls[i] if i < len(urls) else ""
            
            # Декодируем URL если он закодирован
            if url.startswith('//duckduckgo.com/l/?'):
                # Извлекаем реальный URL из redirect
                url_match = re.search(r'uddg=([^&]+)', url)
                if url_match:
                    url = urllib.parse.unquote(url_match.group(1))
            
            search_results.append(
                f"[Результат {i+1}]\n"
                f"Заголовок: {title}\n"
                f"Описание: {snippet}\n"
                f"Ссылка: {url}"
            )
            print(f"[FALLBACK_SEARCH] Результат {i+1}: {title[:50]}...")
        
        if not search_results:
            return "⚠️ Результаты поиска пусты. Попробуйте переформулировать запрос."
        
        final_results = "\n\n".join(search_results)
        print(f"[FALLBACK_SEARCH] ✓ Fallback поиск завершён. Найдено {len(search_results)} результатов")
        return final_results
        
    except requests.Timeout:
        return "⚠️ Превышено время ожидания ответа от поисковика. Попробуйте снова."
    except requests.RequestException as e:
        return f"⚠️ Ошибка сетевого подключения: {e}"
    except Exception as e:
        print(f"[FALLBACK_SEARCH] ✗ Ошибка: {e}")
        import traceback
        traceback.print_exc()
        return f"⚠️ Ошибка fallback поиска: {e}"

# -------------------------
# TTS с pyttsx3
# -------------------------
def compress_search_results(search_results: str, max_length: int) -> str:
    """Сжимает результаты поиска до нужной длины, сохраняя самое важное"""
    print(f"[COMPRESS] Начальная длина: {len(search_results)} символов")
    print(f"[COMPRESS] Целевая длина: {max_length} символов")
    
    if len(search_results) <= max_length:
        print(f"[COMPRESS] Сжатие не требуется")
        return search_results
    
    # Разбиваем на отдельные результаты
    results = search_results.split('[Результат ')
    if len(results) <= 1:
        # Если не удалось разбить, просто обрезаем
        print(f"[COMPRESS] Простое обрезание до {max_length} символов")
        return search_results[:max_length] + "..."
    
    # Первый элемент - пустой, убираем
    results = results[1:]
    
    # Вычисляем, сколько символов на каждый результат
    chars_per_result = max_length // len(results)
    print(f"[COMPRESS] Результатов: {len(results)}, символов на результат: {chars_per_result}")
    
    compressed_results = []
    for i, result in enumerate(results, 1):
        # Восстанавливаем структуру
        result = '[Результат ' + result
        
        # Извлекаем основные части
        lines = result.split('\n')
        title_line = ""
        description_line = ""
        link_line = ""
        
        for line in lines:
            if line.startswith('Заголовок:'):
                title_line = line
            elif line.startswith('Описание:'):
                description_line = line
            elif line.startswith('Ссылка:'):
                link_line = line
        
        # Сжимаем описание, если нужно
        if description_line:
            desc_prefix = "Описание: "
            desc_text = description_line[len(desc_prefix):]
            
            # Оставляем место для заголовка и ссылки (примерно 200 символов)
            available_for_desc = chars_per_result - 200
            if available_for_desc < 100:
                available_for_desc = 100
            
            if len(desc_text) > available_for_desc:
                desc_text = desc_text[:available_for_desc] + "..."
                description_line = desc_prefix + desc_text
        
        # Собираем сжатый результат
        compressed = f"[Результат {i}]\n{title_line}\n{description_line}\n{link_line}"
        compressed_results.append(compressed)
    
    final_result = "\n\n".join(compressed_results)
    print(f"[COMPRESS] Итоговая длина: {len(final_result)} символов")
    
    return final_result


def build_contextual_search_query(user_message: str, chat_manager, chat_id: int, detected_language: str) -> str:
    """
    Формирует контекстный поисковый запрос на основе истории диалога.
    
    Логика:
    1. Определяет, является ли вопрос уточняющим (короткий или с ключевыми словами)
    2. Если уточняющий - добавляет контекст из предыдущих сообщений
    3. Если самостоятельный - возвращает как есть
    """
    print(f"[CONTEXTUAL_SEARCH] Анализирую вопрос...")
    print(f"[CONTEXTUAL_SEARCH] Вопрос: {user_message}")
    
    # Получаем последние сообщения для контекста
    if chat_manager and chat_id:
        history = chat_manager.get_chat_messages(chat_id, limit=10)
    else:
        # Fallback на старую БД
        import sqlite3
        conn = sqlite3.connect("chat_memory.db")
        cur = conn.cursor()
        cur.execute("SELECT role, content, created_at FROM messages ORDER BY id DESC LIMIT 10")
        history = list(reversed(cur.fetchall()))
        conn.close()
    
    if not history or len(history) < 2:
        print(f"[CONTEXTUAL_SEARCH] История короткая, используем исходный запрос")
        return user_message
    
    # Ключевые слова уточняющих вопросов
    clarifying_keywords_ru = [
        'а почему', 'а как', 'а где', 'а когда', 'а что', 'а кто', 'а после', 'а завтра', 'а вчера', 'а сегодня',
        'почему', 'как именно', 'что именно', 'когда именно', 'где именно',
        'расскажи', 'подробнее', 'ещё', 'еще', 'тоже', 'также', 'дальше',
        'его', 'её', 'их', 'этого', 'этой', 'этим', 'этот', 'эта', 'это',
        'тогда', 'потом', 'после этого', 'что дальше',
        'завтра', 'вчера', 'сегодня', 'послезавтра'  # ВАЖНО: добавлены временные слова
    ]
    
    clarifying_keywords_en = [
        'and why', 'and how', 'and where', 'and when', 'and what', 'and who',
        'why', 'how exactly', 'what exactly', 'when exactly', 'where exactly',
        'tell me', 'more', 'also', 'too', 'then', 'after', 'next',
        'it', 'its', 'their', 'this', 'that', 'those', 'these',
        'tomorrow', 'yesterday', 'today'  # Temporal words
    ]
    
    keywords = clarifying_keywords_ru if detected_language == "russian" else clarifying_keywords_en
    
    user_lower = user_message.lower().strip()
    
    # Проверка 1: Содержит ли вопрос ключевые слова уточнения
    has_clarifying_words = any(keyword in user_lower for keyword in keywords)
    
    # Проверка 2: ОЧЕНЬ короткий вопрос (менее 6 слов) - скорее всего уточнение
    is_very_short = len(user_message.split()) < 6
    
    # Проверка 3: Начинается с вопросительного слова без контекста
    starts_with_question = any(user_lower.startswith(q) for q in ['почему', 'как', 'где', 'когда', 'зачем', 'why', 'how', 'where', 'when'])
    
    # Проверка 4: Начинается с "а " - ВСЕГДА уточнение
    starts_with_a = user_lower.startswith('а ') or user_lower.startswith('and ')
    
    # Проверка 5: Только временные слова (завтра, вчера, сегодня)
    is_temporal_only = user_lower in ['завтра', 'вчера', 'сегодня', 'послезавтра', 'tomorrow', 'yesterday', 'today']
    
    # РАСШИРЕННАЯ ЛОГИКА: считаем уточняющим если:
    # - есть ключевые слова ИЛИ
    # - очень короткий вопрос ИЛИ
    # - начинается с "а " ИЛИ
    # - только временное слово
    is_clarifying = has_clarifying_words or is_very_short or starts_with_a or is_temporal_only
    
    if is_clarifying:
        print(f"[CONTEXTUAL_SEARCH] ✅ Обнаружен УТОЧНЯЮЩИЙ вопрос")
        print(f"[CONTEXTUAL_SEARCH]    - Ключевые слова: {has_clarifying_words}")
        print(f"[CONTEXTUAL_SEARCH]    - Очень короткий (<6 слов): {is_very_short}")
        print(f"[CONTEXTUAL_SEARCH]    - Начинается с 'а': {starts_with_a}")
        print(f"[CONTEXTUAL_SEARCH]    - Только временное слово: {is_temporal_only}")
        
        # Извлекаем последний вопрос пользователя для контекста
        context_parts = []
        
        for i in range(len(history) - 1, -1, -1):
            role, content, _ = history[i]
            
            # Берём последний вопрос пользователя (не текущий)
            if role == "user" and content != user_message:
                context_parts.insert(0, content)
                print(f"[CONTEXTUAL_SEARCH]    Найден предыдущий вопрос: {content[:50]}...")
                break
        
        if context_parts:
            # Формируем расширенный запрос
            main_context = context_parts[0]
            
            # УМНАЯ ОБРАБОТКА УТОЧНЯЮЩИХ ВОПРОСОВ
            user_lower = user_message.lower().strip()
            
            # Если вопрос начинается с "а в/а на" - это изменение места
            # Пример: "погода в Питере" + "а в Мытищах" → "погода в Мытищах"
            if detected_language == "russian":
                # Проверяем паттерны изменения места
                location_change_patterns = [
                    ('а в ', 'в '),
                    ('а на ', 'на '),
                    ('а для ', 'для ')
                ]
                
                for pattern, replacement in location_change_patterns:
                    if user_lower.startswith(pattern):
                        # Извлекаем новое место
                        new_location_part = user_message[len(pattern):]
                        
                        # Заменяем старое место на новое в исходном запросе
                        # Ищем паттерны типа "в [город]", "на [место]"
                        import re
                        # Заменяем первое вхождение предлога + место
                        for prep in ['в ', 'на ', 'для ']:
                            pattern_to_replace = prep + r'\S+'
                            if re.search(pattern_to_replace, main_context.lower()):
                                contextual_query = re.sub(
                                    pattern_to_replace,
                                    replacement + new_location_part,
                                    main_context,
                                    count=1,
                                    flags=re.IGNORECASE
                                )
                                print(f"[CONTEXTUAL_SEARCH] 🔄 Заменено место: '{main_context}' → '{contextual_query}'")
                                return contextual_query
                        
                        # Если не нашли паттерн, добавляем новое место в конец основного запроса
                        contextual_query = main_context.replace(main_context.split()[-1], new_location_part)
                        print(f"[CONTEXTUAL_SEARCH] 🔄 Изменено место (fallback): '{contextual_query}'")
                        return contextual_query
            
            else:
                # Для английского
                location_change_patterns = [
                    ('and in ', 'in '),
                    ('and at ', 'at '),
                    ('and for ', 'for ')
                ]
                
                for pattern, replacement in location_change_patterns:
                    if user_lower.startswith(pattern):
                        new_location_part = user_message[len(pattern):]
                        
                        import re
                        for prep in ['in ', 'at ', 'for ']:
                            pattern_to_replace = prep + r'\S+'
                            if re.search(pattern_to_replace, main_context.lower()):
                                contextual_query = re.sub(
                                    pattern_to_replace,
                                    replacement + new_location_part,
                                    main_context,
                                    count=1,
                                    flags=re.IGNORECASE
                                )
                                print(f"[CONTEXTUAL_SEARCH] 🔄 Replaced location: '{main_context}' → '{contextual_query}'")
                                return contextual_query
                        
                        contextual_query = main_context.replace(main_context.split()[-1], new_location_part)
                        print(f"[CONTEXTUAL_SEARCH] 🔄 Changed location (fallback): '{contextual_query}'")
                        return contextual_query
            
            # Стандартное поведение для других типов уточнений
            # Комбинируем: "основная тема" + "уточняющий вопрос"
            contextual_query = f"{main_context} {user_message}"
            
            print(f"[CONTEXTUAL_SEARCH] ✅ Расширенный запрос: {contextual_query[:100]}...")
            return contextual_query
        else:
            print(f"[CONTEXTUAL_SEARCH] ⚠️  Не найден предыдущий контекст, используем исходный запрос")
            return user_message
    else:
        print(f"[CONTEXTUAL_SEARCH] ℹ️  Самостоятельный вопрос, контекст не требуется")
        return user_message

# Озвучка полностью удалена



def init_db():
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("""
    CREATE TABLE IF NOT EXISTS messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        role TEXT,
        content TEXT,
        created_at TEXT)
    """)
    conn.commit()
    conn.close()

def save_message(role: str, content: str):
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("INSERT INTO messages (role, content, created_at) VALUES (?, ?, ?)",
                (role, content, datetime.utcnow().isoformat()))
    conn.commit()
    conn.close()

def load_history(limit=MAX_HISTORY_LOAD):
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("SELECT role, content, created_at FROM messages ORDER BY id DESC LIMIT ?", (limit,))
    rows = cur.fetchall()
    conn.close()
    return list(reversed(rows))

def clear_messages():
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("DELETE FROM messages")
    conn.commit()
    conn.close()

# -------------------------
# Model-call helpers
# -------------------------
def call_ollama_vision(image_path: str, prompt: str, max_tokens: int = 800, timeout=120):
    """
    Вызов Ollama vision модели для анализа изображений
    Использует модель llama3.2-vision или другую multimodal модель из конфигурации
    (УЛУЧШЕНО: нормализация путей с пробелами)
    """
    try:
        import base64
        
        # УЛУЧШЕНИЕ: Нормализуем путь к изображению
        image_path = os.path.normpath(os.path.abspath(image_path))
        
        print(f"[OLLAMA_VISION] ========== НАЧАЛО АНАЛИЗА ==========")
        print(f"[OLLAMA_VISION] Загрузка изображения: {image_path}")
        
        # Проверяем существование файла
        if not os.path.exists(image_path):
            error = f"❌ Файл изображения не найден: {image_path}"
            print(f"[OLLAMA_VISION] {error}")
            return error
        
        # Проверяем что это действительно файл
        if not os.path.isfile(image_path):
            error = f"❌ Путь не является файлом: {image_path}"
            print(f"[OLLAMA_VISION] {error}")
            return error
        
        # Читаем изображение и конвертируем в base64
        with open(image_path, 'rb') as img_file:
            image_bytes = img_file.read()
            image_data = base64.b64encode(image_bytes).decode('utf-8')
        
        file_size = len(image_bytes) / 1024  # KB
        print(f"[OLLAMA_VISION] ✓ Изображение закодировано в base64 (размер: {file_size:.1f} KB)")
        
        # Используем vision модель из конфигурации
        vision_model = OLLAMA_VISION_MODEL
        print(f"[OLLAMA_VISION] Модель: {vision_model}")
        print(f"[OLLAMA_VISION] Промпт: {prompt[:100]}...")
        print(f"[OLLAMA_VISION] Max tokens: {max_tokens}")
        
        url = f"{OLLAMA_HOST}/api/chat"
        headers = {"Content-Type": "application/json"}
        
        # Формируем запрос с изображением
        # Для llama3.2-vision может потребоваться упрощенный промпт
        payload = {
            "model": vision_model,
            "messages": [
                {
                    "role": "user",
                    "content": prompt,
                    "images": [image_data]
                }
            ],
            "stream": False,
            "options": {
                "num_predict": max_tokens,
                "temperature": 0.7
            }
        }
        
        print(f"[OLLAMA_VISION] Отправка запроса к {OLLAMA_HOST}/api/chat...")
        print(f"[OLLAMA_VISION] Ожидание ответа (таймаут: {timeout}s)...")
        
        r = requests.post(url, headers=headers, json=payload, timeout=timeout)
        
        # Детальная диагностика ответа
        print(f"[OLLAMA_VISION] Status Code: {r.status_code}")
        
        if r.status_code != 200:
            print(f"[OLLAMA_VISION] ❌ Ошибка HTTP {r.status_code}")
            print(f"[OLLAMA_VISION] Ответ сервера: {r.text[:500]}")
            r.raise_for_status()
        
        j = r.json()
        print(f"[OLLAMA_VISION] Получен JSON ответ")
        print(f"[OLLAMA_VISION] Ключи в ответе: {list(j.keys())}")
        
        # Проверяем разные форматы ответа
        if "message" in j and "content" in j["message"]:
            response = j["message"]["content"].strip()
            print(f"[OLLAMA_VISION] ✅ Успешный анализ (формат: message.content)")
            print(f"[OLLAMA_VISION] Длина ответа: {len(response)} символов")
            print(f"[OLLAMA_VISION] Первые 200 символов: {response[:200]}...")
            return response
        elif "response" in j:
            # Альтернативный формат
            response = j["response"].strip()
            print(f"[OLLAMA_VISION] ✅ Успешный анализ (формат: response)")
            print(f"[OLLAMA_VISION] Длина ответа: {len(response)} символов")
            return response
        else:
            print(f"[OLLAMA_VISION] ⚠️ Неожиданный формат ответа")
            print(f"[OLLAMA_VISION] Полный ответ: {json.dumps(j, indent=2, ensure_ascii=False)[:1000]}")
            return f"[Ошибка] Неожиданный формат ответа от модели. Проверьте консоль."
        
    except FileNotFoundError:
        error = f"❌ Файл изображения не найден: {image_path}"
        print(f"[OLLAMA_VISION] {error}")
        return error
    except requests.exceptions.Timeout:
        error = f"❌ Превышен таймаут ожидания ответа ({timeout}s). Модель {OLLAMA_VISION_MODEL} может быть слишком медленной или не загружена."
        print(f"[OLLAMA_VISION] {error}")
        return error
    except requests.exceptions.ConnectionError:
        error = f"""❌ Не удалось подключиться к Ollama.

Убедитесь что Ollama запущена:
1. Откройте терминал
2. Выполните: ollama serve

Или проверьте что Ollama работает на {OLLAMA_HOST}"""
        print(f"[OLLAMA_VISION] {error}")
        return error
    except requests.exceptions.HTTPError as e:
        print(f"[OLLAMA_VISION] ❌ HTTP ошибка: {e}")
        print(f"[OLLAMA_VISION] Ответ сервера: {e.response.text if hasattr(e, 'response') else 'Нет ответа'}")
        
        # Если vision модель не найдена
        if "404" in str(e) or "not found" in str(e).lower():
            error = f"""❌ Модель '{OLLAMA_VISION_MODEL}' не найдена.

Установите модель командой:
  ollama pull {OLLAMA_VISION_MODEL}

Доступные vision модели:
  • llama3.2-vision (рекомендуется, новая)
  • llava (стабильная, проверенная)
  • bakllava (альтернатива)

Проверить установленные модели:
  ollama list"""
            print(f"[OLLAMA_VISION] {error}")
            return error
        else:
            error = f"❌ HTTP ошибка {e.response.status_code}: {e.response.text[:200]}"
            print(f"[OLLAMA_VISION] {error}")
            return error
    except json.JSONDecodeError as e:
        error = f"❌ Ошибка парсинга JSON ответа: {e}"
        print(f"[OLLAMA_VISION] {error}")
        print(f"[OLLAMA_VISION] Сырой ответ: {r.text[:500]}")
        return error
    except Exception as e:
        error = f"❌ Неожиданная ошибка: {type(e).__name__}: {str(e)}"
        print(f"[OLLAMA_VISION] {error}")
        import traceback
        traceback.print_exc()
        return error
    finally:
        print(f"[OLLAMA_VISION] ========== КОНЕЦ АНАЛИЗА ==========\n")

def call_ollama_chat(messages: list, max_tokens: int = 800, timeout=60):
    """Вызов Ollama через chat API с retry при временных сбоях
    
    Использует обычную модель (НЕ vision) для текстовых ответов
    """
    print(f"[OLLAMA_CHAT] ════════════════════════════════════════")
    print(f"[OLLAMA_CHAT] 🤖 МОДЕЛЬ: {OLLAMA_MODEL} (обычная модель)")
    print(f"[OLLAMA_CHAT] 📨 Отправка запроса к Ollama...")
    
    url = f"{OLLAMA_HOST}/api/chat"
    headers = {"Content-Type": "application/json"}
    payload = {
        "model": OLLAMA_MODEL,
        "messages": messages,
        "stream": False,
        "options": {
            "num_predict": max_tokens
        }
    }
    
    # Попытка с retry для временных сбоев
    max_retries = 2
    for attempt in range(max_retries):
        try:
            print(f"[OLLAMA_CHAT] Попытка {attempt + 1}/{max_retries}: timeout={timeout}s, max_tokens={max_tokens}")
            r = requests.post(url, headers=headers, json=payload, timeout=timeout)
            r.raise_for_status()
            j = r.json()
            
            if "message" in j and "content" in j["message"]:
                response = j["message"]["content"].strip()
                print(f"[OLLAMA_CHAT] ✅ Успешный ответ, длина: {len(response)}")
                return response
            
            print(f"[OLLAMA_CHAT] ⚠️ Неожиданный формат ответа: {j}")
            # Если формат неожиданный, но это не последняя попытка - пробуем снова
            if attempt < max_retries - 1:
                print(f"[OLLAMA_CHAT] Повторная попытка через 1 секунду...")
                import time
                time.sleep(1)
                continue
            return str(j)
            
        except requests.exceptions.Timeout:
            error = f"[Ollama timeout] Превышено время ожидания {timeout}s"
            print(f"[OLLAMA_CHAT] ⏱️ {error}")
            if attempt < max_retries - 1:
                print(f"[OLLAMA_CHAT] Повторная попытка...")
                continue
            return error
            
        except requests.exceptions.ConnectionError as e:
            error = f"[Ollama connection error] Не удалось подключиться к Ollama на {OLLAMA_HOST}"
            print(f"[OLLAMA_CHAT] 🔌 {error}: {e}")
            if attempt < max_retries - 1:
                print(f"[OLLAMA_CHAT] Повторная попытка...")
                import time
                time.sleep(1)
                continue
            return error
            
        except requests.exceptions.HTTPError as e:
            error = f"[Ollama error] HTTP ошибка: {e}"
            print(f"[OLLAMA_CHAT] ❌ {error}")
            # HTTP ошибки обычно не временные, не retry
            return error
            
        except Exception as e:
            error = f"[Ollama error] Неожиданная ошибка: {e}"
            print(f"[OLLAMA_CHAT] ❌ {error}")
            if attempt < max_retries - 1:
                print(f"[OLLAMA_CHAT] Повторная попытка...")
                import time
                time.sleep(1)
                continue
            return error
    
    # Не должны сюда попасть, но на всякий случай
    return "[Ollama error] Все попытки исчерпаны"


def get_ai_response(user_message: str, current_language: str, deep_thinking: bool, use_search: bool, should_forget: bool = False, chat_manager=None, chat_id=None, file_paths: list = None, ai_mode: str = AI_MODE_FAST):
    """Получить ответ от AI (с жёстким закреплением языка)"""
    print(f"\n[GET_AI_RESPONSE] ========== НАЧАЛО ==========")
    print(f"[GET_AI_RESPONSE] Сообщение пользователя: {user_message}")
    print(f"[GET_AI_RESPONSE] Текущий язык интерфейса: {current_language}")
    print(f"[GET_AI_RESPONSE] Глубокое мышление: {deep_thinking}")
    print(f"[GET_AI_RESPONSE] Использовать поиск: {use_search}")
    print(f"[GET_AI_RESPONSE] Забыть историю: {should_forget}")
    print(f"[GET_AI_RESPONSE] Файлов прикреплено: {len(file_paths) if file_paths else 0}")

    # НОРМАЛИЗАЦИЯ МАТЕМАТИЧЕСКИХ СИМВОЛОВ
    # Заменяем специальные символы на стандартные ASCII
    user_message = user_message.replace('×', '*')  # Умножение
    user_message = user_message.replace('÷', '/')  # Деление
    user_message = user_message.replace('−', '-')  # Минус (длинное тире)
    user_message = user_message.replace('±', '+/-')  # Плюс-минус
    user_message = user_message.replace('–', '-')  # Среднее тире
    user_message = user_message.replace('—', '-')  # Длинное тире
    print(f"[GET_AI_RESPONSE] Нормализованное сообщение: {user_message}")

    # ═══════════════════════════════════════════════════════════
    # ОБРАБОТКА КОМАНД ПАМЯТИ
    # ═══════════════════════════════════════════════════════════
    user_lower = user_message.lower().strip()
    
    # Команда "ЗАПОМНИ"
    if chat_id and (user_lower.startswith("запомни") or user_lower.startswith("remember")):
        try:
            context_mgr = ContextMemoryManager()
            # Извлекаем текст после команды
            if user_lower.startswith("запомни"):
                memory_text = user_message[7:].strip()  # После "запомни"
                if memory_text.startswith(":"):
                    memory_text = memory_text[1:].strip()
            else:
                memory_text = user_message[8:].strip()  # После "remember"
                if memory_text.startswith(":"):
                    memory_text = memory_text[1:].strip()
            
            if memory_text:
                context_mgr.save_context_memory(chat_id, "user_memory", memory_text)
                print(f"[MEMORY] ✓ Сохранено: {memory_text[:50]}...")
                return "✓ Запомнил!"
        except Exception as e:
            print(f"[MEMORY] ✗ Ошибка сохранения: {e}")

    # ПРОВЕРЯЕМ РОЛЕВУЮ КОМАНДУ
    role_info = detect_role_command(user_message)
    role_instruction = ""
    if role_info["is_role_command"]:
        print(f"[GET_AI_RESPONSE] 🎭 Обнаружена РОЛЕВАЯ КОМАНДА: {role_info['role']}")
        role_instruction = role_info["instruction"]
    
    # ОПРЕДЕЛЯЕМ РЕАЛЬНЫЙ ЯЗЫК ВОПРОСА
    detected_language = detect_message_language(user_message)
    print(f"[GET_AI_RESPONSE] Определённый язык вопроса: {detected_language}")

    # ОПРЕДЕЛЯЕМ, ЯВЛЯЕТСЯ ЛИ ЗАПРОС МАТЕМАТИЧЕСКОЙ ЗАДАЧЕЙ
    is_math_problem = detect_math_problem(user_message)
    if is_math_problem:
        print(f"[GET_AI_RESPONSE] 🔬 Обнаружена МАТЕМАТИЧЕСКАЯ ЗАДАЧА - применяю олимпиадный режим")

    # Выбираем режим системного промпта на основе ai_mode
    if ai_mode == AI_MODE_FAST:
        mode = "short"
    elif ai_mode == AI_MODE_THINKING:
        mode = "deep"
    elif ai_mode == AI_MODE_PRO:
        mode = "pro"
    else:
        # Fallback на старую логику если ai_mode не распознан
        mode = "deep" if deep_thinking else "short"
    
    print(f"[GET_AI_RESPONSE] Выбран системный промпт: mode='{mode}', ai_mode='{ai_mode}'")
    base_system = SYSTEM_PROMPTS.get(detected_language, SYSTEM_PROMPTS["russian"])[mode]
    
    # ═══════════════════════════════════════════════════════════
    # ЗАГРУЗКА СОХРАНЁННОЙ ПАМЯТИ
    # ═══════════════════════════════════════════════════════════
    memory_context = ""
    if chat_id:
        try:
            context_mgr = ContextMemoryManager()
            saved_memories = context_mgr.get_context_memory(chat_id, limit=20)
            
            if saved_memories:
                user_memories = [content for ctx_type, content, _ in saved_memories if ctx_type == "user_memory"]
                
                if user_memories:
                    if detected_language == "russian":
                        memory_context = "\n\n📌 ВАЖНАЯ ИНФОРМАЦИЯ (пользователь просил запомнить):\n"
                        for idx, mem in enumerate(user_memories, 1):
                            memory_context += f"{idx}. {mem}\n"
                        print(f"[MEMORY] ✓ Загружено {len(user_memories)} записей памяти")
                    else:
                        memory_context = "\n\n📌 IMPORTANT INFORMATION (user asked to remember):\n"
                        for idx, mem in enumerate(user_memories, 1):
                            memory_context += f"{idx}. {mem}\n"
                        print(f"[MEMORY] ✓ Loaded {len(user_memories)} memory records")
        except Exception as e:
            print(f"[MEMORY] ✗ Ошибка загрузки памяти: {e}")
    
    # Добавляем математический промпт если это математическая задача
    math_prompt = ""
    if is_math_problem:
        # Выбираем математический промпт на основе режима AI
        if ai_mode == AI_MODE_FAST:
            math_prompt = MATH_PROMPTS["fast"]
            print(f"[GET_AI_RESPONSE] 🔬 Математика - режим: БЫСТРЫЙ")
        elif ai_mode == AI_MODE_THINKING:
            math_prompt = MATH_PROMPTS["thinking"]
            print(f"[GET_AI_RESPONSE] 🔬 Математика - режим: ДУМАЮЩИЙ")
        elif ai_mode == AI_MODE_PRO:
            math_prompt = MATH_PROMPTS["pro"]
            print(f"[GET_AI_RESPONSE] 🔬 Математика - режим: ПРО (олимпиадный)")
        else:
            # По умолчанию думающий режим
            math_prompt = MATH_PROMPTS["thinking"]
            print(f"[GET_AI_RESPONSE] 🔬 Математика - режим: ДУМАЮЩИЙ (по умолчанию)")
        
        print(f"[GET_AI_RESPONSE] ⚠️ Интернет ЗАПРЕЩЁН для математических задач")
        
        # КРИТИЧНО: Для математических задач ЗАПРЕЩАЕМ интернет
        use_search = False
    
    if detected_language == "russian":
        system_prompt = base_system + memory_context + math_prompt + role_instruction + """


ВАЖНО - ЯЗЫК ОТВЕТА:
• Отвечай ТОЛЬКО на русском языке
• НЕ используй английские слова (кроме имён собственных, брендов, терминов)
• Используй русские эквиваленты: however→однако, therefore→поэтому, important→важный"""
    else:
        system_prompt = base_system + memory_context + math_prompt + role_instruction

    final_user_message = user_message
    
    # Обрабатываем прикреплённые файлы
    if file_paths and len(file_paths) > 0:
        print(f"[GET_AI_RESPONSE] Обработка файлов: {len(file_paths)}")
        all_files_context = []
        
        for file_path in file_paths:
            # УЛУЧШЕНИЕ: Нормализуем путь к файлу
            file_path = os.path.normpath(os.path.abspath(file_path))
            print(f"[GET_AI_RESPONSE] Обработка файла: {file_path}")
            print(f"[GET_AI_RESPONSE] ════════════════════════════════════════")
            
            try:
                file_ext = os.path.splitext(file_path)[1].lower()
                file_name = os.path.basename(file_path)
                
                # ПРОВЕРКА: убеждаемся что файл существует
                if not os.path.exists(file_path):
                    print(f"[GET_AI_RESPONSE] ⚠️ ФАЙЛ НЕ НАЙДЕН: {file_path}")
                    
                    # Возвращаем понятную ошибку пользователю
                    if detected_language == "russian":
                        error_msg = f"""🔴 Файл '{file_name}' не найден

Путь: {file_path}

Возможные причины:
• Файл был перемещён или удалён
• Неправильный путь к файлу
• Проблема с правами доступа

Попробуйте:
1. Прикрепите файл заново
2. Убедитесь что файл существует на диске
3. Проверьте права доступа к файлу"""
                    else:
                        error_msg = f"""🔴 File '{file_name}' not found

Path: {file_path}

Possible reasons:
• File was moved or deleted
• Incorrect file path
• Access permission issue

Try:
1. Attach the file again
2. Make sure the file exists on disk
3. Check file access permissions"""
                    
                    return error_msg
                
                # Проверяем тип файла
                if file_ext in ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp']:
                    # ═══════════════════════════════════════════════════════
                    # ИЗОБРАЖЕНИЕ - Используем Vision модель (llama3.2-vision)
                    # ═══════════════════════════════════════════════════════
                    print(f"[GET_AI_RESPONSE] 🖼️ ТИП: ИЗОБРАЖЕНИЕ")
                    print(f"[GET_AI_RESPONSE] 🤖 МОДЕЛЬ: {OLLAMA_VISION_MODEL} (Vision)")
                    print(f"[GET_AI_RESPONSE] 📊 Запуск VISION анализа...")
                    
                    # Формируем промпт в зависимости от режима
                    if ai_mode == AI_MODE_FAST:
                        if detected_language == "russian":
                            vision_prompt = f"Кратко опиши что на изображении '{file_name}'."
                        else:
                            vision_prompt = f"Briefly describe what's in the image '{file_name}'."
                    elif ai_mode == AI_MODE_THINKING:
                        if detected_language == "russian":
                            vision_prompt = f"Подробно проанализируй изображение '{file_name}'. Опиши все важные детали, объекты, текст (если есть), цвета, композицию."
                        else:
                            vision_prompt = f"Analyze the image '{file_name}' in detail. Describe all important details, objects, text (if any), colors, composition."
                    else:  # PRO
                        if detected_language == "russian":
                            vision_prompt = f"""Максимально детальный анализ изображения '{file_name}':
1. Основной объект/сцена
2. Все видимые объекты и их расположение
3. Текст на изображении (если есть) - перепиши дословно
4. Цветовая схема и освещение
5. Качество изображения, разрешение
6. Контекст и возможное назначение
7. Любые необычные или важные детали"""
                        else:
                            vision_prompt = f"""Maximum detailed image analysis for '{file_name}':
1. Main object/scene
2. All visible objects and their location
3. Text in the image (if any) - transcribe verbatim
4. Color scheme and lighting
5. Image quality, resolution
6. Context and possible purpose
7. Any unusual or important details"""
                    
                    # Анализируем изображение через vision модель
                    vision_response = call_ollama_vision(file_path, vision_prompt, max_tokens=1500 if ai_mode == AI_MODE_PRO else 800, timeout=120)
                    
                    # УЛУЧШЕННАЯ ПРОВЕРКА НА ОШИБКИ
                    # Проверяем наличие любых символов ошибки
                    is_error = (
                        "❌" in vision_response or 
                        "[Ошибка" in vision_response or 
                        "[OLLAMA" in vision_response or
                        "не найден" in vision_response.lower() or
                        "not found" in vision_response.lower() or
                        "connection" in vision_response.lower() or
                        "timeout" in vision_response.lower()
                    )
                    
                    if not is_error:
                        # Успешный анализ - добавляем в контекст
                        all_files_context.append(f"[Изображение: {file_name}]\n{vision_response}")
                        print(f"[GET_AI_RESPONSE] ✅ Vision анализ завершен для {file_name}")
                    else:
                        # КРИТИЧНО: НЕ включаем текст ошибки в контекст!
                        # Вместо этого возвращаем понятное сообщение пользователю
                        print(f"[GET_AI_RESPONSE] ❌ Ошибка vision анализа для {file_name}")
                        print(f"[GET_AI_RESPONSE] Детали ошибки: {vision_response}")
                        
                        # Возвращаем ошибку напрямую пользователю БЕЗ фильтрации
                        if detected_language == "russian":
                            error_msg = f"""🔴 Не удалось обработать изображение '{file_name}'

{vision_response}

Возможные решения:
1. Убедитесь что Ollama запущена (выполните в терминале: ollama serve)
2. Проверьте что модель установлена: ollama pull {OLLAMA_VISION_MODEL}
3. Попробуйте прикрепить файл снова"""
                        else:
                            error_msg = f"""🔴 Failed to process image '{file_name}'

{vision_response}

Possible solutions:
1. Make sure Ollama is running (run in terminal: ollama serve)
2. Check that model is installed: ollama pull {OLLAMA_VISION_MODEL}
3. Try attaching the file again"""
                        
                        return error_msg
                    
                else:
                    # ═══════════════════════════════════════════════════════
                    # ТЕКСТОВЫЙ ФАЙЛ - Читаем и обрабатываем обычной моделью
                    # ═══════════════════════════════════════════════════════
                    print(f"[GET_AI_RESPONSE] 📄 ТИП: ТЕКСТОВЫЙ ФАЙЛ")
                    print(f"[GET_AI_RESPONSE] 🤖 МОДЕЛЬ: {OLLAMA_MODEL} (обычная модель)")
                    print(f"[GET_AI_RESPONSE] 📖 Чтение файла...")
                    
                    try:
                        # Пробуем разные кодировки
                        encodings = ['utf-8', 'cp1251', 'latin-1']
                        file_content = None
                        used_encoding = None
                        
                        for encoding in encodings:
                            try:
                                with open(file_path, 'r', encoding=encoding) as f:
                                    file_content = f.read()[:10000]  # Ограничиваем 10000 символов
                                used_encoding = encoding
                                break
                            except UnicodeDecodeError:
                                continue
                        
                        if file_content:
                            if detected_language == "russian":
                                all_files_context.append(f"""[Файл: {file_name}]
СОДЕРЖИМОЕ:
{file_content}""")
                            else:
                                all_files_context.append(f"""[File: {file_name}]
CONTENT:
{file_content}""")
                            print(f"[GET_AI_RESPONSE] ✅ Файл прочитан ({used_encoding}): {file_name}")
                        else:
                            raise UnicodeDecodeError("all", b"", 0, 0, "Could not decode with any encoding")
                            
                    except Exception as e:
                        # Не удалось прочитать как текст
                        print(f"[GET_AI_RESPONSE] ❌ Не удалось прочитать файл: {file_name} ({e})")
                        
                        # Показываем понятное сообщение
                        if detected_language == "russian":
                            error_msg = f"""⚠️ Файл '{file_name}' не может быть прочитан

Возможные причины:
• Это бинарный файл (exe, pdf, docx и т.д.)
• Неподдерживаемая кодировка

Поддерживаемые текстовые файлы: .txt, .py, .js, .html, .css, .md и др.
Для изображений используйте форматы: .png, .jpg, .jpeg, .gif"""
                        else:
                            error_msg = f"""⚠️ File '{file_name}' cannot be read

Possible reasons:
• This is a binary file (exe, pdf, docx, etc.)
• Unsupported encoding

Supported text files: .txt, .py, .js, .html, .css, .md, etc.
For images use formats: .png, .jpg, .jpeg, .gif"""
                        
                        return error_msg
                        
            except Exception as e:
                print(f"[GET_AI_RESPONSE] Ошибка обработки файла {file_name}: {e}")
                import traceback
                traceback.print_exc()
        
        # Объединяем контекст всех файлов
        if all_files_context:
            # Формируем инструкцию в зависимости от режима
            if ai_mode == AI_MODE_FAST:
                if detected_language == "russian":
                    file_instruction = "Кратко ответь на вопрос используя информацию из файлов."
                else:
                    file_instruction = "Answer briefly using information from the files."
            elif ai_mode == AI_MODE_THINKING:
                if detected_language == "russian":
                    file_instruction = "Проанализируй содержимое файлов. Дай развернутый ответ с примерами и пояснениями."
                else:
                    file_instruction = "Analyze the file contents. Provide a detailed answer with examples and explanations."
            else:  # PRO
                if detected_language == "russian":
                    file_instruction = """Максимально глубокий анализ файлов:
1. Обзор всех файлов
2. Ключевые моменты из каждого файла
3. Связи между файлами (если применимо)
4. Детальный ответ на вопрос пользователя с обоснованием"""
                else:
                    file_instruction = """Maximum deep file analysis:
1. Overview of all files
2. Key points from each file
3. Connections between files (if applicable)
4. Detailed answer to user's question with justification"""
            
            files_context = "\n\n".join(all_files_context)
            
            if detected_language == "russian":
                final_user_message = f"""[Пользователь прикрепил {len(file_paths)} файл(ов)]

{files_context}

ИНСТРУКЦИЯ:
{file_instruction}

Вопрос пользователя: {user_message}"""
            else:
                final_user_message = f"""[User attached {len(file_paths)} file(s)]

{files_context}

INSTRUCTION:
{file_instruction}

User's question: {user_message}"""
            
            print(f"[GET_AI_RESPONSE] Все файлы добавлены в контекст")
    
    print(f"[GET_AI_RESPONSE] Контекстная память добавлена в системный промпт")

    if use_search:
        print(f"[GET_AI_RESPONSE] ПОИСК АКТИВИРОВАН! Выполняю поиск...")
        if detected_language == "russian":
            region = "ru-ru"
        else:
            region = "us-en"
        num_results = 8 if deep_thinking else 3
        
        # 🔥 КОНТЕКСТНЫЙ ПОИСК: формируем запрос с учётом истории диалога
        contextual_query = build_contextual_search_query(user_message, chat_manager, chat_id, detected_language)
        print(f"[GET_AI_RESPONSE] 🔍 Поисковый запрос: {contextual_query}")
        
        # УМНЫЙ ПОИСК: используем deep_web_search для режимов "думающий" и "про"
        if ai_mode in [AI_MODE_THINKING, AI_MODE_PRO]:
            print(f"[GET_AI_RESPONSE] 🧠 Использую ГЛУБОКИЙ веб-поиск (анализ сайтов)")
            search_results = deep_web_search(contextual_query, num_results=num_results, region=region, language=detected_language)
        else:
            print(f"[GET_AI_RESPONSE] ⚡ Использую БЫСТРЫЙ веб-поиск (только результаты)")
            search_results = google_search(contextual_query, num_results=num_results, region=region, language=detected_language)
        
        print(f"[GET_AI_RESPONSE] Результаты поиска получены. Длина: {len(search_results)} символов")
        print(f"[GET_AI_RESPONSE] Первые 300 символов результатов: {search_results[:300]}...")

        # СЖИМАЕМ результаты поиска под лимит токенов
        # Примерно 1 токен ≈ 4 символа для русского, ≈ 3 символа для английского
        # Оставляем место для системного промпта (~500 токенов) и ответа
        if deep_thinking:
            # Режим "Думать" - больше токенов на контекст
            max_search_tokens = 2000  # ~8000 символов для русского
        else:
            # Быстрый режим - меньше токенов
            max_search_tokens = 1000  # ~4000 символов для русского
        
        max_search_chars = max_search_tokens * 4 if detected_language == "russian" else max_search_tokens * 3
        print(f"[GET_AI_RESPONSE] Лимит для результатов поиска: {max_search_tokens} токенов ({max_search_chars} символов)")
        
        if len(search_results) > max_search_chars:
            print(f"[GET_AI_RESPONSE] Результаты поиска слишком длинные, сжимаем...")
            search_results = compress_search_results(search_results, max_search_chars)

        if detected_language == "russian":
            # УПРОЩЁННЫЕ инструкции БЕЗ явных заголовков
            # Проверяем, является ли запрос о погоде
            is_weather_query = any(kw in user_message.lower() for kw in ['погода', 'температура', 'градус', 'прогноз', 'тепло', 'холодно', 'мороз', 'жара'])
            
            if is_weather_query:
                # СПЕЦИАЛЬНАЯ ИНСТРУКЦИЯ ДЛЯ ПОГОДЫ
                if deep_thinking:
                    search_instruction = """Это запрос о погоде. ОБЯЗАТЕЛЬНО структурируй ответ по времени суток:
• ДНЁМ: температура, ощущается как, ветер, осадки
• НОЧЬЮ: температура, ощущается как, ветер, осадки

Найди в результатах поиска данные для дня и ночи. Если точных данных нет - укажи общую температуру и диапазон.

⚠️ КРИТИЧЕСКИ ВАЖНО - ЯЗЫК:
Отвечай ИСКЛЮЧИТЕЛЬНО на русском языке! ВСЕ слова должны быть на русском.
НЕ используй английские слова: however, moreover, therefore, essentially, arrives, becomes, provides, important, situation, option, example, process, also, really.
Переведи ВСЮ информацию из поисковых результатов на русский язык."""
                else:
                    search_instruction = """Это запрос о погоде. Структурируй ответ:
ДНЁМ: температура, ветер
НОЧЬЮ: температура, ветер

⚠️ КРИТИЧЕСКИ ВАЖНО: Отвечай ТОЛЬКО на русском языке! Переведи всю информацию из результатов поиска."""
            else:
                # Обычные инструкции для не-погодных запросов
                if deep_thinking:
                    search_instruction = """Учитывай контекст диалога и предыдущие сообщения. Проанализируй найденную информацию, выбери только релевантную для запроса, сравни данные из разных источников. Дай подробный, понятный ответ своими словами на основе найденной информации.

⚠️ КРИТИЧЕСКИ ВАЖНО - ЯЗЫК:
Отвечай ИСКЛЮЧИТЕЛЬНО на русском языке! ВСЕ слова должны быть на русском (кроме имён собственных, брендов, технических терминов).
НЕ используй английские слова: however, moreover, therefore, essentially, arrives, becomes, provides, important, situation, option, example, process, also, really, features, includes, allows, offers.
Переведи ВСЮ информацию из поисковых результатов на русский язык."""
                else:
                    search_instruction = """Найди главную информацию в результатах и дай краткий ответ по сути.

⚠️ КРИТИЧЕСКИ ВАЖНО: Отвечай ТОЛЬКО на русском языке! Переведи всю информацию из результатов поиска на русский."""
            
            search_context = f"""Ниже результаты поиска в интернете. Используй их для ответа на вопрос.

Результаты поиска:
{search_results}

Вопрос: {user_message}

Проанализируй результаты и дай ответ на основе найденной информации. Пиши своими словами, кратко и понятно."""
        else:
            # Simplified instructions WITHOUT explicit headers
            # Check if this is a weather query
            is_weather_query = any(kw in user_message.lower() for kw in ['weather', 'temperature', 'forecast', 'warm', 'cold', 'hot'])
            
            if is_weather_query:
                # SPECIAL INSTRUCTION FOR WEATHER
                if deep_thinking:
                    search_instruction = """This is a weather query. MUST structure answer by time of day:
• DAYTIME: temperature, feels like, wind, precipitation
• NIGHTTIME: temperature, feels like, wind, precipitation

Find data for day and night in search results. If no exact data - provide general temperature and range."""
                else:
                    search_instruction = """This is a weather query. Structure answer:
DAYTIME: temperature, wind
NIGHTTIME: temperature, wind"""
            else:
                # Regular instructions for non-weather queries
                if deep_thinking:
                    search_instruction = """Consider dialog context and previous messages. Analyze found information, select only relevant data, compare sources. Give detailed, clear answer in your own words based on search results."""
                else:
                    search_instruction = """Find main information in results and give brief answer to the point."""
            
            search_context = f"""Search results from the internet are below. Use them to answer the question.

Search results:
{search_results}

Question: {user_message}

Analyze the results and provide answer based on the information found. Write in your own words, briefly and clearly."""
        print(f"[GET_AI_RESPONSE] Контекст поиска добавлен. Длина: {len(search_context)} символов")
        final_user_message = search_context
    else:
        print(f"[GET_AI_RESPONSE] Поиск НЕ активирован")

    # Если запрошено забывание, НЕ загружаем историю
    if should_forget:
        messages = [{"role": "system", "content": system_prompt}]
        messages.append({
            "role": "user",
            "content": final_user_message
        })
        print(f"[GET_AI_RESPONSE] Режим забывания: история не загружается")
    else:
        # Загружаем историю из chat_manager если доступен, иначе из старой БД
        # ВАЖНО: загружаем историю ДАЖЕ при включенном поиске для учета контекста
        if chat_manager and chat_id:
            history = chat_manager.get_chat_messages(chat_id, limit=MAX_HISTORY_LOAD)
            print(f"[GET_AI_RESPONSE] Загружено сообщений из чата {chat_id}: {len(history)}")
        else:
            history = load_history(limit=MAX_HISTORY_LOAD)
            print(f"[GET_AI_RESPONSE] Загружено сообщений из истории: {len(history)}")
        
        messages = [{"role": "system", "content": system_prompt}]
        for role, content, _ in history:
            # Пропускаем системные сообщения
            if role not in ["user", "assistant"]:
                continue
            messages.append({
                "role": "user" if role == "user" else "assistant",
                "content": content
            })
        messages.append({
            "role": "user",
            "content": final_user_message
        })
        
        if use_search:
            print(f"[GET_AI_RESPONSE] Режим поиска: история загружена для учета контекста диалога")

    print(f"[GET_AI_RESPONSE] Всего сообщений для отправки в AI: {len(messages)}")

    # ═══════════════════════════════════════════════════════════════════
    # АДАПТИВНОЕ ОПРЕДЕЛЕНИЕ ЛИМИТА ТОКЕНОВ
    # ═══════════════════════════════════════════════════════════════════
    # Вместо жестких лимитов используем умную логику, которая:
    # 1. Анализирует длину запроса пользователя
    # 2. Учитывает режим AI
    # 3. Даёт запас для завершения мысли
    # 
    # ЦЕЛЬ: Избежать обрыва ответов на полуслове
    # ═══════════════════════════════════════════════════════════════════
    
    # Анализируем длину запроса пользователя
    user_message_length = len(user_message)
    
    # Базовые лимиты в зависимости от режима AI
    if ai_mode == AI_MODE_FAST:
        base_tokens = 400  # Быстрый режим - короткие ответы, но не слишком
    elif ai_mode == AI_MODE_THINKING:
        base_tokens = 1200  # Думающий режим - средние ответы
    elif ai_mode == AI_MODE_PRO:
        base_tokens = 2500  # Про режим - детальные ответы
    else:
        base_tokens = 800   # По умолчанию
    
    # Коэффициент на основе длины запроса
    if user_message_length < 50:
        length_multiplier = 1.0  # Короткий вопрос
    elif user_message_length < 200:
        length_multiplier = 1.3  # Средний вопрос - больше деталей
    elif user_message_length < 500:
        length_multiplier = 1.6  # Длинный вопрос - ещё больше деталей
    else:
        length_multiplier = 2.0  # Очень длинный вопрос - максимум деталей
    
    # Коэффициент на основе поиска
    if use_search:
        search_multiplier = 1.2  # С поиском нужно больше токенов для синтеза
    else:
        search_multiplier = 1.0
    
    # Итоговый расчёт с запасом
    calculated_tokens = int(base_tokens * length_multiplier * search_multiplier)
    
    # Безопасные границы (минимум и максимум)
    min_tokens = 300   # Минимум чтобы не обрывать
    max_tokens_limit = 4000  # Максимум для производительности
    
    max_tokens = max(min_tokens, min(calculated_tokens, max_tokens_limit))
    
    print(f"[GET_AI_RESPONSE] Адаптивный расчёт токенов:")
    print(f"  - Режим AI: {ai_mode} (база: {base_tokens})")
    print(f"  - Длина запроса: {user_message_length} символов (множитель: {length_multiplier}x)")
    print(f"  - Поиск: {'да' if use_search else 'нет'} (множитель: {search_multiplier}x)")
    print(f"  - Итоговый лимит: {max_tokens} токенов")

    # Увеличиваем timeout для сложных запросов
    if use_search and deep_thinking:
        timeout = 180  # 3 минуты для поиска + глубокое мышление
    elif use_search or deep_thinking:
        timeout = 120  # 2 минуты для поиска ИЛИ глубокое мышление
    else:
        timeout = 60   # 1 минута для обычных запросов

    response_text = ""
    
    if USE_OLLAMA:
        print(f"[GET_AI_RESPONSE] Использую Ollama (LLaMA)...")
        try:
            resp = call_ollama_chat(messages, max_tokens=max_tokens, timeout=timeout)
            
            # Проверяем, что ответ не является ошибкой
            if not resp.startswith("[Ollama error]") and not resp.startswith("[Ollama timeout]") and not resp.startswith("[Ollama connection error]"):
                print(f"[GET_AI_RESPONSE] Ollama ответил успешно. Длина ответа: {len(resp)}")
                response_text = resp
            else:
                print(f"[GET_AI_RESPONSE] Ollama вернул ошибку: {resp}")
                response_text = "❌ Ошибка: не удалось получить ответ от локальной модели LLaMA. Проверьте:\n1. Запущена ли Ollama\n2. Загружена ли модель\n3. Достаточно ли памяти"
        except Exception as e:
            print(f"[GET_AI_RESPONSE] Исключение при вызове Ollama: {e}")
            response_text = f"❌ Ошибка подключения к LLaMA: {e}"
    
    # КРИТИЧЕСКАЯ ПРОВЕРКА: если вопрос на русском, но ответ содержит много английского - переводим
    if detected_language == "russian":
        # Проверяем, есть ли в ответе много английского
        response_lang = detect_message_language(response_text)
        if response_lang == "english":
            print(f"[GET_AI_RESPONSE] ⚠️⚠️⚠️ КРИТИЧНО! Ответ ПОЛНОСТЬЮ на английском! Переводим...")
            try:
                response_text = translate_to_russian(response_text)
                print(f"[GET_AI_RESPONSE] ✓ Перевод завершён успешно")
            except Exception as e:
                print(f"[GET_AI_RESPONSE] ✗ Ошибка перевода: {e}")
    
    # ФИЛЬТРАЦИЯ ОТКЛЮЧЕНА: системный промпт достаточно строгий
    # Агрессивная фильтрация может ломать нормальный текст
    # if detected_language == "russian":
    #     print(f"[GET_AI_RESPONSE] Фильтрация английских слов...")
    #     response_text = remove_english_words_from_russian(response_text)
    
    # ИСПРАВЛЕНО: НЕ сохраняем полный контекст поиска, чтобы избежать дублирования
    # Сохраняем только метаданные о том, что поиск был выполнен
    if use_search and chat_id and response_text:
        try:
            context_mgr = ContextMemoryManager()
            # Только факт поиска, БЕЗ содержимого ответа
            context_entry = f"[Поиск] {user_message[:80]}"
            context_mgr.save_context_memory(chat_id, "search_meta", context_entry)
            print(f"[GET_AI_RESPONSE] Сохранены метаданные поиска (без дублирования)")
        except Exception as e:
            print(f"[GET_AI_RESPONSE] Ошибка сохранения метаданных: {e}")
    
    print(f"[GET_AI_RESPONSE] ========== КОНЕЦ ==========\n")
    return response_text

# -------------------------
# New helper: decide short text
# -------------------------
def is_short_text(text: str) -> bool:
    """
    Возвращает True если текст короткий — критерии:
    - по символам меньше SHORT_TEXT_THRESHOLD, и
    - не более 2 строк
    """
    if not text:
        return True
    s = text.strip()
    lines = s.count("\n") + 1
    return len(s) <= SHORT_TEXT_THRESHOLD and lines <= 2

# -------------------------
# Animated Checkbox
# -------------------------
class AnimatedCheckBox(QtWidgets.QCheckBox):
    """Чекбокс с плавной анимацией масштабирования через размер шрифта"""
    
    def __init__(self, text, parent=None):
        super().__init__(text, parent)
        
        # Флаг блокировки быстрых нажатий
        self.animation_in_progress = False
        
        try:
            # Сохраняем исходный размер шрифта с проверкой
            self.original_font = self.font()
            self.original_font_size = self.original_font.pointSize()
            if self.original_font_size <= 0:
                self.original_font_size = 11  # Дефолт для чекбоксов
            
            # Анимация размера шрифта
            self.font_animation = QtCore.QVariantAnimation()
            self.font_animation.setDuration(180)  # Быстро и плавно
            self.font_animation.setEasingCurve(QtCore.QEasingCurve.Type.InOutCubic)
            self.font_animation.valueChanged.connect(self.update_font_size)
        except Exception as e:
            print(f"[AnimatedCheckBox] Ошибка инициализации: {e}")
            self.original_font_size = 11
    
    def update_font_size(self, size):
        """Обновляет размер шрифта для эффекта масштабирования"""
        try:
            if hasattr(self, 'original_font') and size > 0:
                new_font = QtGui.QFont(self.original_font)
                new_font.setPointSize(int(size))
                self.setFont(new_font)
        except Exception as e:
            print(f"[AnimatedCheckBox] Ошибка update_font_size: {e}")
    
    def nextCheckState(self):
        """Переопределяем для добавления анимации"""
        if self.animation_in_progress:
            return
        
        try:
            # Запускаем анимацию
            self.start_animation()
        except Exception as e:
            print(f"[AnimatedCheckBox] Ошибка анимации: {e}")
        
        # Вызываем родительский метод
        super().nextCheckState()
    
    def start_animation(self):
        """Плавная анимация увеличения/уменьшения при клике"""
        try:
            self.animation_in_progress = True
            
            # Останавливаем текущую анимацию
            if hasattr(self, 'font_animation') and self.font_animation.state() == QtCore.QAbstractAnimation.State.Running:
                self.font_animation.stop()
            
            # Вычисляем размеры
            increase_size = self.original_font_size + 2  # Увеличение на 2pt
            
            # Анимация: нормальный → увеличенный → нормальный
            self.font_animation.setStartValue(self.original_font_size)
            self.font_animation.setKeyValueAt(0.5, increase_size)  # Середина - увеличение
            self.font_animation.setEndValue(self.original_font_size)  # Конец - возврат
            self.font_animation.start()
            
            # Разблокируем
            QtCore.QTimer.singleShot(180, lambda: setattr(self, 'animation_in_progress', False))
        except Exception as e:
            print(f"[AnimatedCheckBox] Ошибка start_animation: {e}")
            self.animation_in_progress = False

# -------------------------
# Glass Tooltip (стеклянная подсказка)
# -------------------------
class GlassTooltip(QtWidgets.QLabel):
    """Стеклянная подсказка с автоисчезновением"""
    
    def __init__(self, text, parent=None):
        super().__init__(text, parent)
        self.setWindowFlags(QtCore.Qt.WindowType.ToolTip | QtCore.Qt.WindowType.FramelessWindowHint)
        # Прозрачность работает плохо на Windows
        if not IS_WINDOWS:
            self.setAttribute(QtCore.Qt.WidgetAttribute.WA_TranslucentBackground)
        
        # Стиль стеклянной подсказки
        self.setStyleSheet("""
            QLabel {
                background: rgba(255, 255, 255, 0.75);
                border: 1px solid rgba(255, 255, 255, 0.85);
                border-radius: 12px;
                padding: 8px 14px;
                color: #2d3748;
                font-family: Inter;
                font-size: 13px;
                font-weight: 500;
            }
        """)
        
        # Эффект прозрачности для анимации
        self.opacity_effect = QtWidgets.QGraphicsOpacityEffect(self)
        self.setGraphicsEffect(self.opacity_effect)
        self.opacity_effect.setOpacity(0)
        
        # Анимация появления
        self.fade_in = QtCore.QPropertyAnimation(self.opacity_effect, b"opacity")
        self.fade_in.setDuration(350)  # 350ms - более плавная анимация
        self.fade_in.setStartValue(0.0)
        self.fade_in.setEndValue(1.0)
        self.fade_in.setEasingCurve(QtCore.QEasingCurve.Type.OutExpo)  # Более естественная кривая
        
        # Анимация исчезновения
        self.fade_out = QtCore.QPropertyAnimation(self.opacity_effect, b"opacity")
        self.fade_out.setDuration(300)  # 300ms - плавное исчезновение
        self.fade_out.setStartValue(1.0)
        self.fade_out.setEndValue(0.0)
        self.fade_out.setEasingCurve(QtCore.QEasingCurve.Type.InExpo)  # Симметричная кривая для исчезновения
        self.fade_out.finished.connect(self.hide)
    
    def show_at(self, global_pos):
        """Показать подсказку в указанной позиции"""
        self.adjustSize()
        # Позиционируем чуть ниже кнопки
        self.move(global_pos.x() - self.width() // 2, global_pos.y() + 10)
        self.show()
        self.fade_in.start()
        
        # Автоматически скрыть через 2 секунды
        QtCore.QTimer.singleShot(2000, self.hide_animated)
    
    def hide_animated(self):
        """Плавно скрыть подсказку"""
        self.fade_out.start()

# -------------------------
# FadingScrollArea — top-edge gradient overlay
# -------------------------
class _FadingViewport(QtWidgets.QWidget):
    """
    Drop-in replacement for the default QScrollArea viewport.

    paintEvent():
      1. Calls the normal viewport paint (all child message widgets render).
      2. Paints ONE semi-transparent gradient rect on top.
         • Colour: BLACK with varying alpha → creates subtle fade effect
           without "whitening" the content like white overlay did.
         • Alpha ramp: 0 … ~40 (out of 255) over FADE_HEIGHT pixels.
      3. Zero pixmap allocation per frame — QPainter draws directly into
         the device.  Single drawRect call.  Smooth at 60 fps.
      4. WA_TransparentForMouseEvents ensures gradient doesn't block clicks.
    """
    FADE_HEIGHT = 40   # Height of fade gradient in pixels

    def __init__(self, parent=None):
        super().__init__(parent)
        # ✅ Градиент не должен блокировать клики мыши на MessageWidget
        self.setAttribute(QtCore.Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)

    def paintEvent(self, event):
        # ✅ 1. ОБЯЗАТЕЛЬНО: Normal paint — every child widget (messages) draws itself FIRST.
        super().paintEvent(event)

        # 2. Paint the gradient overlay on top.
        #    Only worth painting when there is something to scroll over
        #    (i.e. content is taller than the viewport).
        scroll_area = self.parent()                          # the QScrollArea
        if scroll_area is None:
            return
        sb = scroll_area.verticalScrollBar()
        if sb is None or sb.maximum() == 0:
            # Nothing scrollable → no messages are hidden → skip.
            return

        # ✅ 3. Создаём QPainter ПОСЛЕ super().paintEvent()
        painter = QtGui.QPainter(self)
        
        # ✅ 4. ОБЯЗАТЕЛЬНО: Устанавливаем режим композиции ПЕРЕД рисованием
        painter.setCompositionMode(QtGui.QPainter.CompositionMode.CompositionMode_SourceOver)

        # ✅ 5. Используем полупрозрачный ЧЁРНЫЙ градиент вместо белого
        # Чёрный градиент создаёт затемнение (fade to dark), а не осветление (забеливание)
        # ✅ 6. Градиент рисуется только в верхней зоне FADE_HEIGHT, НЕ по всей высоте
        # ✅ ИСПРАВЛЕНО: Уменьшена интенсивность для более мягкого эффекта
        w = self.width()
        h = self.FADE_HEIGHT  # Только верхняя зона

        grad = QtGui.QLinearGradient(0, 0, 0, h)
        grad.setColorAt(0.0,  QtGui.QColor(0, 0, 0, 25))   # ✅ Чёрный с alpha 25 вверху (мягче)
        grad.setColorAt(0.5,  QtGui.QColor(0, 0, 0, 10))   # ✅ Чёрный с alpha 10 в середине
        grad.setColorAt(1.0,  QtGui.QColor(0, 0, 0, 0))    # ✅ Полностью прозрачный внизу

        painter.setBrush(grad)
        painter.setPen(QtCore.Qt.PenStyle.NoPen)
        painter.drawRect(0, 0, w, h)  # Рисуем только в верхней зоне FADE_HEIGHT
        painter.end()


# -------------------------
# Message widget (с адаптивным размером эмодзи)
# -------------------------
class MessageWidget(QtWidgets.QWidget):
    """Виджет для отображения сообщения"""

    def __init__(self, speaker: str, text: str, add_controls: bool = False,
                 language: str = "russian", main_window=None, parent=None, thinking_time: float = 0, action_history: list = None, attached_files: list = None):
        super().__init__(parent)
        
        # ✅ КРИТИЧНО: Size policy для виджета сообщения
        # Preferred по горизонтали - занимает предпочтительную ширину
        # Minimum по вертикали - НЕ позволяет layout сжимать виджет ниже его содержимого
        self.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.Preferred,   # Horizontal - предпочтительная ширина
            QtWidgets.QSizePolicy.Policy.Minimum      # Vertical - НЕ сжимается!
        )
        
        self.text = text
        self.language = language
        self.speaker = speaker  # Сохраняем спикера
        self.main_window = main_window  # Ссылка на главное окно
        self.copy_button = None  # Ссылка на кнопку копирования для анимации
        self.thinking_time = thinking_time  # Время обдумывания в секундах
        self.action_history = action_history or []  # История действий
        
        # Создаём эффект прозрачности для анимации
        self.opacity_effect = QtWidgets.QGraphicsOpacityEffect(self)
        self.setGraphicsEffect(self.opacity_effect)
        self.opacity_effect.setOpacity(0)  # Начинаем с полной прозрачности

        # ═══════════════════════════════════════════════════════════════════════
        # ПОЛУЧАЕМ НАСТРОЙКИ LIQUID GLASS И ТЕМЫ ИЗ ГЛАВНОГО ОКНА
        # ═══════════════════════════════════════════════════════════════════════
        liquid_glass = True  # По умолчанию включено
        theme = "light"  # По умолчанию светлая
        
        if main_window:
            # Пытаемся загрузить сохранённые настройки
            try:
                if os.path.exists("app_settings.json"):
                    with open("app_settings.json", "r", encoding="utf-8") as f:
                        settings = json.load(f)
                        liquid_glass = settings.get("liquid_glass", True)
                        theme = settings.get("theme", "light")
            except Exception as e:
                print(f"[MSG_WIDGET] Не удалось загрузить настройки: {e}")

        # Сохраняем настройки для возможности обновления стилей
        self.current_theme = theme
        self.current_liquid_glass = liquid_glass

        # ═══════════════════════════════════════════════════════════════════════
        # ПРАВИЛЬНАЯ ЛОГИКА: СНАЧАЛА ТЕМА, ПОТОМ СТЕКЛО
        # ═══════════════════════════════════════════════════════════════════════
        # 
        # ЛОГИКА:
        # 1. Определяем базовые цвета по speaker
        # 2. Определяем тему (light/dark)
        # 3. Применяем liquid_glass (glass/matte)
        # 
        # РЕЗУЛЬТАТ:
        # Light + Glass → светлые стеклянные пузыри
        # Light + NoGlass → светлые матовые пузыри
        # Dark + Glass → тёмные стеклянные пузыри (НЕ светлые!)
        # Dark + NoGlass → тёмные матовые пузыри
        # ═══════════════════════════════════════════════════════════════════════
        
        # Цвет и выравнивание пузыря
        if speaker == "Вы":
            color = "#667eea"
            align = QtCore.Qt.AlignmentFlag.AlignRight
        elif speaker == "Система":
            color = "#48bb78"
            align = QtCore.Qt.AlignmentFlag.AlignCenter
        else:  # Ассистент
            color = "#764ba2"
            align = QtCore.Qt.AlignmentFlag.AlignLeft
        
        # Применяем стили на основе темы и liquid_glass
        if theme == "dark":
            # ═══ ТЁМНАЯ ТЕМА ═══
            if liquid_glass:
                # ТЁМНОЕ СТЕКЛО (прозрачное, с blur)
                bubble_bg = "rgba(35, 35, 40, 0.75)"
                bubble_border = "rgba(50, 50, 55, 0.6)"
                text_color = "#f0f0f0"
                btn_bg = "rgba(45, 45, 50, 0.55)"
                btn_bg_hover = "rgba(55, 55, 60, 0.65)"
                btn_border = "rgba(60, 60, 65, 0.4)"
                # Стекло не использует box-shadow
                box_shadow = "none"
            else:
                # ТЁМНЫЙ МАТОВЫЙ (solid, без прозрачности)
                # Добавляем легкую тень для depth
                bubble_bg = "rgb(43, 43, 48)"
                bubble_border = "rgba(60, 60, 65, 0.95)"  # Чуть темнее border
                text_color = "#f0f0f0"
                btn_bg = "rgb(38, 38, 42)"
                btn_bg_hover = "rgb(48, 48, 52)"
                btn_border = "rgba(58, 58, 62, 0.95)"
                # Subtle elevation с тенью
                box_shadow = "0 2px 8px rgba(0, 0, 0, 0.3)"
        else:
            # ═══ СВЕТЛАЯ ТЕМА ═══
            if liquid_glass:
                # СВЕТЛОЕ СТЕКЛО (прозрачное, с blur)
                bubble_bg = "rgba(255, 255, 255, 0.45)"
                bubble_border = "rgba(255, 255, 255, 0.65)"
                text_color = "#1a202c"
                btn_bg = "rgba(255, 255, 255, 0.55)"
                btn_bg_hover = "rgba(255, 255, 255, 0.75)"
                btn_border = "rgba(255, 255, 255, 0.72)"
                # Стекло не использует box-shadow
                box_shadow = "none"
            else:
                # СВЕТЛЫЙ МАТОВЫЙ (solid, без прозрачности)
                # Добавляем легкую тень для depth
                bubble_bg = "rgb(242, 242, 245)"
                bubble_border = "rgba(200, 200, 205, 0.95)"  # Чуть темнее border
                text_color = "#1a1a1a"
                btn_bg = "rgb(235, 235, 240)"
                btn_bg_hover = "rgb(225, 225, 230)"
                btn_border = "rgba(200, 200, 205, 0.95)"
                # Subtle elevation с тенью
                box_shadow = "0 2px 8px rgba(0, 0, 0, 0.15)"
        
        # Сохраняем стили для использования в кнопках и обновлениях
        self.bubble_bg = bubble_bg
        self.bubble_border = bubble_border
        self.box_shadow = box_shadow
        self.btn_bg = btn_bg
        self.btn_bg_hover = btn_bg_hover
        self.btn_border = btn_border
        self.text_color = text_color
        
        # Определяем цвет иконок в зависимости от liquid_glass и темы
        if liquid_glass:
            if theme == "dark":
                self.icon_color = "#a0a0b0"
            else:
                self.icon_color = "#5a6aaa"
            self.hover_border_color = "rgba(102, 126, 234, 0.40)"
            self.pressed_border_color = "rgba(102, 126, 234, 0.55)"
        else:
            if theme == "dark":
                self.icon_color = "#a0a0b0"
            else:
                self.icon_color = "#5a6aaa"
            self.hover_border_color = btn_border
            self.pressed_border_color = btn_border

        # краткость текста
        short = is_short_text(text)

        # Фиксированные размеры кнопок
        btn_size = 36
        emoji_size = 15
        btn_radius = btn_size // 2

        # главный layout
        main_layout = QtWidgets.QHBoxLayout(self)
        # Для симметрии: сообщения пользователя сдвигаем вправо, ИИ влево
        if align == QtCore.Qt.AlignmentFlag.AlignRight:
            # Сообщения пользователя - ближе к правому краю
            main_layout.setContentsMargins(80, 8, 6, 8)
        elif align == QtCore.Qt.AlignmentFlag.AlignLeft:
            # Сообщения ИИ - ближе к левому краю
            main_layout.setContentsMargins(6, 8, 80, 8)
        else:
            # Системные сообщения - по центру сверху с равными отступами
            main_layout.setContentsMargins(80, 8, 80, 8)
        main_layout.setSpacing(6)
        if align == QtCore.Qt.AlignmentFlag.AlignRight:
            main_layout.addStretch()
        elif speaker == "Система":
            # ✅ Для системных сообщений - центрируем пузырь
            main_layout.addStretch()

        # вертикальный столбик: метка времени (если есть) + пузырь + панель кнопок (вне пузыря)
        col_widget = QtWidgets.QWidget()
        # ✅ Minimum по вертикали - НЕ позволяет сжимать содержимое
        col_widget.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.Preferred,
            QtWidgets.QSizePolicy.Policy.Minimum
        )
        col_layout = QtWidgets.QVBoxLayout(col_widget)
        col_layout.setContentsMargins(0, 0, 0, 0)
        col_layout.setSpacing(4)
        
        # Метка времени обдумывания (только для ИИ, если thinking_time > 0)
        if speaker != "Вы" and speaker != "Система" and thinking_time > 0:
            time_label = QtWidgets.QLabel(f"⏱ думал ~{thinking_time:.1f} с")
            time_label.setStyleSheet("""
                QLabel {
                    color: rgba(90, 106, 170, 0.75);
                    font-size: 11px;
                    font-style: italic;
                    padding: 2px 8px;
                    background: transparent;
                }
            """)
            time_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft)
            col_layout.addWidget(time_label)

        # пузырь сообщения
        message_container = QtWidgets.QWidget()
        message_container.setObjectName("messageContainer")
        message_container.setMaximumWidth(900)
        message_container.setMinimumWidth(200)
        # ✅ Minimum по вертикали - bubble НЕ сжимается ниже размера текста
        message_container.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.Preferred,
            QtWidgets.QSizePolicy.Policy.Minimum
        )
        message_container.setStyleSheet(f"""
            #messageContainer {{
                background-color: {self.bubble_bg};
                border: 1px solid {self.bubble_border};
                border-radius: 24px;
                padding: 20px 26px;
            }}
        """)
        
        # Сохраняем ссылку для обновления стилей
        self.message_container = message_container
        
        container_layout = QtWidgets.QVBoxLayout(message_container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(4)  # Уменьшено с 6 до 4 для компактности пузыря

        # ─── Файловые бейджи (только для сообщений пользователя с прикреплёнными файлами) ───
        # ═══════════════════════════════════════════════════════════════════
        # ОТОБРАЖЕНИЕ ПРИКРЕПЛЕННЫХ ФАЙЛОВ (ВЫШЕ ПУЗЫРЯ, НЕ ВНУТРИ)
        # ═══════════════════════════════════════════════════════════════════
        if speaker == "Вы" and attached_files and len(attached_files) > 0:
            # Создаём контейнер для файлов ОТДЕЛЬНО от пузыря
            files_container = QtWidgets.QWidget()
            
            # Используем FlowLayout для красивого размещения файлов
            # Если файлов много - они автоматически перенесутся на новую строку
            files_layout = QtWidgets.QHBoxLayout(files_container)
            files_layout.setContentsMargins(0, 0, 0, 8)  # Отступ снизу до пузыря
            files_layout.setSpacing(8)
            files_layout.addStretch()  # Выравнивание справа для сообщений пользователя
            
            # Создаём вложенный контейнер для файлов с переносом
            files_wrapper = QtWidgets.QWidget()
            files_grid = QtWidgets.QGridLayout(files_wrapper)
            files_grid.setSpacing(6)
            files_grid.setContentsMargins(0, 0, 0, 0)
            
            # Показываем бейдж для каждого файла (максимум 3 в строке)
            for idx, file_name in enumerate(attached_files):
                row = idx // 3  # Строка
                col = idx % 3   # Столбец
                
                file_ext = os.path.splitext(file_name)[1].lower()
                if file_ext in ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp']:
                    file_emoji = "🖼️"
                else:
                    file_emoji = "📎"
                display_name = file_name if len(file_name) <= 30 else file_name[:27] + "…"
                # ═══════════════════════════════════════════════════════════════
                # КЛИКАБЕЛЬНАЯ КНОПКА вместо обычного Label
                # ═══════════════════════════════════════════════════════════════
                file_badge = QtWidgets.QPushButton(f"{file_emoji} {display_name}")
                file_badge.setFont(QtGui.QFont("Inter", 11))
                file_badge.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
                file_badge.setStyleSheet(f"""
                    QPushButton {{
                        color: rgba(102, 126, 234, 1.0);
                        background: rgba(102, 126, 234, 0.12);
                        border: 1px solid rgba(102, 126, 234, 0.28);
                        border-radius: 10px;
                        padding: 4px 10px;
                        text-align: left;
                    }}
                    QPushButton:hover {{
                        background: rgba(102, 126, 234, 0.20);
                        border: 1px solid rgba(102, 126, 234, 0.40);
                    }}
                    QPushButton:pressed {{
                        background: rgba(102, 126, 234, 0.28);
                    }}
                """)
                
                # Сохраняем file_name как атрибут кнопки для открытия
                file_badge.setProperty("file_name", file_name)
                file_badge.clicked.connect(lambda checked=False, fn=file_name: self.open_attached_file(fn))
                
                files_grid.addWidget(file_badge, row, col)
            
            files_layout.addWidget(files_wrapper)
            
            # Добавляем контейнер файлов в главный layout (ВЫШЕ пузыря)
            col_layout.addWidget(files_container, alignment=QtCore.Qt.AlignmentFlag.AlignRight)

        message_label = QtWidgets.QLabel()
        message_label.setWordWrap(True)
        message_label.setTextInteractionFlags(
            QtCore.Qt.TextInteractionFlag.TextSelectableByMouse |
            QtCore.Qt.TextInteractionFlag.TextSelectableByKeyboard
        )
        # Ограничиваем максимальную ширину текста
        message_label.setMaximumWidth(850)
        # ✅ Minimum по вертикали - текст НЕ сжимается ниже своего размера
        message_label.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.Expanding,
            QtWidgets.QSizePolicy.Policy.Minimum
        )
        
        font = QtGui.QFont("Inter", 18)
        message_label.setFont(font)
        message_label.setStyleSheet(f"""
            QLabel {{
                color: {self.text_color};
                padding: 8px;
                line-height: 1.6;
                word-wrap: break-word;
            }}
        """)
        
        # Сохраняем ссылку для обновления стилей
        self.message_label = message_label
        
        # Применяем форматирование markdown и математических символов
        formatted_text = format_text_with_markdown_and_math(text)
        display_text = f"<b style='color:{color};'>{speaker}:</b><br>{formatted_text}"
        message_label.setText(display_text)
        message_label.setTextFormat(QtCore.Qt.TextFormat.RichText)
        
        # ✅ MessageWidget только обновляет себя, БЕЗ управления родителем
        # Layout автоматически пересчитает размеры после добавления виджета

        # Центрируем текст если его мало
        if short:
            message_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)

        container_layout.addWidget(message_label)


        # Добавляем контейнер с правильным выравниванием
        if align == QtCore.Qt.AlignmentFlag.AlignCenter:
            # Система - строго по центру
            col_layout.addWidget(message_container, alignment=QtCore.Qt.AlignmentFlag.AlignCenter)
        elif align == QtCore.Qt.AlignmentFlag.AlignLeft:
            # AI - слева
            col_layout.addWidget(message_container, alignment=QtCore.Qt.AlignmentFlag.AlignLeft)
        else:
            # Пользователь - справа
            col_layout.addWidget(message_container, alignment=QtCore.Qt.AlignmentFlag.AlignRight)

        # Решаем сторону для панели кнопок
        if speaker == "Вы":
            controls_side = "right"
        elif speaker == "Система":
            controls_side = "center"  # ✅ Системные сообщения - кнопки по центру
        else:
            controls_side = "left"

        # панель кнопок (вне пузыря)
        controls_widget = QtWidgets.QWidget()
        controls_layout = QtWidgets.QHBoxLayout(controls_widget)
        controls_layout.setSpacing(10)
        bubble_padding = 18

        if controls_side == "left":
            controls_layout.setContentsMargins(bubble_padding, 0, 0, 6)
        elif controls_side == "right":
            controls_layout.setContentsMargins(0, 0, bubble_padding, 6)
        else:
            controls_layout.setContentsMargins(0, 0, 0, 6)

        # Кнопка копирования
        copy_btn = QtWidgets.QPushButton()
        copy_btn.setText("📋")
        copy_btn.setToolTip("Копировать")
        copy_btn.setFixedSize(btn_size, btn_size)
        copy_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        copy_btn.clicked.connect(self.copy_text)
        copy_btn.setVisible(add_controls)
        copy_btn.setObjectName("floatingControl")
        copy_btn.setStyleSheet(f"""
            QPushButton#floatingControl {{
                background: {self.btn_bg};
                color: {self.icon_color};
                border: 1px solid {self.btn_border};
                border-radius: {btn_radius}px;
                font-size: {emoji_size}px;
            }}
            QPushButton#floatingControl:hover {{ 
                background: {self.btn_bg_hover};
                border: 1px solid {self.hover_border_color};
            }}
            QPushButton#floatingControl:pressed {{ 
                background: {self.btn_bg_hover};
                border: 1px solid {self.pressed_border_color};
            }}
        """)
        self.copy_button = copy_btn  # Сохраняем ссылку для анимации
        controls_layout.addWidget(copy_btn, alignment=QtCore.Qt.AlignmentFlag.AlignVCenter)
        # Кнопка редактирования (только для пользователя)
        if speaker == "Вы":
            edit_btn = QtWidgets.QPushButton()
            edit_btn.setText("✏️")
            edit_btn.setToolTip("Редактировать")
            edit_btn.setFixedSize(btn_size, btn_size)
            edit_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
            edit_btn.clicked.connect(self.edit_message)
            edit_btn.setVisible(add_controls)
            edit_btn.setObjectName("floatingControl")
            edit_btn.setStyleSheet(f"""
                QPushButton#floatingControl {{
                    background: {self.btn_bg};
                    color: {self.icon_color};
                    border: 1px solid {self.btn_border};
                    border-radius: {btn_radius}px;
                    font-size: {emoji_size}px;
                }}
                QPushButton#floatingControl:hover {{ 
                    background: {self.btn_bg_hover};
                    border: 1px solid {self.hover_border_color};
                }}
                QPushButton#floatingControl:pressed {{ 
                    background: {self.btn_bg_hover};
                    border: 1px solid {self.pressed_border_color};
                }}
            """)
            controls_layout.addWidget(edit_btn, alignment=QtCore.Qt.AlignmentFlag.AlignVCenter)

        
        # Кнопка перегенерации (только для ассистента)
        if speaker != "Вы" and speaker != "Система" and add_controls:
            regenerate_btn = QtWidgets.QPushButton()
            regenerate_btn.setText("🔄")
            regenerate_btn.setToolTip("Перегенерировать ответ")
            regenerate_btn.setFixedSize(btn_size, btn_size)
            regenerate_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
            regenerate_btn.clicked.connect(self.regenerate_response)
            regenerate_btn.setVisible(add_controls)
            regenerate_btn.setObjectName("floatingControl")
            regenerate_btn.setStyleSheet(f"""
                QPushButton#floatingControl {{
                    background: {self.btn_bg};
                    color: {self.icon_color};
                    border: 1px solid {self.btn_border};
                    border-radius: {btn_radius}px;
                    font-size: {emoji_size}px;
                }}
                QPushButton#floatingControl:hover {{ 
                    background: {self.btn_bg_hover};
                    border: 1px solid {self.hover_border_color};
                }}
                QPushButton#floatingControl:pressed {{ 
                    background: {self.btn_bg_hover};
                    border: 1px solid {self.pressed_border_color};
                }}
            """)
            controls_layout.addWidget(regenerate_btn, alignment=QtCore.Qt.AlignmentFlag.AlignVCenter)
            
            # Сохраняем ссылку на кнопку регенерации для управления видимостью
            self.regenerate_button = regenerate_btn
        else:
            self.regenerate_button = None

        controls_widget.setVisible(add_controls)

        # Добавляем панель под пузырём
        if controls_side == "left":
            col_layout.addWidget(controls_widget, alignment=QtCore.Qt.AlignmentFlag.AlignLeft)
        elif controls_side == "right":
            col_layout.addWidget(controls_widget, alignment=QtCore.Qt.AlignmentFlag.AlignRight)
        else:
            col_layout.addWidget(controls_widget, alignment=QtCore.Qt.AlignmentFlag.AlignHCenter)
        
        # Вставляем в главный layout
        main_layout.addWidget(col_widget)
        if align == QtCore.Qt.AlignmentFlag.AlignLeft:
            main_layout.addStretch()
        elif speaker == "Система":
            # ✅ Для системных сообщений - добавляем stretch ПОСЛЕ для полного центрирования
            main_layout.addStretch()
        
        # ✅ ИДЕАЛЬНАЯ FADE-IN АНИМАЦИЯ: Плавное появление с оптимальными параметрами
        # Простая, надёжная, красивая - без конфликтов с layout
        if not IS_WINDOWS:
            # Создаём fade-in анимацию с идеальными параметрами
            self.fade_in_animation = QtCore.QPropertyAnimation(self.opacity_effect, b"opacity")
            self.fade_in_animation.setDuration(800)  # 800ms - очень плавная и приятная анимация
            self.fade_in_animation.setStartValue(0.0)
            self.fade_in_animation.setEndValue(1.0)
            # OutExpo - создаёт очень плавное замедление в конце
            # Сообщение появляется быстро в начале, затем плавно "дотягивается" до полной видимости
            self.fade_in_animation.setEasingCurve(QtCore.QEasingCurve.Type.OutExpo)
            
            # ✅ НЕ запускаем анимацию автоматически - она будет запущена из add_message_widget
            # после полного обновления layout
        else:
            # На Windows сразу показываем без анимации
            self.opacity_effect.setOpacity(1.0)

    @QtCore.pyqtSlot()
    def _start_appear_animation(self):
        """
        Запускает идеальную fade-in анимацию появления.
        
        Простая, надёжная, красивая анимация с оптимальными параметрами:
        - 800ms длительность для очень плавного появления
        - OutExpo кривая для естественного замедления
        
        После завершения анимации graphicsEffect удаляется чтобы
        избежать искажения цветов.
        
        Вызывается через QMetaObject.invokeMethod для синхронизации с layout.
        """
        if hasattr(self, 'fade_in_animation'):
            # Подключаем очистку эффекта после завершения анимации
            try:
                self.fade_in_animation.finished.disconnect()
            except:
                pass
            
            self.fade_in_animation.finished.connect(self._remove_graphics_effect_after_animation)
            self.fade_in_animation.start()
    
    def _remove_graphics_effect_after_animation(self):
        """
        Удаляет graphicsEffect после завершения анимации.
        Это предотвращает искажение цветов сообщений.
        """
        try:
            # Удаляем graphicsEffect чтобы избежать искажения цветов
            self.setGraphicsEffect(None)
            # Убираем ссылки на анимации
            if hasattr(self, 'fade_in_animation'):
                delattr(self, 'fade_in_animation')
            if hasattr(self, 'opacity_effect'):
                delattr(self, 'opacity_effect')
        except Exception as e:
            # Игнорируем ошибки при очистке
            pass
    
    def _cleanup_graphics_effect(self):
        """
        Завершает анимацию появления - удаляет graphicsEffect.
        
        ВАЖНО: Удаляем graphicsEffect чтобы избежать искажения цветов!
        После анимации эффект больше не нужен.
        """
        try:
            # Удаляем graphicsEffect полностью
            self.setGraphicsEffect(None)
            # Очищаем ссылки
            if hasattr(self, 'opacity_effect'):
                delattr(self, 'opacity_effect')
        except RuntimeError:
            # Объект уже удалён - игнорируем
            pass

    def update_message_styles(self, theme: str, liquid_glass: bool):
        """
        Обновляет стили виджета при изменении настроек темы или liquid_glass.
        
        ВАЖНО: НЕ пересоздаёт виджет, только обновляет стили.
        Layout НЕ изменяется.
        
        Параметры:
        - theme: "light" или "dark"
        - liquid_glass: True/False
        """
        # Сохраняем новые настройки
        self.current_theme = theme
        self.current_liquid_glass = liquid_glass
        
        # Пересчитываем стили по той же логике что и в __init__
        if theme == "dark":
            if liquid_glass:
                # ТЁМНОЕ СТЕКЛО
                bubble_bg = "rgba(35, 35, 40, 0.75)"
                bubble_border = "rgba(50, 50, 55, 0.6)"
                text_color = "#f0f0f0"
                btn_bg = "rgba(45, 45, 50, 0.55)"
                btn_bg_hover = "rgba(55, 55, 60, 0.65)"
                btn_border = "rgba(60, 60, 65, 0.4)"
                icon_color = "#a0a0b0"
                hover_border_color = "rgba(102, 126, 234, 0.40)"
                pressed_border_color = "rgba(102, 126, 234, 0.55)"
            else:
                # ТЁМНЫЙ МАТОВЫЙ (с чуть темнее border для depth)
                bubble_bg = "rgb(43, 43, 48)"
                bubble_border = "rgba(60, 60, 65, 0.95)"
                text_color = "#f0f0f0"
                btn_bg = "rgb(38, 38, 42)"
                btn_bg_hover = "rgb(48, 48, 52)"
                btn_border = "rgba(58, 58, 62, 0.95)"
                icon_color = "#a0a0b0"
                hover_border_color = btn_border
                pressed_border_color = btn_border
        else:
            if liquid_glass:
                # СВЕТЛОЕ СТЕКЛО
                bubble_bg = "rgba(255, 255, 255, 0.45)"
                bubble_border = "rgba(255, 255, 255, 0.65)"
                text_color = "#1a202c"
                btn_bg = "rgba(255, 255, 255, 0.55)"
                btn_bg_hover = "rgba(255, 255, 255, 0.75)"
                btn_border = "rgba(255, 255, 255, 0.72)"
                icon_color = "#5a6aaa"
                hover_border_color = "rgba(102, 126, 234, 0.40)"
                pressed_border_color = "rgba(102, 126, 234, 0.55)"
            else:
                # СВЕТЛЫЙ МАТОВЫЙ (с чуть темнее border для depth)
                bubble_bg = "rgb(242, 242, 245)"
                bubble_border = "rgba(200, 200, 205, 0.95)"
                text_color = "#1a1a1a"
                btn_bg = "rgb(235, 235, 240)"
                btn_bg_hover = "rgb(225, 225, 230)"
                btn_border = "rgba(200, 200, 205, 0.95)"
                icon_color = "#5a6aaa"
                hover_border_color = btn_border
                pressed_border_color = btn_border
        
        # Сохраняем новые стили
        self.bubble_bg = bubble_bg
        self.bubble_border = bubble_border
        self.btn_bg = btn_bg
        self.btn_bg_hover = btn_bg_hover
        self.btn_border = btn_border
        self.text_color = text_color
        self.icon_color = icon_color
        self.hover_border_color = hover_border_color
        self.pressed_border_color = pressed_border_color
        
        # Применяем стили к message_container
        if hasattr(self, 'message_container') and self.message_container:
            self.message_container.setStyleSheet(f"""
                #messageContainer {{
                    background-color: {bubble_bg};
                    border: 1px solid {bubble_border};
                    border-radius: 24px;
                    padding: 20px 26px;
                }}
            """)
        
        # Применяем стили к message_label
        if hasattr(self, 'message_label') and self.message_label:
            self.message_label.setStyleSheet(f"""
                QLabel {{
                    color: {text_color};
                    padding: 8px;
                    line-height: 1.6;
                    word-wrap: break-word;
                }}
            """)
        
        # Обновляем стили кнопок (если они есть)
        btn_size = 36
        btn_radius = btn_size // 2
        emoji_size = 15
        
        button_style = f"""
            QPushButton#floatingControl {{
                background: {btn_bg};
                color: {icon_color};
                border: 1px solid {btn_border};
                border-radius: {btn_radius}px;
                font-size: {emoji_size}px;
            }}
            QPushButton#floatingControl:hover {{ 
                background: {btn_bg_hover};
                border: 1px solid {hover_border_color};
            }}
            QPushButton#floatingControl:pressed {{ 
                background: {btn_bg_hover};
                border: 1px solid {pressed_border_color};
            }}
        """
        
        # Применяем к кнопке копирования
        if hasattr(self, 'copy_button') and self.copy_button:
            self.copy_button.setStyleSheet(button_style)
        
        # Применяем к другим кнопкам если они есть
        # Находим все кнопки в виджете
        for button in self.findChildren(QtWidgets.QPushButton):
            if button.objectName() == "floatingControl":
                button.setStyleSheet(button_style)
        
        print(f"[MSG_UPDATE] Стили обновлены: theme={theme}, liquid_glass={liquid_glass}")


    def copy_text(self):
        clipboard = QtWidgets.QApplication.clipboard()
        clipboard.setText(self.text)
        
        # Простая анимация: меняем текст и цвет
        if self.copy_button:
            original_text = self.copy_button.text()
            original_style = self.copy_button.styleSheet()
            
            # Меняем на галочку с зеленым цветом
            self.copy_button.setText("✓")
            
            # Добавляем зеленый фон для индикации успеха
            success_style = original_style.replace(
                self.btn_bg, 
                "rgba(72, 187, 120, 0.3)"  # Зеленый полупрозрачный
            )
            self.copy_button.setStyleSheet(success_style)
            
            # Через 1.5 секунды возвращаем обратно
            QtCore.QTimer.singleShot(1500, lambda: self._restore_copy_button(original_text, original_style))
    
    def _restore_copy_button(self, original_text, original_style):
        """Восстановление оригинального вида кнопки"""
        if self.copy_button:
            self.copy_button.setText(original_text)
            self.copy_button.setStyleSheet(original_style)
    
    def fade_out_and_delete(self):
        """
        Плавное исчезновение виджета через прозрачность.
        
        ВАЖНО: Работает одинаково во всех темах (светлая/тёмная).
        Стиль темы НЕ влияет на механизм удаления.
        """
        # На Windows GraphicsOpacityEffect работает медленно - используем упрощённую анимацию
        if IS_WINDOWS:
            # Упрощённая анимация для Windows без GraphicsOpacityEffect
            try:
                # Просто удаляем без эффектов (на Windows могут быть проблемы с repaint)
                self.deleteLater()
            except Exception as e:
                print(f"[FADE_OUT] Ошибка удаления на Windows: {e}")
            return
        
        # Для macOS и Linux - полноценная анимация с opacity
        # Проверяем, существует ли opacity_effect
        if not hasattr(self, 'opacity_effect') or self.opacity_effect is None:
            # Если эффект удалён - создаём новый
            self.opacity_effect = QtWidgets.QGraphicsOpacityEffect(self)
            self.setGraphicsEffect(self.opacity_effect)
            self.opacity_effect.setOpacity(1.0)
        
        # Дополнительная проверка: проверяем что эффект не был удалён из C++
        try:
            # Пытаемся получить текущую прозрачность - если объект удалён, будет RuntimeError
            current_opacity = self.opacity_effect.opacity()
        except RuntimeError:
            # Объект был удалён на уровне C++ - создаём новый
            self.opacity_effect = QtWidgets.QGraphicsOpacityEffect(self)
            self.setGraphicsEffect(self.opacity_effect)
            self.opacity_effect.setOpacity(1.0)
        
        # ✅ ТОЛЬКО fade-out прозрачности, БЕЗ изменения высоты
        # Layout сам пересчитает позиции после удаления виджета
        # КРИТИЧНО: Анимация НЕ зависит от темы - работает одинаково везде
        self.fade_out_animation = QtCore.QPropertyAnimation(self.opacity_effect, b"opacity")
        self.fade_out_animation.setDuration(350)  # Плавная анимация
        self.fade_out_animation.setStartValue(1.0)
        self.fade_out_animation.setEndValue(0.0)
        self.fade_out_animation.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)  # Плавное замедление
        
        # Удаляем виджет после завершения fade-out
        def safe_delete():
            try:
                # Останавливаем анимацию перед удалением
                if hasattr(self, 'fade_out_animation') and self.fade_out_animation:
                    self.fade_out_animation.stop()
                    self.fade_out_animation = None
                # Удаляем эффект
                if self.graphicsEffect():
                    self.setGraphicsEffect(None)
                # Обнуляем ссылку на opacity_effect
                if hasattr(self, 'opacity_effect'):
                    self.opacity_effect = None
                # Удаляем виджет
                self.deleteLater()
                print("[FADE_OUT] Системное сообщение плавно удалено")
            except RuntimeError:
                # Объект уже удалён
                print("[FADE_OUT] Объект уже удалён (RuntimeError)")
                pass
            except Exception as e:
                print(f"[FADE_OUT] Неожиданная ошибка при удалении: {e}")
        
        self.fade_out_animation.finished.connect(safe_delete)
        self.fade_out_animation.start()
        
        print("[FADE_OUT] Запущена анимация fade-out (универсальная для всех тем)")


    def regenerate_response(self):
        """Перегенерировать ответ ассистента"""
        # Отправляем сигнал родительскому окну
        parent_window = self.window()
        if hasattr(parent_window, 'regenerate_last_response'):
            parent_window.regenerate_last_response()
    
    def edit_message(self):
        """Редактировать сообщение пользователя"""
        parent_window = self.window()
        if hasattr(parent_window, 'edit_last_message'):
            parent_window.edit_last_message(self.text)
    

# -------------------------
# Worker
# -------------------------

    def open_attached_file(self, file_name):
        """Открыть прикреплённый файл при клике (УЛУЧШЕНО: обработка пробелов в путях)"""
        print(f"[FILE_OPEN] Попытка открыть файл: {file_name}")
        
        # Пытаемся найти полный путь к файлу
        file_path = None
        
        # Проверяем main_window.attached_files
        if self.main_window and hasattr(self.main_window, 'attached_files'):
            for full_path in self.main_window.attached_files:
                if os.path.basename(full_path) == file_name:
                    file_path = full_path
                    break
        
        # Если не нашли, возможно это уже полный путь
        if not file_path:
            file_path = file_name
        
        # ИСПРАВЛЕНИЕ: Нормализуем путь для корректной работы с пробелами
        file_path = os.path.normpath(file_path)
        # Преобразуем в абсолютный путь
        file_path = os.path.abspath(file_path)
        
        print(f"[FILE_OPEN] Нормализованный путь: {file_path}")
        
        # Проверяем существование файла
        if not os.path.exists(file_path):
            print(f"[FILE_OPEN] ✗ Файл не найден: {file_path}")
            QtWidgets.QMessageBox.warning(
                self,
                "Файл не найден",
                f"Файл не найден:\n{file_path}",
                QtWidgets.QMessageBox.StandardButton.Ok
            )
            return
        
        # Открываем файл системным приложением
        print(f"[FILE_OPEN] ✓ Открываю файл: {file_path}")
        
        try:
            # ИСПРАВЛЕНИЕ: Используем абсолютные пути для надёжного открытия
            if sys.platform == 'darwin':  # macOS
                # Для macOS используем абсолютный путь
                subprocess.run(['open', file_path], check=True)
            elif sys.platform == 'win32':  # Windows
                # os.startfile автоматически обрабатывает пробелы
                os.startfile(file_path)
            else:  # Linux
                # Для Linux используем абсолютный путь
                subprocess.run(['xdg-open', file_path], check=True)
            
            print(f"[FILE_OPEN] ✅ Файл открыт успешно")
        except subprocess.CalledProcessError as e:
            print(f"[FILE_OPEN] ✗ Ошибка subprocess: {e}")
            QtWidgets.QMessageBox.warning(
                self,
                "Ошибка открытия",
                f"Не удалось открыть файл:\n{file_path}\n\nПопробуйте открыть файл вручную.",
                QtWidgets.QMessageBox.StandardButton.Ok
            )
        except Exception as e:
            print(f"[FILE_OPEN] ✗ Ошибка открытия: {e}")
            QtWidgets.QMessageBox.warning(
                self,
                "Ошибка открытия",
                f"Не удалось открыть файл:\n{e}",
                QtWidgets.QMessageBox.StandardButton.Ok
            )

class WorkerSignals(QtCore.QObject):
    finished = QtCore.pyqtSignal(str)

class AIWorker(QtCore.QRunnable):
    def __init__(self, user_message: str, current_language: str, deep_thinking: bool, use_search: bool, should_forget: bool = False, chat_manager=None, chat_id=None, file_paths: list = None, ai_mode: str = AI_MODE_FAST):
        super().__init__()
        self.user_message = user_message
        self.current_language = current_language
        self.deep_thinking = deep_thinking
        self.use_search = use_search
        self.should_forget = should_forget
        self.chat_manager = chat_manager
        self.chat_id = chat_id
        self.file_paths = file_paths if file_paths else []
        self.ai_mode = ai_mode  # Добавляем режим AI
        self.signals = WorkerSignals()

    @QtCore.pyqtSlot()
    def run(self):
        try:
            response = get_ai_response(
                self.user_message,
                self.current_language,
                self.deep_thinking,
                self.use_search,
                self.should_forget,
                self.chat_manager,
                self.chat_id,
                self.file_paths,
                self.ai_mode  # Передаём режим AI
            )
            # ✅ ИСПРАВЛЕНИЕ: Безопасный emit - проверяем что signals ещё существует
            if hasattr(self, 'signals') and self.signals is not None:
                try:
                    self.signals.finished.emit(response)
                except RuntimeError:
                    # Signals уже удалён - игнорируем
                    pass
        except Exception as e:
            # ✅ Безопасный emit для ошибки
            if hasattr(self, 'signals') and self.signals is not None:
                try:
                    self.signals.finished.emit(f"[Ошибка] {e}")
                except RuntimeError:
                    pass

# -------------------------
# Main Window
# -------------------------

# ═══════════════════════════════════════════════════════════════════════════
# НОВЫЙ КОМПОНЕНТ 1: SCROLL TO BOTTOM BUTTON
# Floating overlay кнопка "⬇ вниз" - НЕ участвует в layout
# ═══════════════════════════════════════════════════════════════════════════

class ScrollToBottomButton(QtWidgets.QPushButton):
    """
    Floating overlay кнопка "⬇ вниз" для скроллинга к низу.
    
    КРИТИЧЕСКИЕ ПРАВИЛА:
    - НЕ участвует в layout сообщений
    - НЕ вызывает автоскролл
    - Только индикатор наличия непрочитанных сообщений внизу
    - Позиция: overlay поверх scroll_area
    """
    
    def __init__(self, parent=None):
        super().__init__("⬇", parent)
        
        self.setObjectName("scrollToBottomBtn")
        self.setFixedSize(50, 50)
        self.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        
        # Изначально скрыта
        self.hide()
        
        # Применяем стиль по умолчанию (светлая тема + glass)
        # На этом этапе добавится тень через graphicsEffect
        self.apply_theme_styles(theme="light", liquid_glass=True)
        
        # ═══════════════════════════════════════════════════════════════
        # ПЛАВНОЕ ПОЯВЛЕНИЕ/ИСЧЕЗНОВЕНИЕ через opacity
        # ═══════════════════════════════════════════════════════════════
        # ВАЖНО: Создаём ПОСЛЕ apply_theme_styles, но используем CSS drop-shadow вместо graphicsEffect
        # так как graphicsEffect можно установить только один
        
        # Создаём эффект прозрачности (заменит тень)
        self.opacity_effect = QtWidgets.QGraphicsOpacityEffect(self)
        self.setGraphicsEffect(self.opacity_effect)
        self.opacity_effect.setOpacity(0.0)  # Изначально невидима
        
        # Анимация fade in/out
        self.fade_animation = QtCore.QPropertyAnimation(self.opacity_effect, b"opacity")
        self.fade_animation.setDuration(400)  # 400ms - более плавная и приятная анимация
        self.fade_animation.setEasingCurve(QtCore.QEasingCurve.Type.OutExpo)  # Более естественная кривая
        
        # Флаг текущего состояния видимости (для предотвращения лишних анимаций)
        self._is_visible_animated = False
    
    def apply_theme_styles(self, theme: str = "light", liquid_glass: bool = True):
        """
        Применить стили в зависимости от темы и liquid glass.
        
        Вызывается при изменении настроек темы.
        """
        if theme == "dark":
            if liquid_glass:
                # ТЁМНАЯ ТЕМА + СТЕКЛО - тёмное полупрозрачное стекло
                bg_start = "rgba(35, 35, 40, 0.75)"
                bg_end = "rgba(28, 28, 32, 0.75)"
                border = "rgba(50, 50, 55, 0.6)"
                hover_bg_start = "rgba(45, 45, 50, 0.85)"
                hover_bg_end = "rgba(38, 38, 42, 0.85)"
                hover_border = "rgba(139, 92, 246, 0.5)"
                text_color = "#e6e6e6"
                shadow_color = "rgba(0, 0, 0, 0.7)"
            else:
                # ТЁМНАЯ ТЕМА БЕЗ СТЕКЛА - матовый тёмный
                bg_start = "rgb(43, 43, 48)"
                bg_end = "rgb(38, 38, 42)"
                border = "rgba(60, 60, 65, 0.95)"
                hover_bg_start = "rgb(53, 53, 58)"
                hover_bg_end = "rgb(48, 48, 52)"
                hover_border = "rgba(139, 92, 246, 0.7)"
                text_color = "#f0f0f0"
                shadow_color = "rgba(0, 0, 0, 0.5)"
        else:
            if liquid_glass:
                # СВЕТЛАЯ ТЕМА + СТЕКЛО - светлое полупрозрачное стекло
                bg_start = "rgba(255, 255, 255, 0.75)"
                bg_end = "rgba(255, 255, 255, 0.65)"
                border = "rgba(255, 255, 255, 0.85)"
                hover_bg_start = "rgba(255, 255, 255, 0.90)"
                hover_bg_end = "rgba(255, 255, 255, 0.80)"
                hover_border = "rgba(102, 126, 234, 0.65)"
                text_color = "#2d3748"
                shadow_color = "rgba(0, 0, 0, 0.15)"
            else:
                # СВЕТЛАЯ ТЕМА БЕЗ СТЕКЛА - матовый светлый
                bg_start = "rgb(242, 242, 245)"
                bg_end = "rgb(235, 235, 240)"
                border = "rgba(210, 210, 215, 0.95)"
                hover_bg_start = "rgb(235, 235, 240)"
                hover_bg_end = "rgb(225, 225, 230)"
                hover_border = "rgba(102, 126, 234, 0.8)"
                text_color = "#1a1a1a"
                shadow_color = "rgba(0, 0, 0, 0.2)"
        
        self.setStyleSheet(f"""
            #scrollToBottomBtn {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {bg_start},
                    stop:1 {bg_end});
                border: 1px solid {border};
                border-radius: 25px;
                color: {text_color};
                font-size: 20px;
                font-weight: bold;
            }}
            #scrollToBottomBtn:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {hover_bg_start},
                    stop:1 {hover_bg_end});
                border: 1px solid {hover_border};
            }}
        """)
        # Тень НЕ добавляем, так как используем opacity_effect для анимации
    
    def update_position(self, parent_width, parent_height):
        """
        Обновить позицию кнопки (центр снизу).
        НЕ вызывается автоматически - только вручную при resize.
        """
        x = (parent_width - self.width()) // 2
        y = parent_height - self.height() - 90  # 90px от низа (не налезает на input bar)
        self.move(x, y)
        self.raise_()
    
    def smooth_show(self):
        """
        Плавное появление кнопки через fade in анимацию.
        
        ОПТИМИЗАЦИЯ: Проверяем текущее состояние чтобы не запускать
        лишние анимации если кнопка уже видна.
        """
        # Если кнопка уже показана - ничего не делаем
        if self._is_visible_animated:
            return
        
        # Показываем виджет (но он невидим из-за opacity=0)
        if not self.isVisible():
            self.show()
        
        # Запускаем fade in анимацию
        self.fade_animation.stop()
        self.fade_animation.setStartValue(self.opacity_effect.opacity())
        self.fade_animation.setEndValue(1.0)
        self.fade_animation.start()
        
        self._is_visible_animated = True
    
    def smooth_hide(self):
        """
        Плавное исчезновение кнопки через fade out анимацию.
        
        ОПТИМИЗАЦИЯ: Проверяем текущее состояние чтобы не запускать
        лишние анимации если кнопка уже скрыта.
        """
        # Если кнопка уже скрыта - ничего не делаем
        if not self._is_visible_animated:
            return
        
        # Запускаем fade out анимацию
        self.fade_animation.stop()
        self.fade_animation.setStartValue(self.opacity_effect.opacity())
        self.fade_animation.setEndValue(0.0)
        
        # После завершения анимации скрываем виджет
        def on_fade_out_finished():
            if self.opacity_effect.opacity() == 0.0:
                self.hide()
        
        # Отключаем старый обработчик если был
        try:
            self.fade_animation.finished.disconnect()
        except:
            pass
        
        self.fade_animation.finished.connect(on_fade_out_finished)
        self.fade_animation.start()
        
        self._is_visible_animated = False


# ═══════════════════════════════════════════════════════════════════════════
# НОВЫЙ КОМПОНЕНТ 2: SETTINGS VIEW
# Экран настроек - замена chat_area
# ═══════════════════════════════════════════════════════════════════════════

class SettingsView(QtWidgets.QWidget):
    """
    Экран настроек приложения.
    
    КРИТИЧЕСКИЕ ПРАВИЛА:
    - НЕ влияет на messages_layout
    - НЕ создаёт новое окно
    - Заменяет содержимое chat_container через QStackedWidget
    - Sidebar и input bar остаются видимыми
    """
    
    # Сигналы
    settings_applied = QtCore.pyqtSignal(dict)
    close_requested = QtCore.pyqtSignal()
    delete_all_chats_requested = QtCore.pyqtSignal()  # Новый сигнал для удаления всех чатов
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        self.setObjectName("settingsView")
        
        # Текущие настройки (сохранённые и применённые)
        self.current_settings = {
            "theme": "light",
            "liquid_glass": True,
        }
        
        # Временные настройки (pending - до нажатия "Применить")
        self.pending_settings = {
            "theme": "light",
            "liquid_glass": True,
        }
        
        self.init_ui()
        self.load_settings()
    
    def init_ui(self):
        """Инициализация UI"""
        
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setContentsMargins(50, 50, 50, 50)
        main_layout.setSpacing(35)
        
        # Заголовок
        title = QtWidgets.QLabel("⚙️ Настройки")
        title.setObjectName("settingsTitle")
        title.setFont(QtGui.QFont("Inter", 32, QtGui.QFont.Weight.Bold))
        title.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        main_layout.addWidget(title)
        
        main_layout.addSpacing(25)
        
        # Контейнер настроек
        settings_container = QtWidgets.QWidget()
        settings_container.setObjectName("settingsContainer")
        settings_layout = QtWidgets.QVBoxLayout(settings_container)
        settings_layout.setSpacing(30)
        
        # ═══════════════════════════════════════════════
        # НАСТРОЙКА 1: Тема
        # ═══════════════════════════════════════════════
        theme_group = self.create_setting_group(
            "Тема оформления",
            "Переключение между светлой и тёмной темой"
        )
        
        theme_layout = QtWidgets.QHBoxLayout()
        theme_layout.setSpacing(15)
        
        self.theme_light_btn = QtWidgets.QPushButton("☀️ Светлая")
        self.theme_light_btn.setObjectName("themeLightBtn")
        self.theme_light_btn.setCheckable(True)
        self.theme_light_btn.setChecked(True)
        self.theme_light_btn.clicked.connect(lambda: self.set_theme("light"))
        
        self.theme_dark_btn = QtWidgets.QPushButton("🌙 Тёмная")
        self.theme_dark_btn.setObjectName("themeDarkBtn")
        self.theme_dark_btn.setCheckable(True)
        self.theme_dark_btn.clicked.connect(lambda: self.set_theme("dark"))
        
        theme_layout.addWidget(self.theme_light_btn)
        theme_layout.addWidget(self.theme_dark_btn)
        
        theme_group.layout().addLayout(theme_layout)
        settings_layout.addWidget(theme_group)
        
        # ═══════════════════════════════════════════════
        # НАСТРОЙКА 2: Liquid Glass - УДАЛЕНО
        # Liquid Glass теперь фиксированный, не редактируется
        # ═══════════════════════════════════════════════
        
        # ═══════════════════════════════════════════════
        # ОПАСНАЯ ЗОНА: Удаление всех чатов
        # ═══════════════════════════════════════════════
        danger_group = self.create_setting_group(
            "⚠️ Опасная зона",
            "Необратимые действия. Будьте осторожны!"
        )
        
        delete_all_layout = QtWidgets.QVBoxLayout()
        delete_all_layout.setSpacing(10)
        
        self.delete_all_chats_btn = QtWidgets.QPushButton("🗑️ Удалить все чаты")
        self.delete_all_chats_btn.setObjectName("deleteAllChatsBtn")
        self.delete_all_chats_btn.setFont(QtGui.QFont("Inter", 13, QtGui.QFont.Weight.Medium))
        self.delete_all_chats_btn.setMinimumHeight(45)
        self.delete_all_chats_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.delete_all_chats_btn.clicked.connect(self.request_delete_all_chats)
        
        delete_all_layout.addWidget(self.delete_all_chats_btn)
        
        danger_group.layout().addLayout(delete_all_layout)
        settings_layout.addWidget(danger_group)
        
        main_layout.addWidget(settings_container)
        main_layout.addStretch()
        
        # ═══════════════════════════════════════════════
        # КНОПКИ ДЕЙСТВИЙ
        # ═══════════════════════════════════════════════
        actions_layout = QtWidgets.QHBoxLayout()
        actions_layout.setSpacing(15)
        
        back_btn = QtWidgets.QPushButton("← Назад к чату")
        back_btn.setObjectName("settingsBackBtn")
        back_btn.setFont(QtGui.QFont("Inter", 14, QtGui.QFont.Weight.Medium))
        back_btn.setMinimumHeight(50)
        back_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        back_btn.clicked.connect(self.close_requested.emit)
        
        apply_btn = QtWidgets.QPushButton("✓ Применить")
        apply_btn.setObjectName("settingsApplyBtn")
        apply_btn.setFont(QtGui.QFont("Inter", 14, QtGui.QFont.Weight.Bold))
        apply_btn.setMinimumHeight(50)
        apply_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        apply_btn.clicked.connect(self.apply_settings)
        
        actions_layout.addWidget(back_btn)
        actions_layout.addWidget(apply_btn)
        
        main_layout.addLayout(actions_layout)
        
        self.apply_settings_styles()
    
    def create_setting_group(self, title: str, description: str) -> QtWidgets.QGroupBox:
        """Создать группу настроек"""
        
        group = QtWidgets.QGroupBox()
        group.setObjectName("settingGroup")
        
        layout = QtWidgets.QVBoxLayout(group)
        layout.setSpacing(12)
        
        title_label = QtWidgets.QLabel(title)
        title_label.setFont(QtGui.QFont("Inter", 18, QtGui.QFont.Weight.Bold))
        layout.addWidget(title_label)
        
        desc_label = QtWidgets.QLabel(description)
        desc_label.setObjectName("descLabel")
        desc_label.setFont(QtGui.QFont("Inter", 13))
        desc_label.setStyleSheet("color: #475569;")
        layout.addWidget(desc_label)
        
        return group
    
    def set_theme(self, theme: str):
        """
        Установить тему ВИЗУАЛЬНО (pending state).
        
        ВАЖНО: НЕ применяет стили к приложению!
        Только меняет визуальное состояние кнопок выбора.
        Реальное применение происходит при нажатии "Применить".
        """
        # Сохраняем в pending settings
        self.pending_settings["theme"] = theme
        
        # Обновляем ТОЛЬКО визуальное состояние кнопок
        self.theme_light_btn.setChecked(theme == "light")
        self.theme_dark_btn.setChecked(theme == "dark")
        
        # НЕ применяем стили! Только обновляем кнопки
        print(f"[SETTINGS] Выбрана тема: {theme} (pending, не применено)")
    
    def set_liquid_glass(self, enabled: bool):
        """
        Liquid Glass теперь фиксированный - метод сохранен для совместимости.
        НЕ ИСПОЛЬЗУЕТСЯ.
        """
        # Заглушка - liquid_glass всегда True
        pass
    
    def load_settings(self):
        """Загрузить сохранённые настройки"""
        try:
            if os.path.exists("app_settings.json"):
                with open("app_settings.json", "r", encoding="utf-8") as f:
                    saved = json.load(f)
                    self.current_settings.update(saved)
                    # Копируем в pending settings
                    self.pending_settings.update(saved)
        except Exception as e:
            print(f"[SETTINGS] Ошибка загрузки: {e}")
        
        # LIQUID GLASS ФИКСИРОВАН - ВСЕГДА TRUE
        self.current_settings["liquid_glass"] = True
        self.pending_settings["liquid_glass"] = True
        
        # Устанавливаем визуальное состояние кнопок согласно current settings
        theme = self.current_settings.get("theme", "light")
        
        self.theme_light_btn.setChecked(theme == "light")
        self.theme_dark_btn.setChecked(theme == "dark")
        
        # Применяем стили к самому окну настроек
        self.apply_settings_styles()
    
    def save_settings(self):
        """Сохранить настройки"""
        try:
            with open("app_settings.json", "w", encoding="utf-8") as f:
                json.dump(self.current_settings, f, indent=2)
            print("[SETTINGS] ✓ Настройки сохранены")
        except Exception as e:
            print(f"[SETTINGS] ✗ Ошибка сохранения: {e}")
    
    def request_delete_all_chats(self):
        """Запросить подтверждение удаления всех чатов"""
        print("[SETTINGS] Запрос на удаление всех чатов")
        self.delete_all_chats_requested.emit()
    
    def update_delete_all_btn_state(self, has_chats_with_messages: bool):
        """
        Обновить состояние кнопки 'Удалить все чаты'.
        Отключает кнопку если нет ни одного чата с сообщениями.
        """
        if hasattr(self, 'delete_all_chats_btn'):
            self.delete_all_chats_btn.setEnabled(has_chats_with_messages)
            if has_chats_with_messages:
                self.delete_all_chats_btn.setCursor(
                    QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
                self.delete_all_chats_btn.setToolTip("")
            else:
                self.delete_all_chats_btn.setCursor(
                    QtGui.QCursor(QtCore.Qt.CursorShape.ForbiddenCursor))
                self.delete_all_chats_btn.setToolTip("Нет чатов для удаления")
    
    def apply_settings(self):
        """
        Применить настройки к приложению.
        
        ВАЖНО: Это единственное место где pending_settings копируется в current_settings
        и отправляется сигнал settings_applied.
        """
        # Копируем pending settings в current settings
        self.current_settings.update(self.pending_settings)
        
        # Сохраняем в файл
        self.save_settings()
        
        # Отправляем сигнал главному окну для применения стилей
        self.settings_applied.emit(self.current_settings)
        
        print(f"[SETTINGS] ✓ Настройки применены: {self.current_settings}")
        # НЕ закрываем настройки автоматически - пользователь сам решает когда вернуться
    
    def apply_settings_styles(self):
        """Применить стили с поддержкой тем"""
        
        # Определяем текущую тему из настроек
        theme = self.current_settings.get("theme", "light")
        liquid_glass = self.current_settings.get("liquid_glass", True)
        
        print(f"[SETTINGS_VIEW] apply_settings_styles: theme={theme}, liquid_glass={liquid_glass}")
        
        if theme == "dark":
            if liquid_glass:
                # ТЁМНАЯ ТЕМА + СТЕКЛО - тёмное стекло
                colors = {
                    "bg": "rgba(24, 24, 28, 0.65)",
                    "title": "#e6e6e6",
                    "group_bg": "rgba(30, 30, 35, 0.60)",
                    "group_border": "rgba(50, 50, 55, 0.5)",
                    "text": "#e6e6e6",
                    "desc": "#b0b0b0",
                    "btn_bg": "rgba(45, 45, 50, 0.50)",
                    "btn_border": "rgba(60, 60, 65, 0.40)",
                    "btn_text": "#b0b0b0",
                    "btn_checked_bg_start": "rgba(139, 92, 246, 0.70)",
                    "btn_checked_bg_end": "rgba(124, 58, 237, 0.70)",
                    "btn_checked_border": "rgba(139, 92, 246, 0.80)",
                    "btn_hover_bg": "rgba(55, 55, 60, 0.70)",
                    "btn_hover_border": "rgba(139, 92, 246, 0.40)",
                    "back_btn_bg": "rgba(30, 30, 35, 0.60)",
                    "back_btn_border": "rgba(50, 50, 55, 0.60)",
                    "back_btn_text": "#b0b0b0",
                    "apply_btn_start": "rgba(34, 197, 94, 0.70)",
                    "apply_btn_end": "rgba(22, 163, 74, 0.80)",
                    "apply_btn_border": "rgba(34, 197, 94, 0.80)",
                    
                    # Кнопка удаления всех чатов
                    "delete_all_btn_bg": "rgba(220, 85, 85, 0.15)",
                    "delete_all_btn_hover": "rgba(220, 85, 85, 0.25)",
                    "delete_all_btn_text": "#e89999",
                    "delete_all_btn_border": "rgba(220, 85, 85, 0.3)",
                    "delete_all_btn_disabled_bg": "rgba(60, 60, 65, 0.4)",
                    "delete_all_btn_disabled_border": "rgba(80, 80, 85, 0.4)",
                    "delete_all_btn_disabled_text": "rgba(120, 120, 125, 0.7)",
                }
            else:
                # ТЁМНАЯ ТЕМА БЕЗ СТЕКЛА - матовый тёмный
                colors = {
                    "bg": "rgb(28, 28, 31)",
                    "title": "#f0f0f0",
                    "group_bg": "rgb(32, 32, 36)",
                    "group_border": "rgba(55, 55, 60, 0.9)",
                    "text": "#f0f0f0",
                    "desc": "#c0c0c0",
                    "btn_bg": "rgb(48, 48, 52)",
                    "btn_border": "rgba(68, 68, 72, 0.95)",
                    "btn_text": "#c0c0c0",
                    "btn_checked_bg_start": "rgba(139, 92, 246, 1.0)",
                    "btn_checked_bg_end": "rgba(124, 58, 237, 1.0)",
                    "btn_checked_border": "rgba(139, 92, 246, 1.0)",
                    "btn_hover_bg": "rgb(58, 58, 62)",
                    "btn_hover_border": "rgba(139, 92, 246, 0.6)",
                    "back_btn_bg": "rgb(32, 32, 36)",
                    "back_btn_border": "rgba(55, 55, 60, 0.95)",
                    "back_btn_text": "#c0c0c0",
                    "apply_btn_start": "rgba(34, 197, 94, 1.0)",
                    "apply_btn_end": "rgba(22, 163, 74, 1.0)",
                    "apply_btn_border": "rgba(34, 197, 94, 1.0)",
                    
                    # Кнопка удаления всех чатов
                    "delete_all_btn_bg": "rgba(220, 85, 85, 0.15)",
                    "delete_all_btn_hover": "rgba(220, 85, 85, 0.25)",
                    "delete_all_btn_text": "#e89999",
                    "delete_all_btn_border": "rgba(220, 85, 85, 0.3)",
                    "delete_all_btn_disabled_bg": "rgba(60, 60, 65, 0.4)",
                    "delete_all_btn_disabled_border": "rgba(80, 80, 85, 0.4)",
                    "delete_all_btn_disabled_text": "rgba(120, 120, 125, 0.7)",
                }
        else:
            # СВЕТЛАЯ ТЕМА
            if liquid_glass:
                # СВЕТЛАЯ ТЕМА + СТЕКЛО
                colors = {
                    "bg": "rgba(255, 255, 255, 0.55)",
                    "title": "#222222",
                    "group_bg": "rgba(255, 255, 255, 0.75)",
                    "group_border": "rgba(255, 255, 255, 0.85)",
                    "text": "#222222",
                    "desc": "#5a5a5a",
                    "btn_bg": "rgba(255, 255, 255, 0.65)",
                    "btn_border": "rgba(203, 213, 225, 0.55)",
                    "btn_text": "#3a3a3a",
                    "btn_checked_bg_start": "rgba(102, 126, 234, 0.80)",
                    "btn_checked_bg_end": "rgba(118, 75, 162, 0.80)",
                    "btn_checked_border": "rgba(102, 126, 234, 0.90)",
                    "btn_hover_bg": "rgba(255, 255, 255, 0.85)",
                    "btn_hover_border": "rgba(102, 126, 234, 0.50)",
                    "back_btn_bg": "rgba(255, 255, 255, 0.75)",
                    "back_btn_border": "rgba(203, 213, 225, 0.75)",
                    "back_btn_text": "#3a3a3a",
                    "apply_btn_start": "rgba(34, 197, 94, 0.80)",
                    "apply_btn_end": "rgba(22, 163, 74, 0.90)",
                    "apply_btn_border": "rgba(34, 197, 94, 0.90)",
                    
                    # Кнопка удаления всех чатов
                    "delete_all_btn_bg": "rgba(220, 85, 85, 0.08)",
                    "delete_all_btn_hover": "rgba(220, 85, 85, 0.15)",
                    "delete_all_btn_text": "#c85555",
                    "delete_all_btn_border": "rgba(220, 85, 85, 0.2)",
                    "delete_all_btn_disabled_bg": "rgba(220, 220, 225, 0.5)",
                    "delete_all_btn_disabled_border": "rgba(200, 200, 205, 0.5)",
                    "delete_all_btn_disabled_text": "rgba(160, 160, 165, 0.8)",
                }
            else:
                # СВЕТЛАЯ ТЕМА БЕЗ СТЕКЛА - плоский
                colors = {
                    "bg": "rgb(246, 246, 248)",
                    "title": "#1a1a1a",
                    "group_bg": "rgb(252, 252, 254)",
                    "group_border": "rgba(210, 210, 215, 0.95)",
                    "text": "#1a1a1a",
                    "desc": "#4a4a4a",
                    "btn_bg": "rgb(242, 242, 245)",
                    "btn_border": "rgba(210, 210, 215, 0.95)",
                    "btn_text": "#2a2a2a",
                    "btn_checked_bg_start": "rgba(102, 126, 234, 1.0)",
                    "btn_checked_bg_end": "rgba(118, 75, 162, 1.0)",
                    "btn_checked_border": "rgba(102, 126, 234, 1.0)",
                    "btn_hover_bg": "rgb(235, 235, 240)",
                    "btn_hover_border": "rgba(102, 126, 234, 0.7)",
                    "back_btn_bg": "rgb(246, 246, 248)",
                    "back_btn_border": "rgba(210, 210, 215, 0.95)",
                    "back_btn_text": "#2a2a2a",
                    "apply_btn_start": "rgba(34, 197, 94, 1.0)",
                    "apply_btn_end": "rgba(22, 163, 74, 1.0)",
                    "apply_btn_border": "rgba(34, 197, 94, 1.0)",
                    
                    # Кнопка удаления всех чатов
                    "delete_all_btn_bg": "rgba(220, 85, 85, 0.08)",
                    "delete_all_btn_hover": "rgba(220, 85, 85, 0.15)",
                    "delete_all_btn_text": "#c85555",
                    "delete_all_btn_border": "rgba(220, 85, 85, 0.2)",
                    "delete_all_btn_disabled_bg": "rgba(220, 220, 225, 0.5)",
                    "delete_all_btn_disabled_border": "rgba(200, 200, 205, 0.5)",
                    "delete_all_btn_disabled_text": "rgba(160, 160, 165, 0.8)",
                }
        
        style = f"""
            #settingsView {{
                background: {colors["bg"]};
            }}
            
            #settingsTitle {{
                color: {colors["title"]};
                font-size: 32px;
            }}
            
            #settingGroup {{
                background: {colors["group_bg"]};
                border: 1px solid {colors["group_border"]};
                border-radius: 18px;
                padding: 24px;
            }}
            
            #settingGroup QLabel {{
                color: {colors["text"]};
            }}
            
            #settingGroup QLabel[objectName="descLabel"] {{
                color: {colors["desc"]};
            }}
            
            #themeLightBtn, #themeDarkBtn,
            #glassOnBtn, #glassOffBtn {{
                background: {colors["btn_bg"]};
                border: 2px solid {colors["btn_border"]};
                border-radius: 12px;
                padding: 16px 22px;
                font-size: 15px;
                font-weight: 600;
                color: {colors["btn_text"]};
                min-height: 50px;
            }}
            
            #themeLightBtn:checked, #themeDarkBtn:checked,
            #glassOnBtn:checked, #glassOffBtn:checked {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {colors["btn_checked_bg_start"]},
                    stop:1 {colors["btn_checked_bg_end"]});
                border: 2px solid {colors["btn_checked_border"]};
                color: white;
            }}
            
            #themeLightBtn:hover, #themeDarkBtn:hover,
            #glassOnBtn:hover, #glassOffBtn:hover {{
                background: {colors["btn_hover_bg"]};
                border: 2px solid {colors["btn_hover_border"]};
            }}
            
            #settingsBackBtn {{
                background: {colors["back_btn_bg"]};
                border: 2px solid {colors["back_btn_border"]};
                border-radius: 14px;
                color: {colors["back_btn_text"]};
            }}
            
            #settingsBackBtn:hover {{
                background: {colors["btn_hover_bg"]};
                border: 2px solid {colors["btn_hover_border"]};
            }}
            
            #settingsApplyBtn {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {colors["apply_btn_start"]},
                    stop:1 {colors["apply_btn_end"]});
                border: 2px solid {colors["apply_btn_border"]};
                border-radius: 14px;
                color: white;
            }}
            
            #settingsApplyBtn:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(34, 197, 94, 0.95),
                    stop:1 rgba(22, 163, 74, 1.0));
            }}
            
            #deleteAllChatsBtn {{
                background: {colors["delete_all_btn_bg"]};
                border: 2px solid {colors["delete_all_btn_border"]};
                border-radius: 14px;
                color: {colors["delete_all_btn_text"]};
                font-weight: 600;
            }}
            
            #deleteAllChatsBtn:hover {{
                background: {colors["delete_all_btn_hover"]};
            }}
            
            #deleteAllChatsBtn:disabled {{
                background: {colors["delete_all_btn_disabled_bg"]};
                border: 2px solid {colors["delete_all_btn_disabled_border"]};
                color: {colors["delete_all_btn_disabled_text"]};
                font-weight: 400;
            }}
        """
        
        self.setStyleSheet(style)
        print(f"[SETTINGS_VIEW] ✓ Стили применены")




class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        global CURRENT_LANGUAGE
        self.current_language = CURRENT_LANGUAGE
        self.deep_thinking = False
        self.use_search = False
        self.is_generating = False
        self.current_user_message = ""
        self.current_worker = None
        
        # ✅ ИСПРАВЛЕНИЕ: Список активных workers для предотвращения RuntimeError
        # WorkerSignals не должен удаляться пока worker работает
        self.active_workers = []  # Сильные ссылки на workers
        
        # Режим работы AI
        self.ai_mode = AI_MODE_FAST  # По умолчанию быстрый режим
        
        # Таймер обдумывания
        self.thinking_start_time = None
        self.thinking_elapsed_time = 0
        
        # Режим редактирования
        self.is_editing = False
        self.editing_message_text = ""
        
        # Прикреплённые файлы (до 5 файлов одновременно)
        self.attached_files = []
        
        # ═══════════════════════════════════════════════════════════════
        # СИСТЕМА ХРАНЕНИЯ ФАЙЛОВ ПО ЧАТАМ
        # ═══════════════════════════════════════════════════════════════
        # Директория для хранения файлов чатов
        self.chat_files_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "chat_files")
        if not os.path.exists(self.chat_files_dir):
            os.makedirs(self.chat_files_dir)
            print(f"[CHAT_FILES] ✓ Создана директория: {self.chat_files_dir}")
        else:
            print(f"[CHAT_FILES] ✓ Директория существует: {self.chat_files_dir}")
        
        
        # ═══════════════════════════════════════════════════════════════
        # DRAG-AND-DROP: Включаем поддержку перетаскивания файлов
        # ═══════════════════════════════════════════════════════════════
        self.setAcceptDrops(True)
        print("[DRAG-DROP] ✓ Поддержка перетаскивания файлов включена")
        
        
        # Менеджер чатов
        self.chat_manager = ChatManager()
        
        # Текущая тема и настройки интерфейса
        self.current_theme = "light"
        self.current_liquid_glass = True
        
        # ═══════════════════════════════════════════════════════════════
        # ЛОГИКА СТАРТОВОГО ЧАТА
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 1: Удаляем все старые ПУСТЫЕ чаты (без пользовательских сообщений)
        print("[STARTUP] Очистка старых пустых чатов...")
        self._cleanup_empty_chats_on_startup()
        
        # ШАГ 2: Создаём новый чат при запуске
        new_chat_id = self.chat_manager.create_chat("Новый чат")
        self.chat_manager.set_active_chat(new_chat_id)
        self.current_chat_id = new_chat_id
        
        # Помечаем этот чат как стартовый (пустой)
        self.startup_chat_id = new_chat_id
        self.startup_chat_has_messages = False
        print(f"[STARTUP] Создан новый стартовый чат ID={new_chat_id}")

        self.setWindowTitle(APP_TITLE)
        self.resize(1100, 850)

        icon_pixmap = create_app_icon()
        self.setWindowIcon(QtGui.QIcon(icon_pixmap))

        # ── Animated background widget (lives behind everything) ──
        self.bg_widget = QtWidgets.QWidget()
        self.bg_widget.setObjectName("bgWidget")

        # Главный контейнер
        main_container = QtWidgets.QWidget()
        self.setCentralWidget(main_container)
        container_layout = QtWidgets.QHBoxLayout(main_container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)

        # Боковая панель чатов
        self.sidebar = QtWidgets.QWidget()
        self.sidebar.setObjectName("sidebar")
        self.sidebar.setFixedWidth(0)  # Изначально скрыта
        sidebar_layout = QtWidgets.QVBoxLayout(self.sidebar)
        sidebar_layout.setContentsMargins(0, 12, 0, 0)  # Верхний отступ как у title
        sidebar_layout.setSpacing(0)

        # Кнопка "Новый чат"
        new_chat_btn = QtWidgets.QPushButton("+ Новый чат")
        new_chat_btn.setObjectName("newChatBtn")
        new_chat_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        new_chat_btn.clicked.connect(self.create_new_chat)
        sidebar_layout.addWidget(new_chat_btn)

        # Список чатов
        self.chats_list = QtWidgets.QListWidget()
        self.chats_list.setObjectName("chatsList")
        self.chats_list.itemClicked.connect(self.switch_chat)
        self.chats_list.setContextMenuPolicy(QtCore.Qt.ContextMenuPolicy.CustomContextMenu)
        self.chats_list.customContextMenuRequested.connect(self.show_delete_panel)
        sidebar_layout.addWidget(self.chats_list)

        # ═══════════════════════════════════════════════
        # НОВОЕ: Кнопка настроек (закреплена снизу sidebar)
        # ═══════════════════════════════════════════════
        self.settings_btn = QtWidgets.QPushButton("⚙️ Настройки")
        self.settings_btn.setObjectName("settingsBtn")
        self.settings_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.settings_btn.clicked.connect(self.open_settings)
        sidebar_layout.addWidget(self.settings_btn)


        container_layout.addWidget(self.sidebar)

        # Панель удаления (справа от sidebar)
        self.delete_panel = QtWidgets.QWidget()
        self.delete_panel.setObjectName("deletePanel")
        self.delete_panel.setFixedWidth(0)  # Изначально скрыта
        delete_layout = QtWidgets.QVBoxLayout(self.delete_panel)
        delete_layout.setContentsMargins(0, 12, 0, 0)
        delete_layout.setSpacing(10)
        
        delete_layout.addStretch()
        
        # Кнопка удаления
        self.delete_chat_btn = QtWidgets.QPushButton("🗑️ Удалить чат")
        self.delete_chat_btn.setObjectName("deleteChatBtn")
        self.delete_chat_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.delete_chat_btn.clicked.connect(self.delete_selected_chat)
        delete_layout.addWidget(self.delete_chat_btn)
        
        delete_layout.addStretch()
        
        container_layout.addWidget(self.delete_panel)
        
        # ID чата для удаления
        self.chat_to_delete = None

        # Основная область
        central = QtWidgets.QWidget()
        central.setObjectName("central")
        main_layout = QtWidgets.QVBoxLayout(central)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        # Title block
        title_widget = QtWidgets.QWidget()
        title_widget.setObjectName("titleWidget")
        self.title_widget = title_widget  # Сохраняем ссылку для blur эффекта
        title_layout = QtWidgets.QHBoxLayout(title_widget)
        title_layout.setContentsMargins(15, 12, 15, 12)
        title_layout.setSpacing(15)

        # Кнопка меню (иконка трёх полосок)
        self.menu_btn = QtWidgets.QPushButton()
        self.menu_btn.setObjectName("menuBtn")
        self.menu_btn.setFixedSize(50, 50)
        self.menu_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.menu_btn.clicked.connect(self.toggle_sidebar)
        # Иконка будет установлена после применения темы
        title_layout.addWidget(self.menu_btn, alignment=QtCore.Qt.AlignmentFlag.AlignVCenter)

        title_layout.addStretch()
        title_label = QtWidgets.QLabel(APP_TITLE)
        title_label.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        title_label.mousePressEvent = lambda event: self.show_model_info()
        title_label.setObjectName("titleLabel")
        font_title = QtGui.QFont("Inter", 22, QtGui.QFont.Weight.Bold)
        title_label.setFont(font_title)
        title_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        title_layout.addWidget(title_label, alignment=QtCore.Qt.AlignmentFlag.AlignVCenter)
        title_layout.addStretch()

        # Кастомная кнопка очистки с подсказкой
        class ClearButtonWithTooltip(QtWidgets.QPushButton):
            def __init__(self, text, parent=None):
                super().__init__(text, parent)
                self.glass_tooltip = None
            
            def enterEvent(self, event):
                # При наведении на неактивную кнопку показываем подсказку
                if not self.isEnabled():
                    if not self.glass_tooltip:
                        self.glass_tooltip = GlassTooltip("Нет сообщений для очистки")
                    # Показываем подсказку под кнопкой
                    button_center = self.rect().center()
                    global_pos = self.mapToGlobal(QtCore.QPoint(button_center.x(), self.height()))
                    self.glass_tooltip.show_at(global_pos)
                super().enterEvent(event)
            
            def leaveEvent(self, event):
                # Скрываем подсказку при уходе курсора
                if self.glass_tooltip:
                    self.glass_tooltip.hide()
                super().leaveEvent(event)
        
        self.clear_btn = ClearButtonWithTooltip("🗑️ Очистить")
        self.clear_btn.setObjectName("clearBtn")
        font_clear = QtGui.QFont("Inter", 13, QtGui.QFont.Weight.Bold)
        self.clear_btn.setFont(font_clear)
        self.clear_btn.setFixedSize(120, 44)
        self.clear_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.clear_btn.clicked.connect(self.clear_chat)
        title_layout.addWidget(self.clear_btn, alignment=QtCore.Qt.AlignmentFlag.AlignVCenter)
        
        # Уменьшен отступ для сдвига кнопки вправо (было 15)
        title_layout.addSpacing(8)

        main_layout.addWidget(title_widget)


        # ═══════════════════════════════════════════════════════════════
        # Chat display - QStackedWidget для переключения чат/настройки
        # ═══════════════════════════════════════════════════════════════
        self.content_stack = QtWidgets.QStackedWidget()
        self.content_stack.setObjectName("contentStack")
        
        # ✅ ИСПРАВЛЕНИЕ: Устанавливаем прозрачный фон для content_stack
        # Это предотвращает белое мигание при переключении страниц
        self.content_stack.setStyleSheet("QStackedWidget { background: transparent; }")

        # ═══════════════════════════════════════════════
        # PAGE 0: CHAT VIEW (существующий функционал)
        # ═══════════════════════════════════════════════
        chat_container = QtWidgets.QWidget()
        chat_container.setObjectName("chatContainer")
        chat_container.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.Expanding,
            QtWidgets.QSizePolicy.Policy.Expanding
        )
        chat_layout = QtWidgets.QVBoxLayout(chat_container)
        chat_layout.setContentsMargins(0, 0, 0, 0)
        
        self.scroll_area = QtWidgets.QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setObjectName("scrollArea")
        self.scroll_area.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.scroll_area.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        self.scroll_area.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.Expanding,
            QtWidgets.QSizePolicy.Policy.Expanding
        )

        self.scroll_area.setStyleSheet("background: transparent;")
        self.scroll_area.viewport().setStyleSheet("background: transparent;")

        self.messages_widget = QtWidgets.QWidget()
        
        self.messages_layout = QtWidgets.QVBoxLayout()
        self.messages_layout.setContentsMargins(5, 5, 5, 20)
        self.messages_layout.setSpacing(8)
        self.messages_layout.setAlignment(QtCore.Qt.AlignmentFlag.AlignTop)
        
        self.messages_widget.setLayout(self.messages_layout)
        
        self.messages_widget.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.Expanding,
            QtWidgets.QSizePolicy.Policy.Minimum
        )

        self.messages_widget.setStyleSheet("background: transparent;")

        self.scroll_area.setWidget(self.messages_widget)
        
        # ═══════════════════════════════════════════════════════════════
        # УСТАНОВКА EVENT FILTER ДЛЯ БЛОКИРОВКИ SCROLL INPUT ВО ВРЕМЯ LAYOUT
        # ═══════════════════════════════════════════════════════════════
        # КРИТИЧНО: Устанавливаем фильтр событий на viewport, а не scroll_area.
        # EventFilter для обновления кнопки "вниз" после wheel событий
        self.scroll_area.viewport().installEventFilter(self)
        
        # EventFilter для обработки resize (обновление позиции кнопки)
        self.scroll_area.installEventFilter(self)
        
        print("[INIT] ✓ messages_layout выровнен вверх без stretch")
        print("[INIT] ✓ БЕЗ автоскролла - пользователь управляет прокруткой сам")
        print("[INIT] ✓ Event filter установлен для обновления кнопки после скролла")
        print("[INIT] ✓ Layout обновляется СИНХРОННО через adjustSize()")
        
        print("[ДИАГНОСТИКА] messages_widget.parent():", self.messages_widget.parent())
        print("[ДИАГНОСТИКА] scroll_area.viewport():", self.scroll_area.viewport())
        print("[ДИАГНОСТИКА] Совпадают?", self.messages_widget.parent() == self.scroll_area.viewport())
        
        # ═══════════════════════════════════════════════
        # НОВОЕ: FLOATING КНОПКА "ВНИЗ" (overlay)
        # ═══════════════════════════════════════════════
        # АРХИТЕКТУРА: Полностью пассивный overlay
        # - НЕ подключена к сигналам scrollbar (valueChanged, rangeChanged)
        # - НЕ вызывает update(), repaint(), updateGeometry()
        # - НЕ влияет на layout сообщений
        # - Обновляется ТОЛЬКО явно после завершения layout
        # - Обновляется после ручного скролла через eventFilter
        self.scroll_to_bottom_btn = ScrollToBottomButton(self.scroll_area)
        self.scroll_to_bottom_btn.clicked.connect(self.manual_scroll_to_bottom)
        
        # Позиционируем кнопку один раз при создании
        # Дальше позиция обновляется только при resize окна (см. eventFilter)
        self.scroll_to_bottom_btn.update_position(
            self.scroll_area.width(),
            self.scroll_area.height()
        )
        
        chat_layout.addWidget(self.scroll_area)
        
        # ═══════════════════════════════════════════════
        # PAGE 1: SETTINGS VIEW
        # ═══════════════════════════════════════════════
        self.settings_view = SettingsView()
        self.settings_view.close_requested.connect(self.close_settings)
        self.settings_view.settings_applied.connect(self.on_settings_applied)
        self.settings_view.delete_all_chats_requested.connect(self.confirm_delete_all_chats)
        
        # Добавляем страницы в stack
        self.content_stack.addWidget(chat_container)  # index 0
        self.content_stack.addWidget(self.settings_view)  # index 1
        
        # Показываем чат по умолчанию
        self.content_stack.setCurrentIndex(0)
        
        main_layout.addWidget(self.content_stack, stretch=1)

        # ═══════════════════════════════════════════════════════════════
        # ФАЙЛОВЫЕ ЧИПЫ — показываются над полем ввода когда файлы прикреплены
        # ═══════════════════════════════════════════════════════════════
        self.file_chip_container = QtWidgets.QWidget()
        self.file_chip_container.setObjectName("fileChipContainer")
        # ✅ ИСПРАВЛЕНИЕ: Устанавливаем максимальную высоту чтобы окно не увеличивалось
        self.file_chip_container.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.Preferred,
            QtWidgets.QSizePolicy.Policy.Maximum  # Максимальный размер ограничен
        )
        self.file_chip_container.setMaximumHeight(120)  # Максимум ~2 ряда чипов
        self.file_chip_container.setStyleSheet("#fileChipContainer { background: transparent; border: none; }")
        self.file_chip_container.hide()  # Скрыт по умолчанию

        # Layout будет создан динамически в update_file_chips()
        main_layout.addWidget(self.file_chip_container)

        # Input elements - добавляем в main_layout ПОСЛЕ scroll area
        input_container = QtWidgets.QWidget()
        input_container.setObjectName("inputContainer")
        input_container.setStyleSheet("#inputContainer { background: transparent; border: none; }")
        # ✅ КРИТИЧНО: Fixed size policy для footer
        input_container.setSizePolicy(
            QtWidgets.QSizePolicy.Policy.Preferred,  # Изменено с Expanding на Preferred
            QtWidgets.QSizePolicy.Policy.Fixed
        )
        input_container.setFixedHeight(85)  # Фиксированная высота footer
        
        input_layout = QtWidgets.QHBoxLayout(input_container)
        input_layout.setContentsMargins(25, 15, 25, 10)
        input_layout.setSpacing(15)

        # Кнопка добавления файла
        self.attach_btn = QtWidgets.QPushButton("+")
        self.attach_btn.setObjectName("attachBtn")
        font_attach = QtGui.QFont("Inter", 26, QtGui.QFont.Weight.Bold)
        self.attach_btn.setFont(font_attach)
        self.attach_btn.setFixedSize(60, 60)
        self.attach_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.attach_btn.clicked.connect(self.show_attach_menu)
        input_layout.addWidget(self.attach_btn)

        self.input_field = QtWidgets.QLineEdit()
        self.input_field.setPlaceholderText("Введите сообщение...")
        self.input_field.setObjectName("inputField")
        font_input = QtGui.QFont("Inter", 14)
        self.input_field.setFont(font_input)
        self.input_field.setMinimumHeight(60)
        self.input_field.returnPressed.connect(self.send_message)
        input_layout.addWidget(self.input_field, stretch=1)
        
        # Кнопка выбора режима AI (новая)
        self.mode_btn = QtWidgets.QPushButton(self.ai_mode)
        self.mode_btn.setObjectName("modeBtn")
        font_mode = QtGui.QFont("Inter", 12, QtGui.QFont.Weight.Medium)
        self.mode_btn.setFont(font_mode)
        self.mode_btn.setFixedSize(95, 60)
        self.mode_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.mode_btn.clicked.connect(self.show_mode_menu)
        input_layout.addWidget(self.mode_btn)

        self.send_btn = QtWidgets.QPushButton("→")
        self.send_btn.setObjectName("sendBtn")
        font_btn = QtGui.QFont("Inter", 22, QtGui.QFont.Weight.Bold)
        self.send_btn.setFont(font_btn)
        self.send_btn.setFixedSize(60, 60)
        self.send_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.send_btn.clicked.connect(self.send_message)
        input_layout.addWidget(self.send_btn)

        # ✅ КРИТИЧНО: Добавляем input_container в main_layout с stretch=0
        main_layout.addWidget(input_container, 0)
        
        # Store reference
        self.input_container = input_container

        # Статус - fixed at bottom
        self.status_label = QtWidgets.QLabel("")
        self.status_label.setObjectName("statusLabel")
        font_status = QtGui.QFont("Inter", 11)
        self.status_label.setFont(font_status)
        self.status_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft)
        self.status_label.setContentsMargins(30, 0, 30, 10)
        main_layout.addWidget(self.status_label)


        # Добавляем основную область в контейнер
        container_layout.addWidget(central)

        self.threadpool = QtCore.QThreadPool()

        # Устанавливаем фильтр событий для автозакрытия sidebar при клике по рабочей области
        self.messages_widget.installEventFilter(self)
        self.scroll_area.viewport().installEventFilter(self)
        chat_container.installEventFilter(self)

        # Загружаем сохранённые настройки
        saved_settings = self.load_saved_settings()
        theme = saved_settings.get("theme", "light")
        liquid_glass = saved_settings.get("liquid_glass", True)
        
        print(f"[INIT] Загружены настройки: тема={theme}, стекло={liquid_glass}")
        
        # КРИТИЧНО: Обновляем self.current_theme ДО применения стилей
        # Без этого меню + и режимов не знают какая тема активна
        self.current_theme = theme
        self.current_liquid_glass = liquid_glass
        
        # Применяем стили с загруженными настройками
        self.apply_styles(theme=theme, liquid_glass=liquid_glass)
        
        # Применяем тему к кнопке "вниз"
        if hasattr(self, 'scroll_to_bottom_btn'):
            self.scroll_to_bottom_btn.apply_theme_styles(theme=theme, liquid_glass=liquid_glass)
        
        # Обновляем settings_view с правильной темой
        if hasattr(self, 'settings_view'):
            self.settings_view.current_settings["theme"] = theme
            self.settings_view.current_settings["liquid_glass"] = liquid_glass
            self.settings_view.pending_settings["theme"] = theme
            self.settings_view.pending_settings["liquid_glass"] = liquid_glass
            self.settings_view.apply_settings_styles()
        
        self.load_chats_list()
        self.load_current_chat()
        
        # Флаг первого показа для финализации layout
        self._first_show_done = False
    
    def load_saved_settings(self) -> dict:
        """Загрузить сохранённые настройки из файла"""
        try:
            if os.path.exists("app_settings.json"):
                with open("app_settings.json", "r", encoding="utf-8") as f:
                    return json.load(f)
        except Exception as e:
            print(f"[SETTINGS] Ошибка загрузки настроек: {e}")
        
        # Возвращаем значения по умолчанию
        return {"theme": "light", "liquid_glass": True}
    
    def showEvent(self, event):
        """
        Обработчик первого показа окна.
        
        КРИТИЧНО: После первого показа окна выполняем финализацию layout.
        Это исправляет баг, когда layout не обновляется до первого скролла.
        """
        super().showEvent(event)
        
        if not self._first_show_done:
            self._first_show_done = True
            # Откладываем финализацию на следующий цикл event loop
            # Это гарантирует что все виджеты полностью отрендерены
            QtCore.QTimer.singleShot(0, self._finalize_initial_layout)
    
    def _finalize_initial_layout(self):
        """
        Финализация layout после первого показа окна.
        
        АЛГОРИТМ:
        1. Дождаться завершения layout через event loop (уже сделано через singleShot(0))
        2. Обновить только контейнер сообщений
        3. НЕ вызывать автоскролл
        4. НЕ использовать processEvents, updateGeometry, adjustSize
        """
        try:
            # Мягкое обновление контейнера сообщений
            if hasattr(self, 'messages_widget'):
                self.messages_widget.update()
            
            # Обновляем scroll area
            if hasattr(self, 'scroll_area'):
                self.scroll_area.update()
            
            print("[LAYOUT_FINALIZE] ✓ Layout финализирован после первого показа")
        except Exception as e:
            print(f"[LAYOUT_FINALIZE] ✗ Ошибка: {e}")
    
    def resizeEvent(self, event):
        """
        Обработка изменения размера окна.
        
        КРИТИЧНО:
        - Обновляем ТОЛЬКО позицию overlay-кнопки "вниз"
        - Обновляем размер blur overlay если он существует
        - НЕ трогаем layout сообщений
        - НЕ вызываем updateGeometry или invalidate
        """
        super().resizeEvent(event)
        
        # Обновляем позицию overlay-кнопки при изменении размера scroll_area
        if hasattr(self, 'scroll_to_bottom_btn') and hasattr(self, 'scroll_area'):
            self.scroll_to_bottom_btn.update_position(
                self.scroll_area.width(),
                self.scroll_area.height()
            )
        
        # ✅ Обновляем размер blur overlay
        if hasattr(self, '_blur_overlay') and self._blur_overlay.isVisible():
            self._blur_overlay.setGeometry(self.rect())
    
    # position_input_elements() удалён - footer теперь в layout
    
    def apply_styles(self, theme: str = "light", liquid_glass: bool = True):
        """
        Применить стили с поддержкой тем и liquid glass.
        
        Параметры:
        - theme: "light" или "dark"
        - liquid_glass: True/False - включить/выключить стеклянные эффекты
        """
        
        print(f"[APPLY_STYLES] Применение стилей: theme={theme}, liquid_glass={liquid_glass}")
        
        # Обновляем иконку меню в зависимости от темы
        if hasattr(self, 'menu_btn'):
            menu_icon = create_menu_icon(theme=theme)
            self.menu_btn.setIcon(QtGui.QIcon(menu_icon))
            self.menu_btn.setIconSize(QtCore.QSize(50, 50))
        
        # ═══════════════════════════════════════════════════════════
        # ЦВЕТОВЫЕ ПАЛИТРЫ - 4 ВАРИАНТА
        # ═══════════════════════════════════════════════════════════
        
        if theme == "dark":
            if liquid_glass:
                # ТЁМНАЯ ТЕМА + СТЕКЛО - тёмное стекло, НЕ светлое
                colors = {
                    "main_bg": "#1e1e21",  # Тёмный фон
                    "central_bg": "rgba(30, 30, 35, 0.70)",  # Тёмное полупрозрачное стекло
                    "sidebar_bg": "rgba(24, 24, 28, 0.65)",  # Тёмное стекло для sidebar
                    
                    "central_border": "rgba(50, 50, 55, 0.4)",  # Мягкие тёмные границы
                    "sidebar_border": "rgba(50, 50, 55, 0.35)",
                    
                    "text_primary": "#e6e6e6",  # Светлый текст для читаемости
                    "text_secondary": "#b0b0b0",
                    "text_tertiary": "#808080",
                    
                    "btn_bg": "rgba(45, 45, 50, 0.55)",  # Тёмные полупрозрачные кнопки
                    "btn_bg_hover": "rgba(55, 55, 60, 0.65)",
                    "btn_border": "rgba(60, 60, 65, 0.4)",
                    
                    "input_bg_start": "rgba(35, 35, 40, 0.75)",  # Тёмные инпуты
                    "input_bg_end": "rgba(28, 28, 32, 0.75)",
                    "input_border": "rgba(55, 55, 60, 0.5)",
                    "input_focus_border": "rgba(139, 92, 246, 0.4)",
                    
                    "accent_primary": "rgba(139, 92, 246, 0.3)",  # Фиолетовый акцент
                    "accent_hover": "rgba(139, 92, 246, 0.45)",
                    
                    "title_bg": "rgba(30, 30, 35, 0.65)",
                    "title_border": "rgba(50, 50, 55, 0.4)",
                    
                    # Мягкая красная кнопка очистки для тёмной темы
                    "clear_btn_bg": "rgba(220, 85, 85, 0.15)",
                    "clear_btn_hover": "rgba(220, 85, 85, 0.25)",
                    "clear_btn_pressed": "rgba(220, 85, 85, 0.35)",
                    "clear_btn_text": "#e89999",
                    "clear_btn_text_hover": "#f0aaaa",
                    "clear_btn_border": "rgba(220, 85, 85, 0.3)",
                    "clear_btn_border_hover": "rgba(220, 85, 85, 0.45)",
                }
            else:
                # ТЁМНАЯ ТЕМА БЕЗ СТЕКЛА - матовый тёмный интерфейс
                colors = {
                    "main_bg": "#1e1e21",
                    "central_bg": "rgb(32, 32, 36)",  # НЕПРОЗРАЧНЫЙ тёмно-серый
                    "sidebar_bg": "rgb(28, 28, 31)",  # НЕПРОЗРАЧНЫЙ
                    
                    "central_border": "rgba(55, 55, 60, 0.9)",  # Чёткие границы
                    "sidebar_border": "rgba(55, 55, 60, 0.85)",
                    
                    "text_primary": "#f0f0f0",  # Очень светлый текст для контраста
                    "text_secondary": "#c0c0c0",
                    "text_tertiary": "#909090",
                    
                    "btn_bg": "rgb(48, 48, 52)",  # НЕПРОЗРАЧНЫЕ кнопки
                    "btn_bg_hover": "rgb(58, 58, 62)",
                    "btn_border": "rgba(68, 68, 72, 0.95)",
                    
                    "input_bg_start": "rgb(38, 38, 42)",  # НЕПРОЗРАЧНЫЕ инпуты
                    "input_bg_end": "rgb(32, 32, 36)",
                    "input_border": "rgba(58, 58, 62, 0.95)",
                    "input_focus_border": "rgba(139, 92, 246, 0.7)",
                    
                    "accent_primary": "rgba(139, 92, 246, 0.45)",
                    "accent_hover": "rgba(139, 92, 246, 0.65)",
                    
                    "title_bg": "rgb(32, 32, 36)",
                    "title_border": "rgba(55, 55, 60, 0.9)",
                    
                    # Мягкая красная кнопка очистки для тёмной темы
                    "clear_btn_bg": "rgba(220, 85, 85, 0.15)",
                    "clear_btn_hover": "rgba(220, 85, 85, 0.25)",
                    "clear_btn_pressed": "rgba(220, 85, 85, 0.35)",
                    "clear_btn_text": "#e89999",
                    "clear_btn_text_hover": "#f0aaaa",
                    "clear_btn_border": "rgba(220, 85, 85, 0.3)",
                    "clear_btn_border_hover": "rgba(220, 85, 85, 0.45)",
                }
        else:
            # СВЕТЛАЯ ТЕМА
            if liquid_glass:
                # СВЕТЛАЯ ТЕМА + СТЕКЛО - классический Liquid Glass
                colors = {
                    "main_bg": "#a1a1aa",
                    "central_bg": "rgba(255, 255, 255, 0.55)",
                    "sidebar_bg": "rgba(255, 255, 255, 0.42)",
                    
                    "central_border": "rgba(255, 255, 255, 0.72)",
                    "sidebar_border": "rgba(255, 255, 255, 0.55)",
                    
                    "text_primary": "#222222",  # Тёмный текст для контраста
                    "text_secondary": "#3a3a3a",
                    "text_tertiary": "#5a5a5a",
                    
                    "btn_bg": "rgba(255, 255, 255, 0.60)",
                    "btn_bg_hover": "rgba(255, 255, 255, 0.78)",
                    "btn_border": "rgba(255, 255, 255, 0.70)",
                    
                    "input_bg_start": "rgba(248, 248, 250, 0.98)",
                    "input_bg_end": "rgba(242, 242, 245, 0.98)",
                    "input_border": "rgba(220, 220, 225, 0.80)",
                    "input_focus_border": "rgba(102, 126, 234, 0.35)",
                    
                    "accent_primary": "rgba(102, 126, 234, 0.18)",
                    "accent_hover": "rgba(102, 126, 234, 0.45)",
                    
                    "title_bg": "rgba(255, 255, 255, 0.52)",
                    "title_border": "rgba(255, 255, 255, 0.72)",
                    
                    # Мягкая красная кнопка очистки для светлой темы
                    "clear_btn_bg": "rgba(220, 85, 85, 0.08)",
                    "clear_btn_hover": "rgba(220, 85, 85, 0.15)",
                    "clear_btn_pressed": "rgba(220, 85, 85, 0.22)",
                    "clear_btn_text": "#c85555",
                    "clear_btn_text_hover": "#b84444",
                    "clear_btn_border": "rgba(220, 85, 85, 0.2)",
                    "clear_btn_border_hover": "rgba(220, 85, 85, 0.35)",
                }
            else:
                # СВЕТЛАЯ ТЕМА БЕЗ СТЕКЛА - плоский iOS-like
                colors = {
                    "main_bg": "#d4d4d8",  # Светло-серый фон
                    "central_bg": "rgb(252, 252, 254)",  # НЕПРОЗРАЧНЫЙ белый
                    "sidebar_bg": "rgb(246, 246, 248)",  # НЕПРОЗРАЧНЫЙ светло-серый
                    
                    "central_border": "rgba(210, 210, 215, 0.95)",
                    "sidebar_border": "rgba(210, 210, 215, 0.9)",
                    
                    "text_primary": "#1a1a1a",  # Очень тёмный текст
                    "text_secondary": "#2a2a2a",
                    "text_tertiary": "#4a4a4a",
                    
                    "btn_bg": "rgb(242, 242, 245)",  # НЕПРОЗРАЧНЫЕ кнопки
                    "btn_bg_hover": "rgb(235, 235, 240)",
                    "btn_border": "rgba(210, 210, 215, 0.95)",
                    
                    "input_bg_start": "rgb(248, 248, 250)",  # НЕПРОЗРАЧНЫЕ инпуты
                    "input_bg_end": "rgb(242, 242, 245)",
                    "input_border": "rgba(210, 210, 215, 0.95)",
                    "input_focus_border": "rgba(102, 126, 234, 0.7)",
                    
                    "accent_primary": "rgba(102, 126, 234, 0.25)",
                    "accent_hover": "rgba(102, 126, 234, 0.5)",
                    
                    "title_bg": "rgb(246, 246, 248)",
                    "title_border": "rgba(210, 210, 215, 0.95)",
                    
                    # Мягкая красная кнопка очистки для светлой темы
                    "clear_btn_bg": "rgba(220, 85, 85, 0.08)",
                    "clear_btn_hover": "rgba(220, 85, 85, 0.15)",
                    "clear_btn_pressed": "rgba(220, 85, 85, 0.22)",
                    "clear_btn_text": "#c85555",
                    "clear_btn_text_hover": "#b84444",
                    "clear_btn_border": "rgba(220, 85, 85, 0.2)",
                    "clear_btn_border_hover": "rgba(220, 85, 85, 0.35)",
                }
        
        style = f"""
        /* ═══════════════════════════════════════════════
           BASE — основной фон
           ═══════════════════════════════════════════════ */
        QMainWindow {{
            background: {colors["main_bg"]};
        }}

        /* ═══════════════════════════════════════════════
           CENTRAL PANEL — основная панель
           ═══════════════════════════════════════════════ */
        #central {{
            background: {colors["central_bg"]};
            border-radius: 0px;
        }}

        /* ═══════════════════════════════════════════════
           SIDEBAR — боковая панель
           ═══════════════════════════════════════════════ */
        #sidebar {{
            background: {colors["sidebar_bg"]};
            border-right: 1px solid {colors["sidebar_border"]};
            border-radius: 0px;
        }}

        /* ── New-chat button ── */
        #newChatBtn {{
            background: {colors["btn_bg"]};
            color: {colors["text_secondary"]};
            border: 1px solid {colors["btn_border"]};
            border-radius: 14px;
            padding: 18px 20px;
            margin: 12px 10px;
            font-size: 16px;
            font-weight: 700;
            text-align: left;
        }}
        #newChatBtn:hover {{
            background: {colors["btn_bg_hover"]};
            border: 1px solid {colors["accent_hover"]};
        }}

        /* ── Chat list ── */
        #chatsList {{
            background: transparent;
            border: none;
            outline: none;
            padding: 0px 10px;
        }}
        #chatsList::item {{
            padding: 12px 14px;
            margin: 3px 0px;
            border-radius: 12px;
            border: none;
            color: {colors["text_secondary"]};
            font-size: 14px;
            font-weight: 500;
            line-height: 1.4;
        }}
        #chatsList::item:hover {{
            background: {colors["btn_bg"]};
        }}
        #chatsList::item:selected {{
            background: {colors["accent_primary"]};
            color: {colors["text_primary"]};
            font-weight: 600;
            border-left: 3px solid {colors["accent_hover"]};
        }}

        /* ── Settings button ── */
        #settingsBtn {{
            background: {colors["btn_bg"]};
            color: {colors["text_secondary"]};
            border: 1px solid {colors["btn_border"]};
            border-radius: 14px;
            padding: 18px 20px;
            margin: 12px 10px;
            font-size: 16px;
            font-weight: 700;
            text-align: left;
        }}
        #settingsBtn:hover {{
            background: {colors["btn_bg_hover"]};
            border: 1px solid {colors["accent_hover"]};
        }}


        /* ── Delete panel ── */
        #deletePanel {{
            background: {colors["sidebar_bg"]};
            border-left: 1px solid {colors["sidebar_border"]};
            padding: 15px;
        }}
        #deleteChatBtn {{
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 rgba(239, 68, 68, 0.75),
                stop:1 rgba(220, 38, 38, 0.85));
            color: white;
            border: none;
            border-radius: 12px;
            padding: 14px 20px;
            font-size: 14px;
            font-weight: 700;
        }}
        #deleteChatBtn:hover {{
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 rgba(239, 68, 68, 0.90),
                stop:1 rgba(185, 28, 28, 0.95));
        }}
        #deleteChatBtn:pressed {{
            background: rgba(185, 28, 28, 0.95);
        }}

        /* ═══════════════════════════════════════════════
           TITLE BAR
           ═══════════════════════════════════════════════ */
        #menuBtn {{
            background: transparent;
            color: {colors["text_secondary"]};
            border: none;
            border-radius: 10px;
            padding: 0;
            margin: 0;
        }}
        #menuBtn:hover {{
            background: {colors["btn_bg"]};
        }}
        #menuBtn:pressed {{
            background: {colors["btn_bg_hover"]};
        }}

        #titleWidget {{
            background: {colors["title_bg"]};
            border: 1px solid {colors["title_border"]};
            border-radius: 18px;
            margin: 10px 15px;
            padding-top: 12px;
            padding-bottom: 12px;
        }}
        #titleLabel {{
            color: {colors["text_secondary"]};
            font-size: 22px;
            font-weight: 700;
            padding: 5px;
        }}

        #clearBtn {{
            background: {colors["clear_btn_bg"]};
            color: {colors["clear_btn_text"]};
            border: 1px solid {colors["clear_btn_border"]};
            border-radius: 12px;
            font-size: 12px;
            font-weight: 700;
            padding: 6px 10px;
            max-width: 105px;
            min-width: 95px;
        }}
        #clearBtn:hover {{
            background: {colors["clear_btn_hover"]};
            border: 1px solid {colors["clear_btn_border_hover"]};
            color: {colors["clear_btn_text_hover"]};
        }}
        #clearBtn:pressed {{
            background: {colors["clear_btn_pressed"]};
            color: {colors["clear_btn_text_hover"]};
        }}

        /* ═══════════════════════════════════════════════
           CHAT SCROLL AREA
           ═══════════════════════════════════════════════ */
        #chatContainer {{ background: transparent; }}

        QScrollArea            {{ background: transparent; border: none; }}
        QScrollArea > QWidget  {{ background: transparent; }}
        QScrollArea > QWidget > QWidget {{ background: transparent; }}

        QScrollBar:vertical {{
            background: transparent;
            width: 0px;
        }}
        QScrollBar::handle:vertical {{
            background: transparent;
            border-radius: 5px;
            min-height: 30px;
        }}
        QScrollBar::handle:vertical:hover {{
            background: transparent;
        }}
        QScrollBar::add-line:vertical,
        QScrollBar::sub-line:vertical {{ height: 0px; }}

        /* ── Input field ── */
        #inputField {{
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {colors["input_bg_start"]},
                stop:1 {colors["input_bg_end"]});
            color: {colors["text_primary"]};
            border: 1px solid {colors["input_border"]};
            border-radius: 30px;
            padding: 18px 25px;
            font-size: 16px;
        }}
        #inputField:focus {{
            border: 1px solid {colors["input_focus_border"]};
        }}
        #inputField::placeholder {{
            color: {colors["text_tertiary"]};
        }}

        /* ── Attach button ── */
        #attachBtn {{
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {colors["input_bg_start"]},
                stop:1 {colors["input_bg_end"]});
            color: {colors["text_tertiary"]};
            border: 1px solid {colors["input_border"]};
            border-radius: 30px;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            padding: 0px;
            line-height: 60px;
        }}
        #attachBtn:hover {{
            border: 1px solid {colors["input_focus_border"]};
        }}
        #attachBtn:pressed {{
            border: 1px solid {colors["accent_hover"]};
        }}

        /* ── Send button ── */
        #sendBtn {{
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {colors["input_bg_start"]},
                stop:1 {colors["input_bg_end"]});
            color: {colors["text_tertiary"]};
            border: 1px solid {colors["input_border"]};
            border-radius: 30px;
            font-size: 26px;
        }}
        #sendBtn:hover {{
            border: 1px solid {colors["input_focus_border"]};
        }}
        #sendBtn:pressed {{
            border: 1px solid {colors["accent_hover"]};
        }}
        #sendBtn:disabled {{
            color: {colors["text_tertiary"]};
            border: 1px solid {colors["input_border"]};
        }}
        
        /* ── Mode button ── */
        #modeBtn {{
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {colors["input_bg_start"]},
                stop:1 {colors["input_bg_end"]});
            color: {colors["text_tertiary"]};
            border: 1px solid {colors["input_border"]};
            border-radius: 30px;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
            padding: 0px 10px;
        }}
        #modeBtn:hover {{
            border: 1px solid {colors["input_focus_border"]};
        }}
        #modeBtn:pressed {{
            border: 1px solid {colors["accent_hover"]};
        }}

        /* ── Status label ── */
        #statusLabel {{
            color: {colors["text_tertiary"]};
            padding-left: 5px;
            font-style: italic;
        }}

        """
        self.setStyleSheet(style)

        try:
            self.scroll_area.viewport().setStyleSheet("background: transparent;")
            self.messages_widget.setStyleSheet("background: transparent;")
        except Exception:
            pass
        
        # ═══════════════════════════════════════════════════════════════════════
        # ОБНОВЛЕНИЕ СТИЛЕЙ СУЩЕСТВУЮЩИХ ВИДЖЕТОВ СООБЩЕНИЙ
        # ═══════════════════════════════════════════════════════════════════════
        # Когда пользователь переключает тему или liquid_glass,
        # нужно обновить стили всех существующих MessageWidget
        try:
            updated_count = 0
            for i in range(self.messages_layout.count()):
                item = self.messages_layout.itemAt(i)
                if item and item.widget():
                    widget = item.widget()
                    # Проверяем что это MessageWidget (у него есть метод update_message_styles)
                    if hasattr(widget, 'update_message_styles'):
                        widget.update_message_styles(theme, liquid_glass)
                        updated_count += 1
            
            if updated_count > 0:
                print(f"[APPLY_STYLES] ✓ Обновлено {updated_count} виджетов сообщений")
        except Exception as e:
            print(f"[APPLY_STYLES] ✗ Ошибка обновления виджетов: {e}")
        
        print(f"[APPLY_STYLES] ✓ Стили применены успешно: theme={theme}, liquid_glass={liquid_glass}")

    
    def show_model_info(self):
        """Показать информацию о модели при клике на заголовок"""
        QtWidgets.QMessageBox.information(
            self,
            "Информация о модели",
            "LLaMA 3 — локальная модель\n\nРаботает полностью офлайн на вашем компьютере.",
            QtWidgets.QMessageBox.StandardButton.Ok
        )
    
    def show_mode_menu(self):
        """Показать меню выбора режима работы AI с премиум iOS-like анимацией"""
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 1: АНИМАЦИЯ НАЖАТИЯ КНОПКИ (spring bounce)
        # ═══════════════════════════════════════════════════════════════
        # Создаём анимацию уменьшения кнопки при нажатии
        if not hasattr(self, '_mode_button_press_anim'):
            self._mode_button_press_anim = QtCore.QPropertyAnimation(self.mode_btn, b"geometry")
        
        # Получаем текущую геометрию кнопки
        original_geo = self.mode_btn.geometry()
        center_x = original_geo.center().x()
        center_y = original_geo.center().y()
        
        # Уменьшаем до 0.9 scale
        new_width = int(95 * 0.9)
        new_height = int(60 * 0.9)
        pressed_geo = QtCore.QRect(
            center_x - new_width // 2,
            center_y - new_height // 2,
            new_width,
            new_height
        )
        
        # Быстрое нажатие
        self._mode_button_press_anim.setDuration(100)
        self._mode_button_press_anim.setStartValue(original_geo)
        self._mode_button_press_anim.setEndValue(pressed_geo)
        self._mode_button_press_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutQuad)
        
        # После нажатия - возврат с bounce
        def on_press_finished():
            if not hasattr(self, '_mode_button_release_anim'):
                self._mode_button_release_anim = QtCore.QPropertyAnimation(self.mode_btn, b"geometry")
            
            self._mode_button_release_anim.setDuration(350)
            self._mode_button_release_anim.setStartValue(pressed_geo)
            self._mode_button_release_anim.setEndValue(original_geo)
            # OutBack создаёт лёгкий spring bounce эффект
            self._mode_button_release_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutBack)
            self._mode_button_release_anim.start()
        
        self._mode_button_press_anim.finished.connect(on_press_finished)
        self._mode_button_press_anim.start()
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 2: СОЗДАНИЕ МЕНЮ
        # ═══════════════════════════════════════════════════════════════
        menu = QtWidgets.QMenu(self)
        
        # Получаем текущую тему
        is_dark = self.current_theme == "dark"
        
        # Прозрачное меню
        menu.setWindowFlags(QtCore.Qt.WindowType.Popup | QtCore.Qt.WindowType.FramelessWindowHint)
        if not IS_WINDOWS:
            menu.setAttribute(QtCore.Qt.WidgetAttribute.WA_TranslucentBackground)
        
        # Адаптивные стили в зависимости от темы
        if is_dark:
            # Тёмная тема
            menu.setStyleSheet("""
                QMenu {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 rgba(30, 30, 35, 0.92),
                        stop:1 rgba(25, 25, 30, 0.95));
                    border: 1px solid rgba(60, 60, 70, 0.8);
                    border-radius: 16px;
                    padding: 10px;
                }
                QMenu::item {
                    padding: 14px 45px;
                    border-radius: 12px;
                    color: #e0e0e0;
                    font-size: 15px;
                    font-weight: 600;
                    margin: 4px;
                    background: transparent;
                }
                QMenu::item:selected {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 rgba(60, 60, 70, 0.85),
                        stop:1 rgba(50, 50, 60, 0.88));
                    color: #ffffff;
                }
            """)
        else:
            # Светлая тема
            menu.setStyleSheet("""
                QMenu {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 rgba(255, 255, 255, 0.92),
                        stop:1 rgba(250, 250, 252, 0.95));
                    border: 1px solid rgba(255, 255, 255, 0.95);
                    border-radius: 16px;
                    padding: 10px;
                }
                QMenu::item {
                    padding: 14px 45px;
                    border-radius: 12px;
                    color: #1a202c;
                    font-size: 15px;
                    font-weight: 600;
                    margin: 4px;
                    background: transparent;
                }
                QMenu::item:selected {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 rgba(255, 255, 255, 0.85),
                        stop:1 rgba(245, 245, 250, 0.88));
                    color: #0f172a;
                }
            """)
        
        # Создаём действия для каждого режима
        fast_action = menu.addAction("⚡ Быстрый")
        fast_action.setCheckable(True)
        fast_action.setChecked(self.ai_mode == AI_MODE_FAST)
        
        thinking_action = menu.addAction("🧠 Думающий")
        thinking_action.setCheckable(True)
        thinking_action.setChecked(self.ai_mode == AI_MODE_THINKING)
        
        pro_action = menu.addAction("🚀 Про")
        pro_action.setCheckable(True)
        pro_action.setChecked(self.ai_mode == AI_MODE_PRO)
        
        # Получаем позицию кнопки
        button_rect = self.mode_btn.rect()
        button_global_pos = self.mode_btn.mapToGlobal(button_rect.bottomLeft())
        
        # Получаем размер меню
        menu.adjustSize()
        menu_size = menu.sizeHint()
        menu_height = menu_size.height()
        menu_width = menu_size.width()
        
        # Получаем геометрию окна приложения
        window_geometry = self.geometry()
        window_top = self.mapToGlobal(QtCore.QPoint(0, 0)).y()
        window_bottom = self.mapToGlobal(QtCore.QPoint(0, window_geometry.height())).y()
        
        # Вычисляем позицию ВВЕРХ от кнопки
        menu_pos_up = QtCore.QPoint(
            button_global_pos.x() - (menu_width - self.mode_btn.width()) // 2,  # Центрируем по кнопке
            button_global_pos.y() - self.mode_btn.height() - menu_height - 8
        )
        
        # Проверяем, выходит ли меню за верхнюю границу окна
        if menu_pos_up.y() < window_top + 80:  # 80px отступ от верха (title bar)
            # Если выходит за верх - показываем ВНИЗ от кнопки
            menu_pos = QtCore.QPoint(
                button_global_pos.x() - (menu_width - self.mode_btn.width()) // 2,
                button_global_pos.y() + 8
            )
            print("[MODE_MENU] Меню открывается вниз (не хватает места сверху)")
        else:
            # Показываем вверх
            menu_pos = menu_pos_up
            print("[MODE_MENU] Меню открывается вверх")
        
        # Плавное появление меню через fade + scale
        # Создаём эффект прозрачности
        opacity_effect = QtWidgets.QGraphicsOpacityEffect(menu)
        menu.setGraphicsEffect(opacity_effect)
        opacity_effect.setOpacity(0.0)
        
        # Анимация прозрачности
        opacity_anim = QtCore.QPropertyAnimation(opacity_effect, b"opacity")
        opacity_anim.setDuration(280)
        opacity_anim.setStartValue(0.0)
        opacity_anim.setEndValue(1.0)
        opacity_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
        
        # ═══════════════════════════════════════════════════════════════
        # SCALE АНИМАЦИЯ - меню появляется снизу вверх с пружинным эффектом
        # ═══════════════════════════════════════════════════════════════
        # Создаём dummy property для анимации масштаба
        class ScaleAnimator(QtCore.QObject):
            valueChanged = QtCore.pyqtSignal(float)
            
            def __init__(self):
                super().__init__()
                self._value = 0.0
            
            def getValue(self):
                return self._value
            
            def setValue(self, val):
                self._value = val
                self.valueChanged.emit(val)
            
            value = QtCore.pyqtProperty(float, getValue, setValue)
        
        scale_animator = ScaleAnimator()
        scale_anim = QtCore.QPropertyAnimation(scale_animator, b"value")
        scale_anim.setDuration(350)
        scale_anim.setStartValue(0.85)
        scale_anim.setEndValue(1.0)
        scale_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutBack)  # iOS-like spring
        
        # Подключаем обновление геометрии при изменении scale
        def update_menu_scale(value):
            try:
                # Получаем текущую геометрию
                if not hasattr(menu, '_original_height'):
                    menu._original_height = menu_height
                
                # Вычисляем новую высоту
                new_height = int(menu._original_height * value)
                
                # Обновляем позицию (anchor point - центр кнопки)
                button_center_y = button_global_pos.y() - self.mode_btn.height() // 2
                
                # Позиционируем меню относительно центра
                if menu_pos.y() < button_center_y:
                    # Меню вверху - растём вниз
                    new_y = button_global_pos.y() - self.mode_btn.height() - new_height - 8
                else:
                    # Меню внизу - растём вверх
                    new_y = button_global_pos.y() + 8
                
                # Устанавливаем новую геометрию
                menu.setGeometry(
                    menu_pos.x(),
                    new_y,
                    menu_width,
                    new_height
                )
            except:
                pass
        
        scale_animator.valueChanged.connect(update_menu_scale)
        
        # Группа анимаций
        anim_group = QtCore.QParallelAnimationGroup()
        anim_group.addAnimation(opacity_anim)
        anim_group.addAnimation(scale_anim)
        
        # Сохраняем ссылки для предотвращения garbage collection
        menu._anim_group = anim_group
        menu._opacity_effect = opacity_effect
        menu._scale_animator = scale_animator
        
        # Запускаем анимацию после небольшой задержки (после нажатия кнопки)
        QtCore.QTimer.singleShot(120, anim_group.start)
        
        action = menu.exec(menu_pos)
        
        # КРИТИЧНО: Убираем фокус с кнопки ВСЕГДА, даже если ничего не выбрано
        # Это предотвращает "залипание" обводки на кнопке
        self.mode_btn.clearFocus()
        
        # Обрабатываем выбор
        if action == fast_action:
            self.ai_mode = AI_MODE_FAST
            self.mode_btn.setText(AI_MODE_FAST)
            print(f"[MODE] Выбран режим: {AI_MODE_FAST}")
        elif action == thinking_action:
            self.ai_mode = AI_MODE_THINKING
            self.mode_btn.setText(AI_MODE_THINKING)
            print(f"[MODE] Выбран режим: {AI_MODE_THINKING}")
        elif action == pro_action:
            self.ai_mode = AI_MODE_PRO
            self.mode_btn.setText(AI_MODE_PRO)
            print(f"[MODE] Выбран режим: {AI_MODE_PRO}")
        
        # Возвращаем фокус на поле ввода
        self.input_field.setFocus()
    
    def eventFilter(self, obj, event):
        """
        Фильтр событий для:
        1. Обновления кнопки "вниз" после ручного скролла
        2. Позиционирования floating кнопки при resize
        3. Автозакрытия sidebar при клике вне его
        
        ПРОСТАЯ АРХИТЕКТУРА:
        - Wheel события НИКОГДА не блокируются
        - После wheel → обновляем кнопку через invokeMethod
        - При resize → обновляем позицию кнопки
        - НЕТ сложной синхронизации, НЕТ флагов
        """
        # ═══════════════════════════════════════════════
        # ОБРАБОТКА WHEEL СОБЫТИЙ (прокрутка колесиком)
        # ═══════════════════════════════════════════════
        # Проверяем что это viewport нашего scroll_area
        if obj == self.scroll_area.viewport():
            # Если это wheel событие
            if event.type() == QtCore.QEvent.Type.Wheel:
                # ═══════════════════════════════════════════════
                # НИКОГДА НЕ БЛОКИРУЕМ WHEEL
                # ═══════════════════════════════════════════════
                # Layout завершается независимо от действий пользователя
                # Пользователь может скроллить в любой момент
                # Обрабатываем wheel событие стандартно
                result = super().eventFilter(obj, event)
                
                # ПОСЛЕ обработки wheel события обновляем кнопку
                # Используем QMetaObject.invokeMethod для отложенного вызова
                # чтобы кнопка обновилась ПОСЛЕ полной обработки скролла
                # (scrollbar.value() уже изменился)
                # update_scroll_button_visibility сама проверит _layout_in_progress
                QtCore.QMetaObject.invokeMethod(
                    self,
                    "_update_button_after_scroll",
                    QtCore.Qt.ConnectionType.QueuedConnection
                )
                
                return result
        
        # ═══════════════════════════════════════════════
        # ОБРАБОТКА RESIZE SCROLL_AREA (изменение размера)
        # ═══════════════════════════════════════════════
        if obj == self.scroll_area and event.type() == QtCore.QEvent.Type.Resize:
            if hasattr(self, 'scroll_to_bottom_btn'):
                # Обновляем позицию кнопки при resize
                # Это единственное место где вызывается update_position
                self.scroll_to_bottom_btn.update_position(
                    self.scroll_area.width(),
                    self.scroll_area.height()
                )
        
        # ═══════════════════════════════════════════════
        # АВТОЗАКРЫТИЕ SIDEBAR (клик вне sidebar)
        # ═══════════════════════════════════════════════
        # Проверяем, открыт ли sidebar
        if self.sidebar.width() > 0:
            # Если событие - клик мышью
            if event.type() == QtCore.QEvent.Type.MouseButtonPress:
                # Закрываем sidebar
                self.toggle_sidebar()
        
        # Для всех остальных случаев - стандартная обработка
        return super().eventFilter(obj, event)
    
    @QtCore.pyqtSlot()
    def _update_button_after_scroll(self):
        """
        Обновляет layout и видимость кнопки "вниз" после ручного скролла.
        
        КРИТИЧНО:
        - Вызывается через QMetaObject.invokeMethod после wheel события
        - Гарантирует что скролл полностью обработан
        - При ручном скролле ВСЕГДА обновляет layout (как при переключении чата)
        - Это гарантирует корректное отображение всех накопленных сообщений и кнопки
        """
        # ═══════════════════════════════════════════════════════════════
        # ОБНОВЛЕНИЕ LAYOUT ПРИ РУЧНОМ СКРОЛЛЕ
        # ═══════════════════════════════════════════════════════════════
        # Сохраняем текущую позицию скролла
        scrollbar = self.scroll_area.verticalScrollBar()
        current_value = scrollbar.value()
        
        # Полное обновление layout (как при переключении чата)
        self.messages_layout.invalidate()
        self.messages_layout.activate()
        self.messages_widget.updateGeometry()
        
        # Синхронная отрисовка
        self.scroll_area.viewport().repaint()
        QtWidgets.QApplication.processEvents()
        
        # Восстанавливаем позицию скролла
        scrollbar.setValue(current_value)
        
        # Теперь обновляем кнопку после завершения layout
        if hasattr(self, 'scroll_to_bottom_btn'):
            self.update_scroll_button_visibility()
    
    def toggle_thinking(self, state=None):
        # Блокируем переключение во время генерации
        if self.is_generating:
            return
        
        # Если вызвано напрямую (из меню), просто используем текущее состояние
        if state is None:
            return
        
        self.deep_thinking = (state == QtCore.Qt.CheckState.Checked.value)

    def toggle_search(self, state=None):
        # Блокируем переключение во время генерации
        if self.is_generating:
            return
        
        # Если вызвано напрямую (из меню), просто используем текущее состояние
        if state is None:
            return
        
        self.use_search = (state == QtCore.Qt.CheckState.Checked.value)
    
    def show_attach_menu(self):
        """Показать меню с опциями Search и Attach file с премиум iOS-like анимацией + blur эффект"""
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 1: АНИМАЦИЯ НАЖАТИЯ КНОПКИ "+" (spring bounce)
        # ═══════════════════════════════════════════════════════════════
        # Создаём анимацию уменьшения кнопки при нажатии
        if not hasattr(self, '_button_press_anim'):
            self._button_press_anim = QtCore.QPropertyAnimation(self.attach_btn, b"geometry")
        
        # Получаем текущую геометрию кнопки
        original_geo = self.attach_btn.geometry()
        center_x = original_geo.center().x()
        center_y = original_geo.center().y()
        
        # Уменьшаем до 0.9 scale
        new_size = int(60 * 0.9)
        pressed_geo = QtCore.QRect(
            center_x - new_size // 2,
            center_y - new_size // 2,
            new_size,
            new_size
        )
        
        # Быстрое нажатие
        self._button_press_anim.setDuration(100)
        self._button_press_anim.setStartValue(original_geo)
        self._button_press_anim.setEndValue(pressed_geo)
        self._button_press_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutQuad)
        
        # После нажатия - возврат с bounce и запуск blur эффекта
        def on_press_finished():
            if not hasattr(self, '_button_release_anim'):
                self._button_release_anim = QtCore.QPropertyAnimation(self.attach_btn, b"geometry")
            
            self._button_release_anim.setDuration(350)
            self._button_release_anim.setStartValue(pressed_geo)
            self._button_release_anim.setEndValue(original_geo)
            # OutBack создаёт лёгкий spring bounce эффект
            self._button_release_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutBack)
            self._button_release_anim.start()
            
            # ✅ ИСПРАВЛЕНО: Убрали активацию blur здесь - она будет синхронизирована с появлением меню
        
        self._button_press_anim.finished.connect(on_press_finished)
        self._button_press_anim.start()
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 2: СОЗДАНИЕ МЕНЮ
        # ═══════════════════════════════════════════════════════════════
        menu = QtWidgets.QMenu(self)
        
        # Получаем текущую тему
        is_dark = self.current_theme == "dark"
        
        # Прозрачное меню без артефактов
        menu.setWindowFlags(QtCore.Qt.WindowType.Popup | QtCore.Qt.WindowType.FramelessWindowHint)
        # Прозрачность работает плохо на Windows
        if not IS_WINDOWS:
            menu.setAttribute(QtCore.Qt.WidgetAttribute.WA_TranslucentBackground)
        
        # Адаптивные стили в зависимости от темы
        if is_dark:
            # Тёмная тема - стеклянный эффект
            menu.setStyleSheet("""
                QMenu {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 rgba(30, 30, 35, 0.92),
                        stop:1 rgba(25, 25, 30, 0.95));
                    border: 1px solid rgba(60, 60, 70, 0.8);
                    border-radius: 20px;
                    padding: 12px;
                }
                QMenu::item {
                    padding: 14px 45px;
                    border-radius: 12px;
                    color: #e0e0e0;
                    font-size: 15px;
                    font-weight: 600;
                    margin: 4px;
                    background: transparent;
                    min-width: 190px;
                    max-width: 190px;
                }
                QMenu::item:selected {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 rgba(60, 60, 70, 0.85),
                        stop:1 rgba(50, 50, 60, 0.88));
                    color: #ffffff;
                }
                QMenu::separator {
                    height: 1px;
                    background: rgba(80, 80, 90, 0.50);
                    margin: 8px 20px;
                }
            """)
        else:
            # Светлая тема - стеклянный эффект
            menu.setStyleSheet("""
                QMenu {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 rgba(255, 255, 255, 0.92),
                        stop:1 rgba(250, 250, 252, 0.95));
                    border: 1px solid rgba(255, 255, 255, 0.95);
                    border-radius: 20px;
                    padding: 12px;
                }
                QMenu::item {
                    padding: 14px 45px;
                    border-radius: 12px;
                    color: #1a202c;
                    font-size: 15px;
                    font-weight: 600;
                    margin: 4px;
                    background: transparent;
                    min-width: 190px;
                    max-width: 190px;
                }
                QMenu::item:selected {
                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                        stop:0 rgba(255, 255, 255, 0.85),
                        stop:1 rgba(245, 245, 250, 0.88));
                    color: #0f172a;
                }
                QMenu::separator {
                    height: 1px;
                    background: rgba(200, 200, 210, 0.60);
                    margin: 8px 20px;
                }
            """)
        
        # FORCED SEARCH - явное указание режима принудительного поиска
        search_label = "🔴 Принудительный поиск" if self.use_search else "🔍 Умный поиск"
        search_action = menu.addAction(search_label)
        search_action.setCheckable(True)
        search_action.setChecked(self.use_search)
        
        # Разделитель
        menu.addSeparator()
        
        # Attach file опция — показываем количество прикреплённых файлов
        files_count = len(self.attached_files)
        if files_count > 0:
            if files_count >= 5:
                # Достигнут лимит - можно только открепить
                file_action = menu.addAction(f"📎 Файлов: {files_count}/5 (максимум)")
                file_action.setEnabled(False)
                clear_action = menu.addAction(f"✕  Открепить все ({files_count})")
            else:
                # Можно добавить ещё файлы
                file_action = menu.addAction(f"📎 Добавить файл ({files_count}/5)")
                clear_action = menu.addAction(f"✕  Открепить все ({files_count})")
        else:
            file_action = menu.addAction("📎 Прикрепить файл")
            clear_action = None
        
        # Вычисляем позицию меню НАД кнопкой с edge avoidance
        button_rect = self.attach_btn.rect()
        button_global_pos = self.attach_btn.mapToGlobal(button_rect.topLeft())
        button_center = self.attach_btn.mapToGlobal(button_rect.center())
        
        # Размеры меню
        menu_height = 150
        # Рассчитываем правильную ширину меню:
        # Item: 190px (content) + 90px (padding 45px*2) + 8px (margin 4px*2) = 288px
        # Menu: 288px + 24px (padding 12px*2) = 312px
        menu_width = 320  # С небольшим запасом
        
        # ═══════════════════════════════════════════════════════════════
        # EDGE AVOIDANCE - гарантируем что меню не выходит за границы окна
        # ═══════════════════════════════════════════════════════════════
        
        # Получаем размеры окна приложения
        app_geometry = self.geometry()
        window_global_pos = self.mapToGlobal(QtCore.QPoint(0, 0))
        window_width = app_geometry.width()
        
        # Минимальный отступ от краёв окна
        EDGE_PADDING = 12
        
        # Вычисляем идеальную позицию (центр меню по центру кнопки)
        ideal_menu_x = button_center.x() - menu_width // 2
        
        # Применяем clamp - ограничиваем позицию границами окна
        # Левая граница: минимум EDGE_PADDING от левого края окна
        min_x = window_global_pos.x() + EDGE_PADDING
        # Правая граница: максимум так, чтобы правый край меню был на EDGE_PADDING от правого края окна
        max_x = window_global_pos.x() + window_width - menu_width - EDGE_PADDING
        
        # Clamp позиции
        clamped_menu_x = max(min_x, min(ideal_menu_x, max_x))
        
        # Финальная позиция меню
        menu_pos = QtCore.QPoint(
            clamped_menu_x,  # X с edge avoidance
            button_global_pos.y() - menu_height - 8  # Y: над кнопкой с отступом
        )
        
        # Отладочная информация
        print(f"[POPOVER] Позиционирование меню:")
        print(f"  Кнопка центр: x={button_center.x()}")
        print(f"  Окно: x={window_global_pos.x()}, width={window_width}")
        print(f"  Меню ширина: {menu_width}")
        print(f"  Идеальная позиция: x={ideal_menu_x}")
        print(f"  Границы: min_x={min_x}, max_x={max_x}")
        print(f"  Финальная позиция: x={clamped_menu_x}")
        print(f"  Сдвиг от идеала: {clamped_menu_x - ideal_menu_x}px")
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 3: ПРЕМИУМ АНИМАЦИЯ ПОЯВЛЕНИЯ МЕНЮ (iOS-like spring)
        # ═══════════════════════════════════════════════════════════════
        
        # Группа анимаций для одновременного воспроизведения
        anim_group = QtCore.QParallelAnimationGroup(menu)
        
        # 1. Анимация прозрачности (fade in)
        opacity_effect = QtWidgets.QGraphicsOpacityEffect(menu)
        menu.setGraphicsEffect(opacity_effect)
        opacity_effect.setOpacity(0.0)
        
        opacity_anim = QtCore.QPropertyAnimation(opacity_effect, b"opacity")
        opacity_anim.setDuration(380)  # 380ms - плавно и премиум
        opacity_anim.setStartValue(0.0)
        opacity_anim.setEndValue(1.0)
        opacity_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutExpo)  # Плавное замедление
        
        # 2. Анимация масштаба по вертикали (scaleY: 0.85 → 1)
        # Используем динамическое свойство для вертикального scale
        menu.setProperty("scale_y", 0.85)
        
        scale_anim = QtCore.QPropertyAnimation(menu, b"scale_y")
        scale_anim.setDuration(380)  # Синхронизировано
        scale_anim.setStartValue(0.85)
        scale_anim.setEndValue(1.0)
        scale_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutBack)  # iOS-like spring
        
        # Подключаем обновление геометрии при изменении scale
        def update_menu_scale(value):
            try:
                # Получаем текущую геометрию
                if not hasattr(menu, '_original_height'):
                    menu._original_height = menu_height
                
                # Вычисляем новую высоту
                new_height = int(menu._original_height * value)
                
                # Обновляем позицию (anchor point внизу - в центре кнопки)
                new_y = button_global_pos.y() - new_height - 8
                
                # Устанавливаем новую геометрию
                menu.setGeometry(
                    menu_pos.x(),
                    new_y,
                    menu_width,
                    new_height
                )
            except:
                pass
        
        scale_anim.valueChanged.connect(update_menu_scale)
        
        # Добавляем анимации в группу
        anim_group.addAnimation(opacity_anim)
        anim_group.addAnimation(scale_anim)
        
        # Сохраняем ссылки для предотвращения garbage collection
        menu._anim_group = anim_group
        menu._opacity_effect = opacity_effect
        
        # Запускаем анимацию после небольшой задержки (после нажатия кнопки)
        QtCore.QTimer.singleShot(120, anim_group.start)
        
        # ✅ ИСПРАВЛЕНИЕ: Активируем blur синхронно с анимацией появления меню
        # Запускаем blur эффект одновременно с анимацией меню
        QtCore.QTimer.singleShot(120, self._apply_menu_blur_effect)
        
        # Показываем меню
        action = menu.exec(menu_pos)
        
        # ✅ ИСПРАВЛЕНИЕ: После закрытия меню - убираем blur и восстанавливаем кнопку
        self._remove_menu_blur_effect()
        
        # Убираем фокус с кнопки после закрытия меню
        self.attach_btn.clearFocus()
        self.input_field.setFocus()
        
        if action == search_action:
            # Переключаем режим Forced Search
            self.use_search = not self.use_search
            if self.use_search:
                print(f"[MENU] ⚠️ FORCED SEARCH MODE активирован - поиск будет выполнен ОБЯЗАТЕЛЬНО")
            else:
                print(f"[MENU] Режим 'Умный поиск' - автоматическое определение необходимости поиска")
        elif action == file_action:
            self.attach_file()
        elif clear_action and action == clear_action:
            self.clear_attached_file()
    
    def _apply_menu_blur_effect(self):
        """Применить реальный blur эффект через снимок экрана"""
        print("[BLUR] Применяю blur эффект через снимок экрана")
        
        # ✅ Устанавливаем флаг что меню открыто
        self._menu_is_open = True
        
        # ✅ Сохраняем состояние кнопки "вниз" перед blur
        if hasattr(self, 'scroll_to_bottom_btn'):
            self._scroll_btn_was_visible = self.scroll_to_bottom_btn._is_visible_animated
        else:
            self._scroll_btn_was_visible = False
        
        # ═══════════════════════════════════════════════════════════════
        # 1. СОЗДАНИЕ РАЗМЫТОГО СНИМКА ЭКРАНА
        # ═══════════════════════════════════════════════════════════════
        
        # Создаем или переиспользуем overlay
        if not hasattr(self, '_blur_overlay'):
            self._blur_overlay = QtWidgets.QLabel(self)
            self._blur_overlay.setObjectName("blurOverlay")
            self._blur_overlay.setScaledContents(True)
            
            # Создаём opacity эффект для анимации появления
            self._overlay_opacity = QtWidgets.QGraphicsOpacityEffect(self._blur_overlay)
            self._blur_overlay.setGraphicsEffect(self._overlay_opacity)
            self._overlay_opacity.setOpacity(0.0)
        else:
            # Очищаем старый pixmap перед созданием нового
            self._blur_overlay.clear()
        
        # ШАГ 1: Делаем снимок экрана (скрываем overlay если он виден)
        self._blur_overlay.hide()
        QtWidgets.QApplication.processEvents()
        snapshot = self.grab()
        
        # ШАГ 2: Применяем blur к снимку
        # Создаем временный QLabel для применения blur effect
        temp_label = QtWidgets.QLabel()
        temp_label.setPixmap(snapshot)
        temp_label.resize(snapshot.size())
        
        # Применяем blur эффект
        blur_effect = QtWidgets.QGraphicsBlurEffect()
        blur_effect.setBlurRadius(15)  # Средний blur
        temp_label.setGraphicsEffect(blur_effect)
        
        # Рендерим размытый результат в новый pixmap
        blurred_pixmap = QtGui.QPixmap(snapshot.size())
        blurred_pixmap.fill(QtCore.Qt.GlobalColor.transparent)
        
        painter = QtGui.QPainter(blurred_pixmap)
        temp_label.render(painter)
        painter.end()
        
        # Удаляем временный label
        temp_label.deleteLater()
        
        # ШАГ 3: Применяем затемнение поверх размытого снимка
        # Создаём полупрозрачный слой для затемнения
        overlay = QtGui.QPixmap(blurred_pixmap.size())
        is_dark = self.current_theme == "dark"
        
        if is_dark:
            overlay.fill(QtGui.QColor(0, 0, 0, 80))  # Легкое затемнение
        else:
            overlay.fill(QtGui.QColor(255, 255, 255, 80))  # Легкое осветление
        
        # Накладываем затемнение на размытый снимок
        final_painter = QtGui.QPainter(blurred_pixmap)
        final_painter.drawPixmap(0, 0, overlay)
        final_painter.end()
        
        # ШАГ 4: Устанавливаем размытый снимок в overlay
        self._blur_overlay.setPixmap(blurred_pixmap)
        self._blur_overlay.setGeometry(self.rect())
        self._blur_overlay.raise_()
        self._blur_overlay.show()
        
        # Анимация появления overlay
        if not hasattr(self, '_overlay_anim'):
            self._overlay_anim = QtCore.QPropertyAnimation(self._overlay_opacity, b"opacity")
        
        self._overlay_anim.stop()
        self._overlay_anim.setDuration(300)
        self._overlay_anim.setStartValue(0.0)
        self._overlay_anim.setEndValue(1.0)
        self._overlay_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
        self._overlay_anim.start()
        
        # ═══════════════════════════════════════════════════════════════
        # 2. FADE OUT КНОПКИ "+"
        # ═══════════════════════════════════════════════════════════════
        # Создаём opacity эффект для кнопки
        if not hasattr(self.attach_btn, '_opacity_effect'):
            self.attach_btn._opacity_effect = QtWidgets.QGraphicsOpacityEffect(self.attach_btn)
            self.attach_btn.setGraphicsEffect(self.attach_btn._opacity_effect)
        
        self.attach_btn._opacity_effect.setOpacity(1.0)
        
        # Анимируем opacity от 1.0 до 0.0
        if not hasattr(self, '_button_fade_anim'):
            self._button_fade_anim = QtCore.QPropertyAnimation(self.attach_btn._opacity_effect, b"opacity")
        
        self._button_fade_anim.stop()  # ✅ Останавливаем если работает
        self._button_fade_anim.setDuration(250)  # 250ms - быстрое исчезновение
        self._button_fade_anim.setStartValue(1.0)
        self._button_fade_anim.setEndValue(0.0)
        self._button_fade_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
        self._button_fade_anim.start()
        
        # ═══════════════════════════════════════════════════════════════
        # 3. FADE OUT КНОПКИ "ВНИЗ" (используем её существующий opacity effect)
        # ═══════════════════════════════════════════════════════════════
        if hasattr(self, 'scroll_to_bottom_btn') and self.scroll_to_bottom_btn.isVisible():
            # Останавливаем текущую анимацию
            self.scroll_to_bottom_btn.fade_animation.stop()
            
            # Плавно скрываем кнопку
            self.scroll_to_bottom_btn.fade_animation.setDuration(250)
            self.scroll_to_bottom_btn.fade_animation.setStartValue(
                self.scroll_to_bottom_btn.opacity_effect.opacity()
            )
            self.scroll_to_bottom_btn.fade_animation.setEndValue(0.0)
            self.scroll_to_bottom_btn.fade_animation.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
            self.scroll_to_bottom_btn.fade_animation.start()
        
        print("[BLUR] Blur эффект применён, кнопка + скрыта")
    
    def _remove_menu_blur_effect(self):
        """Убрать overlay эффект и восстановить кнопку + при закрытии меню"""
        print("[BLUR] Убираю overlay эффект")
        
        # ✅ Устанавливаем флаг что меню закрыто
        self._menu_is_open = False
        
        # ═══════════════════════════════════════════════════════════════
        # 1. FADE OUT OVERLAY
        # ═══════════════════════════════════════════════════════════════
        if hasattr(self, '_overlay_anim') and hasattr(self, '_blur_overlay'):
            # Получаем текущее значение opacity
            current_opacity = self._overlay_opacity.opacity()
            
            self._overlay_anim.stop()
            self._overlay_anim.setDuration(250)
            self._overlay_anim.setStartValue(current_opacity)
            self._overlay_anim.setEndValue(0.0)
            self._overlay_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
            
            # После завершения анимации - скрываем overlay
            def cleanup_overlay():
                # ✅ Проверяем что меню действительно закрыто
                if hasattr(self, '_menu_is_open') and self._menu_is_open:
                    print("[BLUR] Пропускаю cleanup - меню снова открыто")
                    return
                
                if hasattr(self, '_blur_overlay'):
                    self._blur_overlay.hide()
                    # Очищаем pixmap для освобождения памяти
                    self._blur_overlay.clear()
                    print("[BLUR] Overlay скрыт и очищен")
            
            # Отключаем предыдущие коллбэки
            try:
                self._overlay_anim.finished.disconnect()
            except:
                pass
            
            self._overlay_anim.finished.connect(cleanup_overlay)
            self._overlay_anim.start()
        
        # ═══════════════════════════════════════════════════════════════
        # 2. FADE IN КНОПКИ "+"
        # ═══════════════════════════════════════════════════════════════
        if hasattr(self, '_button_fade_anim') and hasattr(self.attach_btn, '_opacity_effect'):
            # Получаем текущее значение opacity
            current_opacity = self.attach_btn._opacity_effect.opacity()
            
            # Останавливаем текущую анимацию
            self._button_fade_anim.stop()
            
            # Анимируем opacity от текущего значения до 1.0
            self._button_fade_anim.setDuration(300)  # 300ms - плавное появление
            self._button_fade_anim.setStartValue(current_opacity)
            self._button_fade_anim.setEndValue(1.0)
            self._button_fade_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
            self._button_fade_anim.start()
        
        # ═══════════════════════════════════════════════════════════════
        # 3. FADE IN КНОПКИ "ВНИЗ" (восстанавливаем если была видна до blur)
        # ═══════════════════════════════════════════════════════════════
        if hasattr(self, 'scroll_to_bottom_btn'):
            # Останавливаем текущую анимацию
            self.scroll_to_bottom_btn.fade_animation.stop()
            
            # ✅ ИСПРАВЛЕНИЕ: Используем сохраненное состояние
            if hasattr(self, '_scroll_btn_was_visible') and self._scroll_btn_was_visible:
                print("[BLUR] Восстанавливаю кнопку 'вниз' - она была видна до blur")
                # Плавно восстанавливаем видимость
                self.scroll_to_bottom_btn.fade_animation.setDuration(300)
                self.scroll_to_bottom_btn.fade_animation.setStartValue(
                    self.scroll_to_bottom_btn.opacity_effect.opacity()
                )
                self.scroll_to_bottom_btn.fade_animation.setEndValue(1.0)
                self.scroll_to_bottom_btn.fade_animation.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
                self.scroll_to_bottom_btn.fade_animation.start()
            else:
                print("[BLUR] Кнопка 'вниз' не восстанавливается - она не была видна до blur")
        
        print("[BLUR] Кнопка + восстановлена")
    
    def attach_file(self):
        """Выбрать и прикрепить файл (любой тип, включая изображения)"""
        # Проверяем лимит файлов
        if len(self.attached_files) >= 5:
            print("[ATTACH] Достигнут лимит файлов (5)")
            return
        
        file_path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self,
            "Выбрать файл",
            "",
            "Все файлы (*.*);;Изображения (*.png *.jpg *.jpeg *.gif *.bmp *.webp);;Текстовые файлы (*.txt *.md *.py *.js *.json)"
        )
        
        # Возвращаем фокус в приложение
        self.activateWindow()
        self.raise_()
        
        if file_path:
            # Добавляем файл в список
            # Копируем файл в директорию чата
            print(f"[ATTACH] ════════════════════════════════════════")
            print(f"[ATTACH] Прикрепление файла через диалог")
            print(f"[ATTACH] Оригинальный путь: {file_path}")
            
            copied_path = self.copy_file_to_chat_dir(file_path, self.current_chat_id)
            
            if copied_path:
                # КРИТИЧНО: Проверяем что copied_path содержит chat_files
                if 'chat_files' in copied_path and os.path.exists(copied_path):
                    self.attached_files.append(copied_path)
                    print(f"[ATTACH] ✅ Файл добавлен в attached_files:")
                    print(f"[ATTACH]    Путь: {copied_path}")
                    print(f"[ATTACH]    Существует: {os.path.exists(copied_path)}")
                else:
                    print(f"[ATTACH] ✗ ОШИБКА: Неправильный путь или файл не существует!")
                    print(f"[ATTACH]    Путь: {copied_path}")
                    print(f"[ATTACH]    Содержит chat_files: {'chat_files' in copied_path}")
                    print(f"[ATTACH]    Существует: {os.path.exists(copied_path)}")
                    QtWidgets.QMessageBox.warning(
                        self,
                        "Ошибка прикрепления",
                        f"Не удалось прикрепить файл. Проверьте права доступа к директории chat_files.",
                        QtWidgets.QMessageBox.StandardButton.Ok
                    )
            else:
                # Если копирование не удалось - НЕ добавляем файл!
                print(f"[ATTACH] ✗ ОШИБКА: Копирование не удалось!")
                print(f"[ATTACH] Файл НЕ будет прикреплён")
                QtWidgets.QMessageBox.warning(
                    self,
                    "Ошибка копирования",
                    f"Не удалось скопировать файл в хранилище чата.\n\nПроверьте:\n1. Права доступа к файлу\n2. Доступ к директории chat_files\n3. Свободное место на диске",
                    QtWidgets.QMessageBox.StandardButton.Ok
                )
            
            print(f"[ATTACH] Всего файлов в attached_files: {len(self.attached_files)}")
            for idx, f in enumerate(self.attached_files, 1):
                print(f"[ATTACH]    {idx}. {f}")
            print(f"[ATTACH] ════════════════════════════════════════")
            
            self.update_file_chips()
            
        # Возвращаем фокус на поле ввода
        self.input_field.setFocus()
    
    def clear_attached_file(self, file_path=None):
        """Очистить прикреплённый файл и обновить чипы
        
        Args:
            file_path: Путь к файлу для удаления. Если None, удаляются все файлы.
        """
        if file_path is None:
            # Удаляем все файлы
            self.attached_files = []
        else:
            # Удаляем конкретный файл
            if file_path in self.attached_files:
                self.attached_files.remove(file_path)
        
        # Обновляем отображение
        self.update_file_chips()
        
        # Возвращаем фокус на поле ввода
        self.input_field.setFocus()
    

    # ═══════════════════════════════════════════════════════════════
    # МЕТОДЫ УПРАВЛЕНИЯ ФАЙЛАМИ ЧАТОВ
    # ═══════════════════════════════════════════════════════════════
    
    def copy_file_to_chat_dir(self, source_path: str, chat_id: int) -> str:
        """Копирует файл в директорию чата и возвращает новый путь (УЛУЧШЕНО: нормализация путей)"""
        print(f"[CHAT_FILES] ════════════════════════════════════════")
        print(f"[CHAT_FILES] КОПИРОВАНИЕ ФАЙЛА")
        print(f"[CHAT_FILES] Источник: {source_path}")
        print(f"[CHAT_FILES] Chat ID: {chat_id}")
        print(f"[CHAT_FILES] Директория хранилища: {self.chat_files_dir}")
        
        try:
            # УЛУЧШЕНИЕ: Нормализуем исходный путь
            source_path = os.path.normpath(source_path)
            source_path = os.path.abspath(source_path)
            print(f"[CHAT_FILES] Нормализованный источник: {source_path}")
            
            # Проверяем что источник существует
            if not os.path.exists(source_path):
                print(f"[CHAT_FILES] ✗ ОШИБКА: Исходный файл не существует!")
                return None
            
            # УЛУЧШЕНИЕ: Нормализуем директорию хранилища
            chat_files_dir = os.path.normpath(os.path.abspath(self.chat_files_dir))
            
            # Создаём директорию для этого чата
            chat_dir = os.path.join(chat_files_dir, f"chat_{chat_id}")
            chat_dir = os.path.normpath(os.path.abspath(chat_dir))
            print(f"[CHAT_FILES] Целевая директория чата: {chat_dir}")
            
            if not os.path.exists(chat_dir):
                os.makedirs(chat_dir)
                print(f"[CHAT_FILES] ✓ Создана директория чата")
            else:
                print(f"[CHAT_FILES] ✓ Директория чата уже существует")
            
            # Генерируем уникальное имя файла с timestamp
            import time
            timestamp = int(time.time() * 1000)
            file_name = os.path.basename(source_path)
            new_file_name = f"{timestamp}_{file_name}"
            dest_path = os.path.join(chat_dir, new_file_name)
            dest_path = os.path.normpath(os.path.abspath(dest_path))
            
            print(f"[CHAT_FILES] Целевой путь (АБСОЛЮТНЫЙ): {dest_path}")
            
            # Копируем файл
            import shutil
            shutil.copy2(source_path, dest_path)
            
            # Проверяем что файл скопирован
            if os.path.exists(dest_path):
                file_size = os.path.getsize(dest_path)
                print(f"[CHAT_FILES] ✅ УСПЕШНО! Файл скопирован ({file_size} байт)")
                print(f"[CHAT_FILES] ════════════════════════════════════════")
                return dest_path
            else:
                print(f"[CHAT_FILES] ✗ ОШИБКА: Файл не появился после копирования!")
                print(f"[CHAT_FILES] ════════════════════════════════════════")
                return None
                
        except Exception as e:
            print(f"[CHAT_FILES] ✗ КРИТИЧЕСКАЯ ОШИБКА: {e}")
            import traceback
            traceback.print_exc()
            print(f"[CHAT_FILES] ════════════════════════════════════════")
            return None
    
    def load_chat_files(self, chat_id: int):
        """Загружает файлы для указанного чата (УЛУЧШЕНО: детальное логирование)"""
        print(f"[LOAD_CHAT_FILES] ════════════════════════════════════════")
        print(f"[LOAD_CHAT_FILES] Загрузка файлов для чата {chat_id}")
        
        try:
            chat_files_dir = os.path.normpath(os.path.abspath(self.chat_files_dir))
            chat_dir = os.path.join(chat_files_dir, f"chat_{chat_id}")
            chat_dir = os.path.normpath(os.path.abspath(chat_dir))
            
            print(f"[LOAD_CHAT_FILES] Директория чата: {chat_dir}")
            print(f"[LOAD_CHAT_FILES] Существует: {os.path.exists(chat_dir)}")
            
            if os.path.exists(chat_dir):
                files = []
                for file_name in os.listdir(chat_dir):
                    file_path = os.path.join(chat_dir, file_name)
                    file_path = os.path.normpath(os.path.abspath(file_path))
                    
                    if os.path.isfile(file_path):
                        files.append(file_path)
                        print(f"[LOAD_CHAT_FILES]   Найден файл: {file_path}")
                        print(f"[LOAD_CHAT_FILES]   Существует: {os.path.exists(file_path)}")
                
                print(f"[LOAD_CHAT_FILES] ✅ Загружено {len(files)} файлов для чата {chat_id}")
                print(f"[LOAD_CHAT_FILES] ════════════════════════════════════════")
                return files
            else:
                print(f"[LOAD_CHAT_FILES] ℹ️ Директория чата {chat_id} не существует")
                print(f"[LOAD_CHAT_FILES] ════════════════════════════════════════")
                return []
        except Exception as e:
            print(f"[LOAD_CHAT_FILES] ✗ Ошибка загрузки файлов: {e}")
            import traceback
            traceback.print_exc()
            print(f"[LOAD_CHAT_FILES] ════════════════════════════════════════")
            return []
    
    def clear_chat_files(self, chat_id: int):
        """Удаляет все файлы чата"""
        try:
            chat_dir = os.path.join(self.chat_files_dir, f"chat_{chat_id}")
            if os.path.exists(chat_dir):
                import shutil
                shutil.rmtree(chat_dir)
                print(f"[CHAT_FILES] ✓ Удалена директория чата {chat_id}")
                return True
            else:
                print(f"[CHAT_FILES] ℹ️ Директория чата {chat_id} не существует")
                return False
        except Exception as e:
            print(f"[CHAT_FILES] ✗ Ошибка удаления файлов: {e}")
            return False
    
    def clear_all_chat_files(self):
        """Удаляет файлы всех чатов"""
        try:
            if os.path.exists(self.chat_files_dir):
                import shutil
                for item in os.listdir(self.chat_files_dir):
                    item_path = os.path.join(self.chat_files_dir, item)
                    if os.path.isdir(item_path):
                        shutil.rmtree(item_path)
                print(f"[CHAT_FILES] ✓ Удалены файлы всех чатов")
                return True
        except Exception as e:
            print(f"[CHAT_FILES] ✗ Ошибка удаления всех файлов: {e}")
            return False

    def update_file_chips(self):
        """Обновить отображение файловых чипов"""
        if not hasattr(self, 'file_chip_container'):
            return
        
        # Очищаем контейнер
        layout = self.file_chip_container.layout()
        if layout:
            while layout.count():
                item = layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()
            # Удаляем старый layout
            QtWidgets.QWidget().setLayout(layout)
        
        # Если файлов нет - скрываем контейнер
        if not self.attached_files:
            self.file_chip_container.hide()
            self.input_field.setPlaceholderText("Введите сообщение...")
            return
        
        # Показываем контейнер
        self.file_chip_container.show()
        self.input_field.setPlaceholderText("Введите вопрос...")
        
        # Получаем текущую тему
        is_dark = getattr(self, 'current_theme', 'light') == 'dark'
        
        # Создаем новый grid layout для wrapping
        grid_layout = QtWidgets.QGridLayout(self.file_chip_container)
        grid_layout.setContentsMargins(25, 4, 25, 4)
        grid_layout.setSpacing(8)
        
        # Размещаем чипы в сетке (максимум 3 в строке)
        MAX_CHIPS_PER_ROW = 3
        row = 0
        col = 0
        
        # Создаем чип для каждого файла
        for file_path in self.attached_files:
            file_name = os.path.basename(file_path)
            file_ext = os.path.splitext(file_path)[1].lower()
            
            # Выбираем эмодзи в зависимости от типа файла
            if file_ext in ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp']:
                emoji = "🖼️"
            else:
                emoji = "📎"
            
            # Создаем чип
            chip = QtWidgets.QWidget()
            chip.setObjectName("fileChip")
            
            # Стили для чипа в зависимости от темы
            if is_dark:
                chip.setStyleSheet("""
                    #fileChip {
                        background: rgba(102, 126, 234, 0.20);
                        border: 1px solid rgba(102, 126, 234, 0.40);
                        border-radius: 14px;
                        padding: 2px 6px;
                    }
                """)
            else:
                chip.setStyleSheet("""
                    #fileChip {
                        background: rgba(102, 126, 234, 0.15);
                        border: 1px solid rgba(102, 126, 234, 0.35);
                        border-radius: 14px;
                        padding: 2px 6px;
                    }
                """)
            
            chip_layout = QtWidgets.QHBoxLayout(chip)
            chip_layout.setContentsMargins(10, 4, 6, 4)
            chip_layout.setSpacing(6)
            
            # Лейбл с названием файла
            display_name = file_name if len(file_name) <= 20 else file_name[:17] + "…"
            label = QtWidgets.QLabel(f"{emoji} {display_name}")
            label.setFont(QtGui.QFont("Inter", 11))
            
            if is_dark:
                label.setStyleSheet("color: #8fa3f5; background: transparent; border: none;")
            else:
                label.setStyleSheet("color: #667eea; background: transparent; border: none;")
            
            chip_layout.addWidget(label)
            
            # Кнопка удаления
            remove_btn = QtWidgets.QPushButton("✕")
            remove_btn.setFixedSize(22, 22)
            remove_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
            remove_btn.setFont(QtGui.QFont("Inter", 10, QtGui.QFont.Weight.Bold))
            
            if is_dark:
                remove_btn.setStyleSheet("""
                    QPushButton {
                        background: rgba(102, 126, 234, 0.25);
                        color: #8fa3f5;
                        border: none;
                        border-radius: 11px;
                    }
                    QPushButton:hover {
                        background: rgba(239, 68, 68, 0.30);
                        color: #f87171;
                    }
                """)
            else:
                remove_btn.setStyleSheet("""
                    QPushButton {
                        background: rgba(102, 126, 234, 0.2);
                        color: #667eea;
                        border: none;
                        border-radius: 11px;
                    }
                    QPushButton:hover {
                        background: rgba(239, 68, 68, 0.25);
                        color: #ef4444;
                    }
                """)
            
            # Замыкание для передачи пути файла
            remove_btn.clicked.connect(lambda checked, fp=file_path: self.clear_attached_file(fp))
            chip_layout.addWidget(remove_btn)
            
            # Добавляем чип в grid layout
            grid_layout.addWidget(chip, row, col)
            
            # Переходим к следующей позиции
            col += 1
            if col >= MAX_CHIPS_PER_ROW:
                col = 0
                row += 1
        
        # Добавляем stretch в конце последнего ряда
        grid_layout.setColumnStretch(MAX_CHIPS_PER_ROW, 1)
    
    def start_status_animation(self):
        """Запуск анимации точек в статусе"""
        self.status_dots_count = 0
        self.status_timer = QtCore.QTimer(self)
        self.status_timer.timeout.connect(self.update_status_dots)
        self.status_timer.start(350)  # Интервал 350ms
    
    def update_status_dots(self):
        """Обновление точек в статусе"""
        # ✅ КРИТИЧНО: Проверка наличия status_base_text
        if not hasattr(self, 'status_base_text'):
            self.status_base_text = ""
        
        # ✅ КРИТИЧНО: Очищаем перед обновлением
        self.status_label.clear()
        
        dots = "." * self.status_dots_count
        self.status_label.setText(f"{self.status_base_text}{dots}")
        self.status_dots_count = (self.status_dots_count + 1) % 4  # 0, 1, 2, 3
    
    def stop_status_animation(self):
        """Остановка анимации точек"""
        if hasattr(self, 'status_timer') and self.status_timer.isActive():
            self.status_timer.stop()
        # ✅ КРИТИЧНО: Очищаем перед установкой пустой строки
        self.status_label.clear()
        self.status_label.setText("")

    def toggle_sidebar(self):
        """Переключение боковой панели с плавной анимацией (УЛУЧШЕНО)"""
        current_width = self.sidebar.width()
        target_width = 280 if current_width == 0 else 0
        is_opening = target_width > 0
        
        # Скрываем панель удаления при закрытии sidebar
        if target_width == 0:
            self.hide_delete_panel()
        
        # ═══════════════════════════════════════════════════════════════
        # АНИМАЦИЯ КНОПКИ МЕНЮ (поворот)
        # ═══════════════════════════════════════════════════════════════
        if hasattr(self, 'menu_btn'):
            # Создаём анимацию поворота иконки меню
            if not hasattr(self, '_menu_btn_rotate_anim'):
                self._menu_btn_rotate_anim = QtCore.QPropertyAnimation(self.menu_btn, b"rotation")
            
            # Поворачиваем иконку при открытии/закрытии
            target_rotation = 90 if is_opening else 0
            
            self._menu_btn_rotate_anim.stop()
            self._menu_btn_rotate_anim.setDuration(400)
            self._menu_btn_rotate_anim.setStartValue(0 if not is_opening else 90)
            self._menu_btn_rotate_anim.setEndValue(target_rotation)
            self._menu_btn_rotate_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
            
            # Масштабирование кнопки при клике (bounce эффект)
            if not hasattr(self, '_menu_btn_scale_anim'):
                self._menu_btn_scale_anim = QtCore.QPropertyAnimation(self.menu_btn, b"geometry")
            
            original_geo = self.menu_btn.geometry()
            center_x = original_geo.center().x()
            center_y = original_geo.center().y()
            
            # Уменьшаем до 0.85 scale
            scale_factor = 0.85
            new_width = int(original_geo.width() * scale_factor)
            new_height = int(original_geo.height() * scale_factor)
            pressed_geo = QtCore.QRect(
                center_x - new_width // 2,
                center_y - new_height // 2,
                new_width,
                new_height
            )
            
            # Быстрое сжатие
            self._menu_btn_scale_anim.stop()
            self._menu_btn_scale_anim.setDuration(120)
            self._menu_btn_scale_anim.setStartValue(original_geo)
            self._menu_btn_scale_anim.setEndValue(pressed_geo)
            self._menu_btn_scale_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutQuad)
            
            # После сжатия - возврат с bounce
            def on_menu_press_finished():
                if not hasattr(self, '_menu_btn_release_anim'):
                    self._menu_btn_release_anim = QtCore.QPropertyAnimation(self.menu_btn, b"geometry")
                
                self._menu_btn_release_anim.setDuration(400)
                self._menu_btn_release_anim.setStartValue(pressed_geo)
                self._menu_btn_release_anim.setEndValue(original_geo)
                self._menu_btn_release_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutBack)
                self._menu_btn_release_anim.start()
            
            try:
                self._menu_btn_scale_anim.finished.disconnect()
            except:
                pass
            self._menu_btn_scale_anim.finished.connect(on_menu_press_finished)
            self._menu_btn_scale_anim.start()
        
        # ═══════════════════════════════════════════════════════════════
        # АНИМАЦИЯ SIDEBAR (плавное выдвижение/скрытие)
        # ═══════════════════════════════════════════════════════════════
        # Останавливаем предыдущие анимации если ещё идут
        if hasattr(self, 'animation') and self.animation:
            self.animation.stop()
        if hasattr(self, 'animation2') and self.animation2:
            self.animation2.stop()
        
        # Более плавная и быстрая анимация
        duration = 450   # ms - чуть дольше для более плавного эффекта
        easing = QtCore.QEasingCurve.Type.OutCubic  # Более плавная кривая
        
        self.animation = QtCore.QPropertyAnimation(self.sidebar, b"minimumWidth")
        self.animation.setDuration(duration)
        self.animation.setStartValue(current_width)
        self.animation.setEndValue(target_width)
        self.animation.setEasingCurve(easing)
        
        self.animation2 = QtCore.QPropertyAnimation(self.sidebar, b"maximumWidth")
        self.animation2.setDuration(duration)
        self.animation2.setStartValue(current_width)
        self.animation2.setEndValue(target_width)
        self.animation2.setEasingCurve(easing)
        
        self.animation.start()
        self.animation2.start()
        
        print(f"[SIDEBAR] {'Открываю' if is_opening else 'Закрываю'} sidebar с плавной анимацией")
    


    def manual_scroll_to_bottom(self):
        """
        Ручной скролл вниз при нажатии на кнопку с ПЛАВНОЙ анимацией.
        НЕ автоматический - только по клику пользователя.
        
        ОБНОВЛЕНИЕ LAYOUT:
        Когда пользователь нажимает кнопку "вниз", делаем полное
        обновление layout чтобы все накопленные сообщения отобразились корректно.
        
        ПЛАВНЫЙ СКРОЛЛ:
        Используем QPropertyAnimation для плавного скролла вниз.
        """
        print("[MANUAL_SCROLL] 🔄 Обновление layout перед скроллом вниз...")
        
        # Полное обновление layout для корректного отображения всех сообщений
        self.messages_layout.invalidate()
        self.messages_layout.activate()
        self.messages_widget.updateGeometry()
        self.scroll_area.viewport().repaint()
        QtWidgets.QApplication.processEvents()
        
        # ═══════════════════════════════════════════════════════════════
        # ПЛАВНЫЙ СКРОЛЛ ВНИЗ
        # ═══════════════════════════════════════════════════════════════
        scrollbar = self.scroll_area.verticalScrollBar()
        
        # Создаём анимацию скролла
        if not hasattr(self, '_scroll_animation'):
            self._scroll_animation = QtCore.QPropertyAnimation(scrollbar, b"value")
        
        self._scroll_animation.stop()  # Останавливаем предыдущую если есть
        self._scroll_animation.setDuration(600)  # 600ms - более плавная и приятная анимация
        self._scroll_animation.setStartValue(scrollbar.value())
        self._scroll_animation.setEndValue(scrollbar.maximum())
        self._scroll_animation.setEasingCurve(QtCore.QEasingCurve.Type.OutExpo)  # Более естественная кривая
        
        # Когда скролл завершится - плавно скрываем кнопку
        def on_scroll_finished():
            self.scroll_to_bottom_btn.smooth_hide()
        
        # Отключаем старый обработчик если был
        try:
            self._scroll_animation.finished.disconnect()
        except:
            pass
        
        self._scroll_animation.finished.connect(on_scroll_finished)
        self._scroll_animation.start()
        
        print("[MANUAL_SCROLL] ✓ Запущен плавный скролл вниз")
    
    def update_scroll_button_visibility(self):
        """
        Обновить видимость overlay-кнопки "вниз" на основе положения scrollBar.
        
        ═══ ПОЛНОСТЬЮ ПАССИВНЫЙ OVERLAY - АРХИТЕКТУРА ═══
        
        КРИТИЧНО - ПРАВИЛА ПАССИВНОСТИ:
        1. НЕ подключен к сигналам scrollbar (valueChanged, rangeChanged)
        2. Вызывается ТОЛЬКО явно:
           - После завершения layout в add_message_widget()
           - После ручного скролла в _update_button_after_scroll()
           - При resize окна в eventFilter
        3. ТОЛЬКО читает состояние scrollbar - НЕ изменяет его
        4. ТОЛЬКО меняет visibility (show/hide) - НЕ вызывает:
           - update(), repaint()
           - updateGeometry(), adjustSize()
           - invalidate(), activate() на любом layout
           - update_position() (позиция обновляется только в resize)
        
        ГАРАНТИИ:
        - НЕ влияет на layout сообщений
        - НЕ вызывает пересчёт геометрии
        - НЕ создаёт race condition с layout-pass
        - Layout уже завершён через adjustSize() до вызова этой функции
        
        ЛОГИКА:
        - ScrollBar внизу → hide()
        - ScrollBar не внизу → show()
        - Контент помещается → hide()
        """
        # Проверяем что мы на странице чата, а не настроек
        if hasattr(self, 'content_stack') and self.content_stack.currentIndex() != 0:
            self.scroll_to_bottom_btn.smooth_hide()
            return
        
        scrollbar = self.scroll_area.verticalScrollBar()
        
        # Проверяем что контент больше viewport
        if scrollbar.maximum() == 0:
            self.scroll_to_bottom_btn.smooth_hide()
            return
        
        # Показываем кнопку если НЕ внизу (с порогом 10px)
        if scrollbar.value() < scrollbar.maximum() - 10:
            # ПЛАВНОЕ ПОЯВЛЕНИЕ вместо резкого show()
            self.scroll_to_bottom_btn.smooth_show()
        else:
            # ПЛАВНОЕ ИСЧЕЗНОВЕНИЕ вместо резкого hide()
            self.scroll_to_bottom_btn.smooth_hide()
    
    def check_has_chats_with_messages(self) -> bool:
        """
        Проверить есть ли хоть один чат с сообщениями.
        Если все чаты пустые (или чатов вообще нет) — возвращает False.
        """
        try:
            import sqlite3 as _sq
            import chat_manager as _cm
            conn = _sq.connect(_cm.CHATS_DB)
            cur = conn.cursor()
            cur.execute("SELECT COUNT(*) FROM chat_messages")
            count = cur.fetchone()[0]
            conn.close()
            return count > 0
        except Exception as e:
            print(f"[CHECK_CHATS] Ошибка: {e}")
            return False

    def open_settings(self):
        """Открыть экран настроек"""
        print("[SETTINGS] Открытие настроек")
        
        # Скрываем кнопку скролла
        if hasattr(self, 'scroll_to_bottom_btn'):
            self.scroll_to_bottom_btn.smooth_hide()
        
        # Скрываем ВСЕ элементы чата
        if hasattr(self, 'scroll_area'):
            self.scroll_area.hide()
        if hasattr(self, 'title_label'):
            self.title_label.hide()
        if hasattr(self, 'clear_btn'):
            self.clear_btn.hide()
        if hasattr(self, 'input_container'):
            self.input_container.hide()
        
        # Отключаем toggle_sidebar, подключаем close_settings
        if hasattr(self, 'menu_btn'):
            try:
                self.menu_btn.clicked.disconnect()
            except:
                pass
            self.menu_btn.clicked.connect(self.close_settings)
        
        # Обновляем стили экрана настроек ПЕРЕД показом
        if hasattr(self, 'settings_view'):
            self.settings_view.apply_settings_styles()
            has_messages = self.check_has_chats_with_messages()
            self.settings_view.update_delete_all_btn_state(has_messages)
            
            # ═══════════════════════════════════════════════════════════════
            # ВАЖНО: Скрываем settings_view чтобы не было двойного появления
            # ═══════════════════════════════════════════════════════════════
            self.settings_view.hide()
        
        # Функция для показа настроек с анимацией (вызывается ПОСЛЕ переключения страницы)
        def show_settings_animated():
            print("[SETTINGS] Страница переключена, запускаю fade-in...")
            
            if not hasattr(self, 'settings_view'):
                return
            
            # Показываем виджет
            self.settings_view.show()
            
            # Применяем эффект opacity
            effect = QtWidgets.QGraphicsOpacityEffect(self.settings_view)
            self.settings_view.setGraphicsEffect(effect)
            effect.setOpacity(0.0)
            
            # Анимация появления
            anim = QtCore.QPropertyAnimation(effect, b"opacity")
            anim.setDuration(300)
            anim.setStartValue(0.0)
            anim.setEndValue(1.0)
            anim.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
            anim.start()
            
            # Сохраняем ссылку
            if not hasattr(self, '_settings_fade_animations'):
                self._settings_fade_animations = []
            self._settings_fade_animations.append(anim)
            
            print("[SETTINGS] ✓ Настройки плавно появляются")
        
        # Закрываем sidebar если открыт
        if self.sidebar.width() > 0:
            print("[SETTINGS] Закрываю sidebar...")
            self.toggle_sidebar()
            # Ждём закрытия sidebar + переключаем страницу + показываем с анимацией
            QtCore.QTimer.singleShot(400, lambda: [
                self.content_stack.setCurrentIndex(1),
                QtCore.QTimer.singleShot(50, show_settings_animated)
            ])
        else:
            print("[SETTINGS] Sidebar закрыт, открываю настройки")
            # Сразу переключаем страницу + показываем с анимацией
            self.content_stack.setCurrentIndex(1)
            QtCore.QTimer.singleShot(50, show_settings_animated)
        
        print(f"[SETTINGS] Текущий индекс: {self.content_stack.currentIndex()}")
    
        def switch_to_settings():
            print("[SETTINGS] ▶ switch_to_settings() вызвана")
            
            # Скрываем элементы header кроме кнопки меню
            if hasattr(self, 'title_label'):
                print("[SETTINGS] Скрываю title_label")
                self.title_label.hide()
            if hasattr(self, 'clear_btn'):
                print("[SETTINGS] Скрываю clear_btn")
                self.clear_btn.hide()
            
            # Скрываем footer (поле ввода, кнопки)
            if hasattr(self, 'input_container'):
                print("[SETTINGS] Скрываю input_container")
                self.input_container.hide()
            
            # Отключаем toggle_sidebar, подключаем close_settings
            if hasattr(self, 'menu_btn'):
                try:
                    self.menu_btn.clicked.disconnect()
                    print("[SETTINGS] Отключил старый обработчик menu_btn")
                except:
                    pass
                self.menu_btn.clicked.connect(self.close_settings)
                print("[SETTINGS] Подключил close_settings к menu_btn")
            
            # Плавный переход к настройкам
            print("[SETTINGS] Запускаю _animate_stack_transition(0 → 1)")
            self._animate_stack_transition(from_index=0, to_index=1, callback=None)
            print(f"[SETTINGS] ✓ Переключен на индекс: {self.content_stack.currentIndex()}")
        
        # Проверяем ширину sidebar
        sidebar_width = self.sidebar.width()
        print(f"[SETTINGS] Ширина sidebar: {sidebar_width}")
        
        # Если sidebar открыт - сначала закрываем его
        if sidebar_width > 0:
            print("[SETTINGS] Sidebar открыт, сначала закрываю его...")
            
            # Ждем завершения анимации закрытия sidebar
            def on_sidebar_closed():
                print("[SETTINGS] ✓ Sidebar закрыт (callback вызван)")
                # Небольшая задержка для плавности
                print("[SETTINGS] Задержка 100ms перед открытием настроек...")
                QtCore.QTimer.singleShot(100, switch_to_settings)
            
            # Подключаем callback к анимации
            if hasattr(self, 'animation') and self.animation:
                try:
                    self.animation.finished.disconnect()
                except:
                    pass
                self.animation.finished.connect(on_sidebar_closed)
                print("[SETTINGS] Callback подключен к анимации sidebar")
            else:
                print("[SETTINGS] ⚠️ animation не найдена!")
            
            print("[SETTINGS] Запускаю toggle_sidebar()")
            self.toggle_sidebar()
        else:
            print("[SETTINGS] Sidebar уже закрыт, сразу открываю настройки")
            switch_to_settings()
        
        print("[SETTINGS] ========================================")
        print("[SETTINGS] Открытие настроек - КОНЕЦ метода")
        print("[SETTINGS] ========================================")
    
        def switch_to_settings():
            # Скрываем элементы header кроме кнопки меню
            if hasattr(self, 'title_label'):
                self.title_label.hide()
            if hasattr(self, 'clear_btn'):
                self.clear_btn.hide()
            
            # Скрываем footer (поле ввода, кнопки)
            if hasattr(self, 'input_container'):
                self.input_container.hide()
            
            # Отключаем toggle_sidebar, подключаем close_settings
            if hasattr(self, 'menu_btn'):
                try:
                    self.menu_btn.clicked.disconnect()
                except:
                    pass
                self.menu_btn.clicked.connect(self.close_settings)
            
            # Плавный переход к настройкам
            self._animate_stack_transition(from_index=0, to_index=1, callback=None)
            print(f"[SETTINGS] Переключен на индекс: {self.content_stack.currentIndex()}")
        
        # Если sidebar открыт - сначала закрываем его
        if self.sidebar.width() > 0:
            print("[SETTINGS] Сначала закрываю sidebar...")
            # Ждем завершения анимации закрытия sidebar
            def on_sidebar_closed():
                print("[SETTINGS] Sidebar закрыт, переключаюсь на настройки...")
                # Небольшая задержка для плавности
                QtCore.QTimer.singleShot(100, switch_to_settings)
            
            # Подключаем callback к анимации
            if hasattr(self, 'animation') and self.animation:
                try:
                    self.animation.finished.disconnect()
                except:
                    pass
                self.animation.finished.connect(on_sidebar_closed)
            
            self.toggle_sidebar()
        else:
            # Sidebar уже закрыт, сразу переходим к настройкам
            switch_to_settings()
    
    def close_settings(self):
        """Закрыть настройки и вернуться к чату — с плавным fade-переходом"""
        print("[SETTINGS] Возврат к чату")
        self._animate_stack_transition(from_index=1, to_index=0, callback=self._after_close_settings)

    def _after_close_settings(self):
        """Вызывается после завершения анимации закрытия настроек"""
        print("[SETTINGS] Анимация завершена, показываю элементы интерфейса...")
        
        # ═══════════════════════════════════════════════════════════════
        # ИСПРАВЛЕНИЕ: Плавное появление элементов БЕЗ нарушения layout
        # ═══════════════════════════════════════════════════════════════
        
        # Восстанавливаем обработчик кнопки меню СРАЗУ
        if hasattr(self, 'menu_btn'):
            try:
                self.menu_btn.clicked.disconnect()
            except:
                pass
            self.menu_btn.clicked.connect(self.toggle_sidebar)
        
        # Показываем все элементы БЕЗ анимации (чтобы layout правильно работал)
        if hasattr(self, 'scroll_area'):
            self.scroll_area.show()
        if hasattr(self, 'title_label'):
            self.title_label.show()
        if hasattr(self, 'clear_btn'):
            self.clear_btn.show()
        if hasattr(self, 'input_container'):
            self.input_container.show()
        
        # Обновляем layout ПЕРЕД анимацией
        QtWidgets.QApplication.processEvents()
        
        # Теперь применяем fade-in только к ВЕРХНЕМУ уровню виджетов
        widgets_to_animate = []
        
        if hasattr(self, 'scroll_area'):
            widgets_to_animate.append(self.scroll_area)
        if hasattr(self, 'title_label'):
            widgets_to_animate.append(self.title_label)
        if hasattr(self, 'clear_btn'):
            widgets_to_animate.append(self.clear_btn)
        # НЕ анимируем input_container - там сложный layout с кнопками
        # Вместо этого анимируем только внешний контейнер если он есть
        
        # Применяем эффект opacity ТОЛЬКО если это простые виджеты
        for widget in widgets_to_animate:
            # Проверяем что виджет видим
            if not widget.isVisible():
                continue
                
            effect = QtWidgets.QGraphicsOpacityEffect(widget)
            widget.setGraphicsEffect(effect)
            effect.setOpacity(0.0)
            
            # Анимация появления
            anim = QtCore.QPropertyAnimation(effect, b"opacity")
            anim.setDuration(300)
            anim.setStartValue(0.0)
            anim.setEndValue(1.0)
            anim.setEasingCurve(QtCore.QEasingCurve.Type.OutQuad)
            
            # ВАЖНО: Убираем эффект после завершения анимации
            def remove_effect(w=widget):
                w.setGraphicsEffect(None)
                print(f"[SETTINGS] Убрал эффект с {w.objectName()}")
            
            anim.finished.connect(remove_effect)
            anim.start()
            
            # Сохраняем ссылку
            if not hasattr(self, '_fade_in_animations'):
                self._fade_in_animations = []
            self._fade_in_animations.append(anim)
        
        # input_container появляется БЕЗ анимации (чтобы не сломать layout)
        if hasattr(self, 'input_container'):
            self.input_container.show()
            print("[SETTINGS] input_container показан БЕЗ анимации (сохранён layout)")
        
        # Обновляем видимость кнопки скролла с задержкой
        QtCore.QTimer.singleShot(350, lambda: QtCore.QMetaObject.invokeMethod(
            self,
            "_update_button_after_scroll",
            QtCore.Qt.ConnectionType.QueuedConnection
        ))
        
        print("[SETTINGS] ✓ Элементы интерфейса плавно появляются")

    def _animate_stack_transition(self, from_index: int, to_index: int, callback=None):
        """
        Плавный fade-переход между страницами QStackedWidget.
        Делает скриншот текущей страницы, переключает, плавно убирает скриншот.
        """
        # Останавливаем предыдущую анимацию если идёт
        if hasattr(self, '_stack_anim') and self._stack_anim:
            try:
                self._stack_anim.stop()
                if hasattr(self, '_stack_overlay') and self._stack_overlay:
                    self._stack_overlay.deleteLater()
                    self._stack_overlay = None
            except:
                pass

        # Снимок текущего состояния (страницы from_index)
        snapshot = self.content_stack.grab()

        # Мгновенно переключаем страницу
        self.content_stack.setCurrentIndex(to_index)
        QtWidgets.QApplication.processEvents()

        # Накладываем снимок поверх нового содержимого
        overlay = QtWidgets.QLabel(self.content_stack)
        overlay.setPixmap(snapshot)
        overlay.setGeometry(0, 0, self.content_stack.width(), self.content_stack.height())
        overlay.setScaledContents(True)
        overlay.show()
        overlay.raise_()

        # Эффект прозрачности
        effect = QtWidgets.QGraphicsOpacityEffect(overlay)
        overlay.setGraphicsEffect(effect)
        effect.setOpacity(1.0)

        # Анимация: снимок плавно исчезает → видна новая страница
        anim = QtCore.QPropertyAnimation(effect, b"opacity")
        anim.setDuration(280)
        anim.setStartValue(1.0)
        anim.setEndValue(0.0)
        anim.setEasingCurve(QtCore.QEasingCurve.Type.InOutQuad)

        def on_finished():
            overlay.deleteLater()
            self._stack_overlay = None
            self._stack_anim = None
            if callback:
                callback()

        anim.finished.connect(on_finished)
        anim.start()

        self._stack_overlay = overlay
        self._stack_anim = anim
    
    def on_settings_applied(self, settings: dict):
        """Обработка применения настроек с плавной crossfade анимацией смены темы"""
        print(f"[SETTINGS] Применены настройки: {settings}")
        
        # Получаем параметры
        theme = settings.get("theme", "light")
        liquid_glass = settings.get("liquid_glass", True)
        
        # Проверяем, изменилась ли тема
        theme_changed = (self.current_theme != theme)
        
        if theme_changed:
            # КРИТИЧНО: Останавливаем и очищаем предыдущую анимацию если она ещё идёт
            if hasattr(self, '_crossfade_group') and self._crossfade_group:
                self._crossfade_group.stop()
                self._crossfade_group.deleteLater()
                self._crossfade_group = None
            
            if hasattr(self, '_old_overlay') and self._old_overlay:
                self._old_overlay.deleteLater()
                self._old_overlay = None
            
            if hasattr(self, '_new_overlay') and self._new_overlay:
                self._new_overlay.deleteLater()
                self._new_overlay = None
            
            # ПЛАВНАЯ CROSSFADE АНИМАЦИЯ СМЕНЫ ТЕМЫ
            print(f"[SETTINGS] Запускаю crossfade анимацию: {self.current_theme} → {theme}")
            
            # ШАГ 1: Делаем скриншот СТАРОЙ темы
            old_pixmap = self.grab()
            
            # ШАГ 2: Применяем НОВУЮ тему (мгновенно, но скрыто под оверлеем)
            self.current_theme = theme
            self.current_liquid_glass = liquid_glass
            self.apply_styles(theme=theme, liquid_glass=liquid_glass)
            
            # Обновляем цвета файлового чипа при смене темы
            if hasattr(self, 'file_chip_container') and self.file_chip_container.isVisible():
                is_dark = (theme == 'dark')
                if is_dark:
                    self.file_chip.setStyleSheet("""
                        #fileChip {
                            background: rgba(102, 126, 234, 0.20);
                            border: 1px solid rgba(102, 126, 234, 0.40);
                            border-radius: 14px;
                            padding: 2px 6px;
                        }
                    """)
                    self.file_chip_label.setStyleSheet("color: #8fa3f5; background: transparent; border: none;")
                    self.file_chip_remove_btn.setStyleSheet("""
                        QPushButton {
                            background: rgba(102, 126, 234, 0.25);
                            color: #8fa3f5;
                            border: none;
                            border-radius: 11px;
                        }
                        QPushButton:hover {
                            background: rgba(239, 68, 68, 0.30);
                            color: #f87171;
                        }
                    """)
                else:
                    self.file_chip.setStyleSheet("""
                        #fileChip {
                            background: rgba(102, 126, 234, 0.15);
                            border: 1px solid rgba(102, 126, 234, 0.35);
                            border-radius: 14px;
                            padding: 2px 6px;
                        }
                    """)
                    self.file_chip_label.setStyleSheet("color: #667eea; background: transparent; border: none;")
                    self.file_chip_remove_btn.setStyleSheet("""
                        QPushButton {
                            background: rgba(102, 126, 234, 0.2);
                            color: #667eea;
                            border: none;
                            border-radius: 11px;
                        }
                        QPushButton:hover {
                            background: rgba(239, 68, 68, 0.25);
                            color: #ef4444;
                        }
                    """)
            
            # Обновляем стили кнопки "вниз"
            if hasattr(self, 'scroll_to_bottom_btn'):
                self.scroll_to_bottom_btn.apply_theme_styles(theme=theme, liquid_glass=liquid_glass)
            
            # Обновляем стили настроек
            if hasattr(self, 'settings_view'):
                self.settings_view.apply_settings_styles()
            
            # Принудительно обновляем всё
            self.update()
            QtWidgets.QApplication.processEvents()
            
            # ШАГ 3: Делаем скриншот НОВОЙ темы
            new_pixmap = self.grab()
            
            # ШАГ 4: Создаём два оверлея для crossfade
            # Оверлей со старой темой (будет исчезать)
            old_overlay = QtWidgets.QLabel(self)
            old_overlay.setPixmap(old_pixmap)
            old_overlay.setGeometry(0, 0, self.width(), self.height())
            old_overlay.setScaledContents(True)
            old_overlay.show()
            old_overlay.raise_()
            
            # Оверлей с новой темой (будет проявляться)
            new_overlay = QtWidgets.QLabel(self)
            new_overlay.setPixmap(new_pixmap)
            new_overlay.setGeometry(0, 0, self.width(), self.height())
            new_overlay.setScaledContents(True)
            new_overlay.show()
            new_overlay.raise_()
            
            # Эффекты прозрачности
            old_effect = QtWidgets.QGraphicsOpacityEffect(old_overlay)
            old_overlay.setGraphicsEffect(old_effect)
            old_effect.setOpacity(1.0)
            
            new_effect = QtWidgets.QGraphicsOpacityEffect(new_overlay)
            new_overlay.setGraphicsEffect(new_effect)
            new_effect.setOpacity(0.0)
            
            # ШАГ 5: Анимация crossfade
            # Старая тема исчезает
            old_fade = QtCore.QPropertyAnimation(old_effect, b"opacity")
            old_fade.setDuration(400)  # 400ms
            old_fade.setStartValue(1.0)
            old_fade.setEndValue(0.0)
            old_fade.setEasingCurve(QtCore.QEasingCurve.Type.InOutSine)
            
            # Новая тема появляется
            new_fade = QtCore.QPropertyAnimation(new_effect, b"opacity")
            new_fade.setDuration(400)  # 400ms
            new_fade.setStartValue(0.0)
            new_fade.setEndValue(1.0)
            new_fade.setEasingCurve(QtCore.QEasingCurve.Type.InOutSine)
            
            # Группируем анимации для синхронного запуска
            animation_group = QtCore.QParallelAnimationGroup(self)
            animation_group.addAnimation(old_fade)
            animation_group.addAnimation(new_fade)
            
            def on_crossfade_finished():
                # Удаляем оверлеи
                old_overlay.deleteLater()
                new_overlay.deleteLater()
                print("[SETTINGS] ✓ Crossfade анимация завершена")
                
                # Очищаем ссылки
                self._old_overlay = None
                self._new_overlay = None
                self._crossfade_group = None
            
            animation_group.finished.connect(on_crossfade_finished)
            animation_group.start()
            
            # Сохраняем ссылки
            self._crossfade_group = animation_group
            self._old_overlay = old_overlay
            self._new_overlay = new_overlay
            
        else:
            # Если тема не изменилась, просто применяем стили без анимации
            self.current_theme = theme
            self.current_liquid_glass = liquid_glass
            
            self.apply_styles(theme=theme, liquid_glass=liquid_glass)
            
            # Обновляем стили кнопки "вниз"
            if hasattr(self, 'scroll_to_bottom_btn'):
                self.scroll_to_bottom_btn.apply_theme_styles(theme=theme, liquid_glass=liquid_glass)
                print("[SETTINGS] ✓ Стили кнопки 'вниз' обновлены")
            
            # Обновляем стили настроек
            if hasattr(self, 'settings_view'):
                self.settings_view.apply_settings_styles()
        
        print("[SETTINGS] ✓ Стили успешно обновлены")


    def show_delete_panel(self, pos):
        """Показать контекстное меню при правом клике на чат"""
        item = self.chats_list.itemAt(pos)
        if not item:
            return
        
        chat_id = item.data(QtCore.Qt.ItemDataRole.UserRole)
        
        # Получаем текущую тему
        is_dark = self.current_theme == "dark"
        
        # Создаём контекстное меню
        context_menu = QtWidgets.QMenu(self)
        
        # Адаптивные стили в зависимости от темы
        if is_dark:
            context_menu.setStyleSheet("""
                QMenu {
                    background-color: rgba(30, 30, 35, 0.85);
                    border: 1px solid rgba(60, 60, 70, 0.8);
                    border-radius: 12px;
                    padding: 6px;
                }
                QMenu::item {
                    padding: 10px 20px;
                    border-radius: 8px;
                    color: #e0e0e0;
                }
                QMenu::item:selected {
                    background-color: rgba(220, 38, 38, 0.25);
                    color: #ff6b6b;
                }
            """)
        else:
            context_menu.setStyleSheet("""
                QMenu {
                    background-color: rgba(255, 255, 255, 0.72);
                    border: 1px solid rgba(255, 255, 255, 0.85);
                    border-radius: 12px;
                    padding: 6px;
                }
                QMenu::item {
                    padding: 10px 20px;
                    border-radius: 8px;
                    color: #2d3748;
                }
                QMenu::item:selected {
                    background-color: rgba(239, 68, 68, 0.15);
                    color: #dc2626;
                }
            """)
        
        # Пункт "Удалить чат"
        delete_action = context_menu.addAction("🗑️ Удалить чат")
        
        # Показываем меню и обрабатываем выбор
        action = context_menu.exec(self.chats_list.mapToGlobal(pos))
        
        if action == delete_action:
            self.delete_chat_by_id(chat_id)

    def hide_delete_panel(self):
        """Скрыть панель удаления"""
        if self.delete_panel.width() == 0:
            return
        
        anim1 = QtCore.QPropertyAnimation(self.delete_panel, b"minimumWidth")
        anim1.setDuration(200)
        anim1.setStartValue(self.delete_panel.width())
        anim1.setEndValue(0)
        anim1.setEasingCurve(QtCore.QEasingCurve.Type.InOutQuad)
        
        anim2 = QtCore.QPropertyAnimation(self.delete_panel, b"maximumWidth")
        anim2.setDuration(200)
        anim2.setStartValue(self.delete_panel.width())
        anim2.setEndValue(0)
        anim2.setEasingCurve(QtCore.QEasingCurve.Type.InOutQuad)
        
        anim1.start()
        anim2.start()

    def delete_chat_by_id(self, chat_id: int):
        """Удалить чат по ID"""
        # Подтверждение удаления
        reply = QtWidgets.QMessageBox.question(
            self, "Удаление чата",
            "Вы уверены, что хотите удалить этот чат?\nВсе сообщения будут удалены.",
            QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
        )
        
        if reply == QtWidgets.QMessageBox.StandardButton.Yes:
            # Если удаляем активный чат
            if chat_id == self.current_chat_id:
                # Создаём новый пустой чат
                new_chat_id = self.chat_manager.create_chat("Новый чат")
                self.chat_manager.set_active_chat(new_chat_id)
                self.current_chat_id = new_chat_id
            
            # Удаляем чат
            self.chat_manager.delete_chat(chat_id)
            
            # Обновляем список
            self.load_chats_list()
            self.load_current_chat()

    def delete_selected_chat(self):
        """Удалить выбранный чат (для кнопки в панели)"""
        if not self.chat_to_delete:
            return
        
        self.delete_chat_by_id(self.chat_to_delete)
        
        # Скрываем панель удаления
        self.hide_delete_panel()
        self.chat_to_delete = None

    def _cleanup_empty_chats_on_startup(self):
        """Удалить все старые чаты без пользовательских сообщений при запуске"""
        try:
            all_chats = self.chat_manager.get_all_chats()
            deleted_count = 0
            
            for chat in all_chats:
                chat_id = chat['id']
                # Получаем сообщения чата
                messages = self.chat_manager.get_chat_messages(chat_id, limit=100)
                
                # Проверяем есть ли хотя бы одно сообщение от пользователя
                has_user_messages = any(role == "user" for role, content, created in messages)
                
                if not has_user_messages:
                    # Удаляем пустой чат
                    print(f"[CLEANUP] Удаляю пустой чат ID={chat_id}, title='{chat['title']}'")
                    self.chat_manager.delete_chat(chat_id)
                    deleted_count += 1
                else:
                    print(f"[CLEANUP] Сохраняю чат ID={chat_id} - есть сообщения пользователя")
            
            if deleted_count > 0:
                print(f"[CLEANUP] ✓ Удалено пустых чатов: {deleted_count}")
            else:
                print(f"[CLEANUP] ✓ Пустых чатов не найдено")
                
        except Exception as e:
            print(f"[CLEANUP] ✗ Ошибка при очистке: {e}")
            import traceback
            traceback.print_exc()
    
    def load_chats_list(self):
        """Загрузить список чатов"""
        self.chats_list.clear()
        chats = self.chat_manager.get_all_chats()
        
        for chat in chats:
            item = QtWidgets.QListWidgetItem(chat['title'])
            item.setData(QtCore.Qt.ItemDataRole.UserRole, chat['id'])
            self.chats_list.addItem(item)
            
            if chat['is_active']:
                self.chats_list.setCurrentItem(item)

    def load_current_chat(self):
        """Загрузить текущий активный чат (УЛУЧШЕНО: загрузка файлов)"""
        if not self.current_chat_id:
            return
        
        print(f"[LOAD_CURRENT] ════════════════════════════════════════")
        print(f"[LOAD_CURRENT] Загрузка чата ID={self.current_chat_id}")
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 1: ОЧИСТКА ФАЙЛОВ ИЗ ПРЕДЫДУЩЕГО ЧАТА
        # ═══════════════════════════════════════════════════════════════
        if self.attached_files:
            print(f"[LOAD_CURRENT] 🗑️ Очищаем {len(self.attached_files)} старых файлов")
            self.attached_files = []
            self.update_file_chips()
        
        # ✅ КРИТИЧНО: Полностью очищаем все виджеты сообщений
        # Структура layout: [message1, message2, ..., stretch(1)]
        # Удаляем только виджеты сообщений, оставляем stretch в конце
        items_to_remove = []
        for i in range(self.messages_layout.count()):
            item = self.messages_layout.itemAt(i)
            if item and item.widget():
                widget = item.widget()
                # Удаляем все виджеты сообщений (они имеют атрибут speaker)
                if hasattr(widget, 'speaker'):
                    items_to_remove.append(widget)
        
        # Удаляем собранные виджеты
        for widget in items_to_remove:
            self.messages_layout.removeWidget(widget)
            widget.deleteLater()
        
        print(f"[LOAD_CURRENT] Удалено виджетов: {len(items_to_remove)}")
        
        # Загружаем сообщения текущего чата (оптимизировано: 30 вместо 50)
        messages = self.chat_manager.get_chat_messages(self.current_chat_id, limit=30)
        
        # Проверяем состояние кнопки "Очистить"
        self.clear_btn.setEnabled(True)
        self.clear_btn.setStyleSheet("")
        
        # Показываем приветствие если чат пустой
        if len(messages) == 0:
            welcome_msg = "Привет! Готов к работе."
            self.add_message_widget("Система", welcome_msg, add_controls=False)
            print(f"[LOAD_CURRENT] ✅ Загрузка завершена (пустой чат)")
            print(f"[LOAD_CURRENT] ════════════════════════════════════════")
            return
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 2: ЗАГРУЗКА ФАЙЛОВ ДЛЯ ТЕКУЩЕГО ЧАТА
        # ═══════════════════════════════════════════════════════════════
        chat_files = self.load_chat_files(self.current_chat_id)
        if chat_files:
            print(f"[LOAD_CURRENT] 📁 Загружено {len(chat_files)} файлов для чата {self.current_chat_id}")
            self.attached_files = chat_files
            self.update_file_chips()
        else:
            print(f"[LOAD_CURRENT] ℹ️ Нет сохранённых файлов для чата {self.current_chat_id}")
        
        # Определяем какие сообщения показывать с анимацией (последние 2 для ускорения)
        total_messages = len(messages)
        
        # Загружаем существующие сообщения
        for idx, (role, content, created) in enumerate(messages):
            speaker = "Вы" if role == "user" else ASSISTANT_NAME
            if role not in ["user", "assistant"]:
                continue
            
            # Проверяем, входит ли сообщение в последние 2 (оптимизировано)
            is_recent = (total_messages - idx) <= 2
            
            # Создаём виджет БЕЗ анимации (для всех)
            message_widget = MessageWidget(
                speaker, content, add_controls=True,
                language=self.current_language,
                main_window=self,
                parent=self.messages_widget,
                thinking_time=0
            )
            
            # Для старых сообщений сразу убираем анимацию
            if not is_recent:
                if hasattr(message_widget, 'opacity_effect'):
                    message_widget.opacity_effect.setOpacity(1.0)
                # Отключаем анимации появления
                if hasattr(message_widget, 'fade_in_animation'):
                    message_widget.fade_in_animation.stop()
                if hasattr(message_widget, 'pos_animation'):
                    message_widget.pos_animation.stop()
            else:
                # Для последних 2 - анимация включена по умолчанию (оптимизировано)
                pass
            
            # Добавляем в layout (stretch уже удалён, добавляем в конец)
            self.messages_layout.addWidget(message_widget)
            
            # Запускаем анимацию для последних 2 сообщений (оптимизировано)
            if is_recent and not IS_WINDOWS and hasattr(message_widget, '_start_appear_animation'):
                # Запускаем с плавной задержкой для красивого каскадного эффекта (150ms между сообщениями)
                # Увеличена задержка под новую 800ms анимацию
                QtCore.QTimer.singleShot(60 + idx * 150, message_widget._start_appear_animation)
        
        # ═══════════════════════════════════════════════════════════════
        # АВТОМАТИЧЕСКИЙ СКРОЛЛ ВНИЗ ПОСЛЕ ЗАГРУЗКИ ЧАТА
        # ═══════════════════════════════════════════════════════════════
        # Полное обновление layout (invalidate гарантирует пересчёт ВСЕГО дерева)
        self.messages_layout.invalidate()
        self.messages_layout.activate()
        self.messages_widget.updateGeometry()
        QtWidgets.QApplication.processEvents()
        
        # Скроллим вниз с задержкой 350ms:
        # - последние 2 сообщения запускают анимацию в 60ms и 210ms
        # - 350ms гарантирует что layout успел пересчитать размеры ДО скролла
        def scroll_to_bottom_delayed():
            # Повторный invalidate + activate — layout ГАРАНТИРОВАННО завершён
            self.messages_layout.invalidate()
            self.messages_layout.activate()
            self.messages_widget.updateGeometry()
            QtWidgets.QApplication.processEvents()
            scrollbar = self.scroll_area.verticalScrollBar()
            scrollbar.setValue(scrollbar.maximum())
            # Обновляем видимость кнопки "вниз"
            if hasattr(self, 'scroll_to_bottom_btn'):
                self.update_scroll_button_visibility()
        
        QtCore.QTimer.singleShot(350, scroll_to_bottom_delayed)

    def create_new_chat(self):
        """Создать новый чат (УЛУЧШЕНО: с плавной анимацией кнопки)"""
        
        # ═══════════════════════════════════════════════════════════════
        # АНИМАЦИЯ КНОПКИ "+ Новый чат" (bounce эффект)
        # ═══════════════════════════════════════════════════════════════
        # Находим кнопку нового чата
        new_chat_btn = None
        for i in range(self.sidebar.layout().count()):
            widget = self.sidebar.layout().itemAt(i).widget()
            if widget and isinstance(widget, QtWidgets.QPushButton):
                if "Новый чат" in widget.text() or widget.text() == "+ Новый чат":
                    new_chat_btn = widget
                    break
        
        if new_chat_btn:
            # Создаём анимацию масштабирования
            if not hasattr(self, '_new_chat_btn_press_anim'):
                self._new_chat_btn_press_anim = QtCore.QPropertyAnimation(new_chat_btn, b"geometry")
            
            original_geo = new_chat_btn.geometry()
            center_x = original_geo.center().x()
            center_y = original_geo.center().y()
            
            # Уменьшаем до 0.92 scale для более тонкого эффекта
            scale_factor = 0.92
            new_width = int(original_geo.width() * scale_factor)
            new_height = int(original_geo.height() * scale_factor)
            pressed_geo = QtCore.QRect(
                center_x - new_width // 2,
                center_y - new_height // 2,
                new_width,
                new_height
            )
            
            # Быстрое нажатие
            self._new_chat_btn_press_anim.stop()
            self._new_chat_btn_press_anim.setDuration(100)
            self._new_chat_btn_press_anim.setStartValue(original_geo)
            self._new_chat_btn_press_anim.setEndValue(pressed_geo)
            self._new_chat_btn_press_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutQuad)
            
            # После нажатия - возврат с bounce
            def on_new_chat_press_finished():
                if not hasattr(self, '_new_chat_btn_release_anim'):
                    self._new_chat_btn_release_anim = QtCore.QPropertyAnimation(new_chat_btn, b"geometry")
                
                self._new_chat_btn_release_anim.setDuration(350)
                self._new_chat_btn_release_anim.setStartValue(pressed_geo)
                self._new_chat_btn_release_anim.setEndValue(original_geo)
                # OutBack создаёт лёгкий spring bounce эффект
                self._new_chat_btn_release_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutBack)
                self._new_chat_btn_release_anim.start()
            
            try:
                self._new_chat_btn_press_anim.finished.disconnect()
            except:
                pass
            self._new_chat_btn_press_anim.finished.connect(on_new_chat_press_finished)
            self._new_chat_btn_press_anim.start()
            
            print("[NEW_CHAT] ✨ Запущена анимация кнопки нового чата")
        
        # ═══════════════════════════════════════════════════════════════
        # ЛОГИКА ОЧИСТКИ ПУСТЫХ ЧАТОВ
        # ═══════════════════════════════════════════════════════════════
        # Проверяем текущий чат - если он пустой, удаляем его перед созданием нового
        if self.current_chat_id:
            messages = self.chat_manager.get_chat_messages(self.current_chat_id, limit=10)
            user_messages = [msg for msg in messages if msg[0] == "user"]
            
            # Если в текущем чате нет сообщений пользователя - удаляем его
            if len(user_messages) == 0:
                print(f"[NEW_CHAT] Удаляем пустой чат {self.current_chat_id} перед созданием нового")
                try:
                    self.chat_manager.delete_chat(self.current_chat_id)
                except Exception as e:
                    print(f"[NEW_CHAT] Ошибка удаления пустого чата: {e}")
        
        # Создаём новый чат
        chat_id = self.chat_manager.create_chat("Новый чат")
        self.chat_manager.set_active_chat(chat_id)
        self.current_chat_id = chat_id
        
        # Обновляем флаги стартового чата
        self.startup_chat_id = chat_id
        self.startup_chat_has_messages = False
        
        self.load_chats_list()
        self.load_current_chat()
        
        # Закрываем sidebar после создания с небольшой задержкой для анимации
        QtCore.QTimer.singleShot(150, self.toggle_sidebar)
        
        print(f"[NEW_CHAT] ✓ Создан новый чат ID={chat_id}")

    def switch_chat(self, item):
        """Переключить чат с полной остановкой генерации (УЛУЧШЕНО: очистка файлов)"""
        chat_id = item.data(QtCore.Qt.ItemDataRole.UserRole)
        
        print(f"[SWITCH_CHAT] ════════════════════════════════════════")
        print(f"[SWITCH_CHAT] Переключение с чата {self.current_chat_id} на {chat_id}")
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 1: ПОЛНАЯ ОСТАНОВКА ГЕНЕРАЦИИ (КРИТИЧНО!)
        # ═══════════════════════════════════════════════════════════════
        if self.is_generating:
            print(f"[SWITCH_CHAT] ⚠️ Останавливаем активную генерацию перед переключением")
            
            # Останавливаем флаг генерации
            self.is_generating = False
            
            # Отменяем воркер
            if hasattr(self, 'current_worker'):
                self.current_worker = None
            
            # Останавливаем анимацию статуса
            if hasattr(self, 'stop_status_animation'):
                self.stop_status_animation()
            
            # Очищаем статус
            self.status_label.setText("")
            
            # Сбрасываем UI
            self.input_field.setEnabled(True)
            self.send_btn.setEnabled(True)
            self.send_btn.setText("→")
            
            print(f"[SWITCH_CHAT] ✓ Генерация остановлена")
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 2: ОЧИСТКА ПРИКРЕПЛЁННЫХ ФАЙЛОВ ИЗ СТАРОГО ЧАТА
        # ═══════════════════════════════════════════════════════════════
        if self.attached_files:
            print(f"[SWITCH_CHAT] 🗑️ Очищаем {len(self.attached_files)} файлов из старого чата")
            self.attached_files = []
            self.update_file_chips()
        
        # ═══ ЛОГИКА ОЧИСТКИ ПУСТЫХ ЧАТОВ ═══
        # Если переключаемся с пустого чата - удаляем его
        if self.current_chat_id and chat_id != self.current_chat_id:
            messages = self.chat_manager.get_chat_messages(self.current_chat_id, limit=10)
            user_messages = [msg for msg in messages if msg[0] == "user"]
            
            # Если в текущем чате нет сообщений пользователя - удаляем его
            if len(user_messages) == 0:
                print(f"[SWITCH_CHAT] Удаляем пустой чат {self.current_chat_id} при переключении")
                try:
                    self.chat_manager.delete_chat(self.current_chat_id)
                except Exception as e:
                    print(f"[SWITCH_CHAT] Ошибка удаления пустого чата: {e}")
        
        # ✅ GUARD: Очищаем поле ввода при переключении
        try:
            self.input_field.clear()
        except Exception:
            pass
        
        self.chat_manager.set_active_chat(chat_id)
        self.current_chat_id = chat_id
        
        # Обновляем флаги стартового чата
        self.startup_chat_id = None
        self.startup_chat_has_messages = False
        
        self.load_chats_list()
        self.load_current_chat()
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 3: ЗАГРУЗКА ФАЙЛОВ ДЛЯ НОВОГО ЧАТА
        # ═══════════════════════════════════════════════════════════════
        chat_files = self.load_chat_files(chat_id)
        if chat_files:
            print(f"[SWITCH_CHAT] 📁 Загружено {len(chat_files)} файлов для чата {chat_id}")
            self.attached_files = chat_files
            self.update_file_chips()
        else:
            print(f"[SWITCH_CHAT] ℹ️ Нет сохранённых файлов для чата {chat_id}")
        
        print(f"[SWITCH_CHAT] ✅ Переключение завершено")
        print(f"[SWITCH_CHAT] ════════════════════════════════════════")
        
        # Закрываем sidebar после переключения
        self.toggle_sidebar()
    def add_message_widget(self, speaker: str, text: str, add_controls: bool = False, thinking_time: float = 0, action_history: list = None, attached_files: list = None):
        """
        Добавить виджет сообщения в layout БЕЗ АВТОСКРОЛЛА.
        
        УМНОЕ ОБНОВЛЕНИЕ В ЗАВИСИМОСТИ ОТ ПОЗИЦИИ ПОЛЬЗОВАТЕЛЯ:
        ════════════════════════════════════════════════════════════
        
        ЛОГИКА:
        • Пользователь ВНИЗУ → Обновляем layout с периодической синхронизацией
        • Пользователь НЕ внизу (читает историю) → МИНИМАЛЬНОЕ обновление
        
        МИНИМАЛЬНОЕ ОБНОВЛЕНИЕ (когда пользователь читает историю):
        ✓ Добавляем виджет в layout (addWidget)
        ✓ Показываем виджет (show)
        ✓ НЕ обновляем viewport (чтобы не мешать чтению)
        ✓ НЕ вызываем processEvents (избегаем "застревания")
        ✓ Пузыри не мешают скроллу
        
        ПЕРИОДИЧЕСКАЯ СИНХРОНИЗАЦИЯ (когда пользователь внизу):
        ✓ Каждое 5-е сообщение → полное обновление
        ✓ Остальные → быстрое обновление
        ✓ Viewport обновляется корректно
        
        РЕЗУЛЬТАТ:
        • Когда читаешь историю → новые сообщения НЕ мешают
        • Когда внизу → всё обновляется нормально
        • БЕЗ автоскролла
        • БЕЗ "застревания" пузырей
        ════════════════════════════════════════════════════════════
        """
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 1: СОХРАНЯЕМ ТЕКУЩУЮ ПОЗИЦИЮ СКРОЛЛА
        # ═══════════════════════════════════════════════════════════════
        scrollbar = self.scroll_area.verticalScrollBar()
        old_value = scrollbar.value()
        old_max = scrollbar.maximum()
        was_at_bottom = (old_max == 0) or (old_value >= old_max - 10)
        
        # ═══════════════════════════════════════════════════════════════
        # ПОДСЧЁТ КОЛИЧЕСТВА СООБЩЕНИЙ
        # ═══════════════════════════════════════════════════════════════
        message_count = 0
        for i in range(self.messages_layout.count()):
            item = self.messages_layout.itemAt(i)
            if item and item.widget() and hasattr(item.widget(), 'speaker'):
                message_count += 1
        
        # ═══════════════════════════════════════════════════════════════
        # ОПРЕДЕЛЯЕМ РЕЖИМ ОБНОВЛЕНИЯ
        # ═══════════════════════════════════════════════════════════════
        FULL_UPDATE_INTERVAL = 5
        is_full_update = (message_count % FULL_UPDATE_INTERVAL == 0)
        
        # Создаём виджет
        message_widget = MessageWidget(
            speaker, text, add_controls,
            language=self.current_language,
            main_window=self,
            parent=self.messages_widget,
            thinking_time=thinking_time,
            action_history=action_history,
            attached_files=attached_files
        )
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 2: ДОБАВЛЕНИЕ В LAYOUT
        # ═══════════════════════════════════════════════════════════════
        self.messages_layout.addWidget(message_widget)
        message_widget.show()
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 3: ОБНОВЛЕНИЕ LAYOUT (ЗАВИСИТ ОТ ПОЗИЦИИ ПОЛЬЗОВАТЕЛЯ)
        # ═══════════════════════════════════════════════════════════════
        
        if not was_at_bottom:
            # ──────────────────────────────────────────────────────────
            # ПОЛЬЗОВАТЕЛЬ ЧИТАЕТ ИСТОРИЮ (НЕ внизу)
            # ──────────────────────────────────────────────────────────
            # МИНИМАЛЬНОЕ обновление - только добавили виджет
            # НЕ трогаем viewport чтобы не мешать чтению
            print(f"[ADD_MESSAGE] 📖 Минимальное обновление (пользователь читает историю)")
            
            # НЕ вызываем activate/update/processEvents
            # Виджет добавлен в layout, но viewport не обновляется
            # Когда пользователь вернётся вниз - всё обновится
            
        else:
            # ──────────────────────────────────────────────────────────
            # ПОЛЬЗОВАТЕЛЬ ВНИЗУ (видит новые сообщения)
            # ──────────────────────────────────────────────────────────
            # Периодическая синхронизация
            
            if is_full_update:
                print(f"[ADD_MESSAGE] 🔄 ПОЛНОЕ обновление (сообщение #{message_count + 1})")
                
                # ПОЛНОЕ обновление с синхронизацией
                self.messages_layout.invalidate()
                self.messages_layout.activate()
                self.messages_widget.updateGeometry()
                
                # Синхронная отрисовка
                self.scroll_area.viewport().repaint()
                QtWidgets.QApplication.processEvents()
                
            else:
                print(f"[ADD_MESSAGE] ⚡ БЫСТРОЕ обновление (сообщение #{message_count + 1})")
                
                # БЫСТРОЕ обновление без processEvents
                self.messages_layout.activate()
                self.messages_widget.updateGeometry()
                self.scroll_area.viewport().update()
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 4: ВОССТАНАВЛИВАЕМ ПОЗИЦИЮ СКРОЛЛА (БЕЗ АВТОСКРОЛЛА)
        # ═══════════════════════════════════════════════════════════════
        if old_max > 0 and not was_at_bottom:
            # Если пользователь НЕ был внизу - сохраняем его позицию
            scrollbar.setValue(old_value)
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 5: ОБНОВЛЯЕМ КНОПКУ "ВНИЗ"
        # ═══════════════════════════════════════════════════════════════
        if hasattr(self, 'scroll_to_bottom_btn'):
            self.update_scroll_button_visibility()
        
        # Анимация появления (не влияет на layout)
        if not IS_WINDOWS and hasattr(message_widget, '_start_appear_animation'):
            QtCore.QMetaObject.invokeMethod(
                message_widget,
                "_start_appear_animation",
                QtCore.Qt.ConnectionType.QueuedConnection
            )
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 6: УПРАВЛЕНИЕ ВИДИМОСТЬЮ КНОПОК РЕГЕНЕРАЦИИ
        # Показываем только у последнего сообщения ассистента
        # ═══════════════════════════════════════════════════════════════
        if speaker != "Вы" and speaker != "Система":
            # Отложенное управление кнопками через 100ms (минимальная задержка)
            def manage_regenerate_buttons():
                # Скрываем кнопки регенерации у всех предыдущих сообщений
                for i in range(self.messages_layout.count()):
                    item = self.messages_layout.itemAt(i)
                    if item and item.widget() and hasattr(item.widget(), 'speaker'):
                        widget = item.widget()
                        # Проверяем что это сообщение ассистента
                        if widget.speaker != "Вы" and widget.speaker != "Система":
                            # Если это не текущий виджет - скрываем кнопку
                            if widget != message_widget and hasattr(widget, 'regenerate_button') and widget.regenerate_button:
                                widget.regenerate_button.setVisible(False)
                            # Если это текущий виджет - показываем кнопку
                            elif widget == message_widget and hasattr(widget, 'regenerate_button') and widget.regenerate_button:
                                widget.regenerate_button.setVisible(True)
                
                print(f"[ADD_MESSAGE] ✓ Управление кнопками регенерации завершено")
            
            # Запускаем управление кнопками отложенно
            QtCore.QTimer.singleShot(100, manage_regenerate_buttons)
    
    def send_message(self):
        """Отправка сообщения пользователя
        
        ВАЖНО: Всегда берёт текст ТОЛЬКО из поля ввода (self.input_field.text())
        Никогда не использует старые значения или данные из других чатов
        """
        
        # Если идёт генерация - останавливаем БЕЗ возврата текста
        if self.is_generating:
            print(f"[SEND] ═══════════════════════════════════════════")
            print(f"[SEND] ОСТАНОВКА ГЕНЕРАЦИИ")
            
            self.is_generating = False
            
            # Помечаем текущий worker как отменённый
            if hasattr(self, 'current_worker') and self.current_worker:
                self.current_worker._cancelled = True
                print(f"[SEND] ✓ Worker помечен как отменённый")
            
            self.current_worker = None
            
            # Останавливаем анимацию статуса
            if hasattr(self, 'stop_status_animation'):
                self.stop_status_animation()
            
            # НЕ возвращаем текст в поле - оставляем пустым
            self.input_field.setEnabled(True)
            self.send_btn.setEnabled(True)
            self.send_btn.setText("→")
            
            # Очищаем статус сразу (без задержки)
            self.status_label.setText("")
            
            print(f"[SEND] ✅ Генерация остановлена пользователем")
            print(f"[SEND] ═══════════════════════════════════════════")
            return
        
        global CURRENT_LANGUAGE
        # ИСТОЧНИК ИСТИНЫ - текст из поля ввода
        user_text = self.input_field.text().strip()
        if not user_text:
            return
        
        print(f"[SEND] Отправка сообщения: {user_text[:50]}...")
        
        # Проверка орфографии убрана - нейросеть сама переспросит если не поймёт
        # ════════════════════════════════════════════════════════════════
        # ИСПРАВЛЕНИЕ №3: Проверка на короткие подтверждения
        # ════════════════════════════════════════════════════════════════
        is_acknowledgment, acknowledgment_response = is_short_acknowledgment(user_text)
        if is_acknowledgment:
            print(f"[SEND] Обнаружено короткое подтверждение: {user_text} → {acknowledgment_response}")
            
            # Добавляем сообщение пользователя
            self.input_field.clear()
            self.add_message_widget("Вы", user_text, add_controls=True)
            self.chat_manager.save_message(self.current_chat_id, "user", user_text)
            
            # Отвечаем немедленно без вызова AI
            self.add_message_widget(ASSISTANT_NAME, acknowledgment_response, add_controls=False)
            self.chat_manager.save_message(self.current_chat_id, "assistant", acknowledgment_response)
            
            # Обновляем название чата если это первое сообщение
            try:
                messages = self.chat_manager.get_chat_messages(self.current_chat_id, limit=5)
                if messages and len(messages) == 2:
                    first_user_msg = messages[0][1] if len(messages[0]) > 1 and messages[0][0] == "user" else ""
                    if first_user_msg and isinstance(first_user_msg, str) and len(first_user_msg) > 0:
                        chat_title = first_user_msg[:40]
                        if len(first_user_msg) > 40:
                            chat_title += "..."
                        chat_title = chat_title[0].upper() + chat_title[1:] if len(chat_title) > 0 else "Новый чат"
                        self.chat_manager.update_chat_title(self.current_chat_id, chat_title)
                        self.load_chats_list()
            except Exception as e:
                print(f"[SEND] Ошибка обновления названия чата: {e}")
            
            return  # Завершаем метод, не вызывая AI
        # ════════════════════════════════════════════════════════════════



        should_forget = detect_forget_command(user_text)
        if should_forget:
            print("[SEND] Обнаружена команда забыть!")
            
            # Добавляем сообщение пользователя в чат
            self.input_field.clear()
            self.add_message_widget("Вы", user_text, add_controls=True)
            self.chat_manager.save_message(self.current_chat_id, "user", user_text)
            
            # Извлекаем цель забывания
            forget_info = extract_forget_target(user_text)
            
            if forget_info["forget_all"]:
                # ПОЛНАЯ ОЧИСТКА
                print("[SEND] Выполняю полную очистку памяти...")
                
                # Очищаем сообщения чата
                self.chat_manager.clear_chat_messages(self.current_chat_id)
                
                # Очищаем контекстную память
                try:
                    from context_memory_manager import ContextMemoryManager
                    context_mgr = ContextMemoryManager()
                    context_mgr.clear_context_memory(self.current_chat_id)
                    print(f"[SEND] ✓ Контекстная память очищена для chat_id={self.current_chat_id}")
                except Exception as e:
                    print(f"[SEND] ✗ Ошибка очистки контекстной памяти: {e}")
                
                # Сбрасываем название на "Новый чат"
                self.chat_manager.update_chat_title(self.current_chat_id, "Новый чат")
                
                # Обновляем список чатов
                self.load_chats_list()
                
                # Ответ от имени AI (а не системы!)
                if self.current_language == "russian":
                    ai_response = "Хорошо, я забыл! 😊"
                else:
                    ai_response = "Okay, I've forgotten! 😊"
                
            else:
                # СЕЛЕКТИВНОЕ УДАЛЕНИЕ
                target = forget_info["target"]
                print(f"[SEND] Выполняю селективное удаление: '{target}'")
                
                try:
                    from context_memory_manager import ContextMemoryManager
                    context_mgr = ContextMemoryManager()
                    
                    # Выполняем селективное удаление
                    result = selective_forget_memory(
                        self.current_chat_id, 
                        target, 
                        context_mgr, 
                        self.chat_manager
                    )
                    
                    if result["success"]:
                        print(f"[SEND] ✓ {result['message']}")
                        
                        # Обновляем список чатов
                        self.load_chats_list()
                        
                        # Формируем ответ в зависимости от результата
                        if result["deleted_count"] > 0:
                            if self.current_language == "russian":
                                ai_response = f"✓ Готово! Я забыл информацию о '{target}'. {result['message']}"
                            else:
                                ai_response = f"✓ Done! I've forgotten information about '{target}'. {result['message']}"
                        else:
                            if self.current_language == "russian":
                                ai_response = f"Я не нашёл упоминаний '{target}' в нашей истории. Возможно, мы не обсуждали это."
                            else:
                                ai_response = f"I couldn't find any mentions of '{target}' in our history. Perhaps we didn't discuss this."
                    else:
                        if self.current_language == "russian":
                            ai_response = f"❌ Произошла ошибка при удалении: {result['message']}"
                        else:
                            ai_response = f"❌ An error occurred during deletion: {result['message']}"
                        
                except Exception as e:
                    print(f"[SEND] ✗ Ошибка селективного удаления: {e}")
                    import traceback
                    traceback.print_exc()
                    
                    if self.current_language == "russian":
                        ai_response = f"❌ Не удалось забыть '{target}': {e}"
                    else:
                        ai_response = f"❌ Failed to forget '{target}': {e}"
            
            self.add_message_widget(ASSISTANT_NAME, ai_response, add_controls=False)
            self.chat_manager.save_message(self.current_chat_id, "assistant", ai_response)
            return

        language_switch = detect_language_switch(user_text)
        if language_switch and language_switch != CURRENT_LANGUAGE:
            CURRENT_LANGUAGE = language_switch
            self.current_language = language_switch

            if language_switch == "english":
                notification = "✓ Language switched to English"
            else:
                notification = "✓ Язык изменён на русский"

            self.add_message_widget("Система", notification, add_controls=False)

        self.current_user_message = user_text
        
        # ═══════════════════════════════════════════════════════════
        # УМНАЯ АДАПТИВНАЯ СИСТЕМА ВЕБ-ПОИСКА
        # ═══════════════════════════════════════════════════════════
        
        # ═══════════════════════════════════════════════════════════
        # ВАЖНО: Если есть прикреплённые файлы - НЕ использовать веб-поиск!
        # ═══════════════════════════════════════════════════════════
        if self.attached_files:
            print(f"[SEND] 📎 Обнаружены прикреплённые файлы ({len(self.attached_files)})")
            print("[SEND] ✗ Веб-поиск ОТКЛЮЧЁН (есть файлы для анализа)")
            actual_use_search = False
        else:
            # Получаем историю чата для контекстного анализа
            chat_history = self.chat_manager.get_chat_messages(self.current_chat_id, limit=5)
            
            # Анализируем намерение пользователя с учётом контекста
            intent_result = analyze_intent_for_search(user_text, forced_search=self.use_search, chat_history=chat_history)
            
            # ПРИОРИТЕТ: Принудительный поиск переопределяет всё
            if intent_result["forced"]:
                print("[SEND] 🔴 FORCED SEARCH MODE - поиск обязателен (пользователь нажал кнопку)")
                actual_use_search = True
            elif intent_result["requires_search"]:
                print(f"[SEND] ✓ Автоматический поиск активирован (уверенность: {intent_result['confidence']:.2f})")
                print(f"[SEND] Причина: {intent_result['reason']}")
                actual_use_search = True
                # НЕ сохраняем self.use_search = True - это должен делать только пользователь!
            else:
                print("[SEND] ✗ Поиск не требуется")
                actual_use_search = False  # Явно отключаем поиск
        
        # Адаптируем deep_thinking в зависимости от режима AI
        if self.ai_mode == AI_MODE_FAST:
            actual_deep_thinking = False
        elif self.ai_mode == AI_MODE_THINKING:
            actual_deep_thinking = True
        elif self.ai_mode == AI_MODE_PRO:
            actual_deep_thinking = True  # В режиме "Про" всегда используем углублённое мышление
        else:
            actual_deep_thinking = self.deep_thinking  # Fallback на старое значение
        
        print(f"[SEND] Режим AI: {self.ai_mode}")
        print(f"[SEND] Deep thinking: {actual_deep_thinking}")
        print(f"[SEND] Search enabled: {actual_use_search}")
        
        # Сохраняем текущие режимы для восстановления при редактировании
        self.last_message_deep_thinking = self.deep_thinking
        self.last_message_use_search = actual_use_search
        
        # ═══════════════════════════════════════════════════════════════════════════
        # СОХРАНЕНИЕ ПАРАМЕТРОВ ДЛЯ PIPELINE
        # ═══════════════════════════════════════════════════════════════════════════
        # Сохраняем параметры для использования в pipeline
        self.current_ai_mode = self.ai_mode
        self.current_use_search = actual_use_search
        self.current_deep_thinking = actual_deep_thinking
        
        # Проверяем режим редактирования
        # Проверяем режим редактирования
        if not self.is_editing:
            # Обычная отправка - добавляем сообщение
            self.input_field.clear()
            
            # Плавно удаляем системное приветствие если это первое сообщение
            if self.messages_layout.count() == 2:  # Только stretch + приветствие
                first_widget = self.messages_layout.itemAt(0).widget()
                if first_widget and hasattr(first_widget, 'speaker') and first_widget.speaker == "Система":
                    # Запускаем fade-out для приветствия
                    first_widget.fade_out_and_delete()
                    print("[SEND] Системное приветствие плавно удаляется")
            
            self.add_message_widget("Вы", user_text, add_controls=True,
                                     attached_files=[os.path.basename(f) for f in self.attached_files] if self.attached_files else None)
            self.chat_manager.save_message(self.current_chat_id, "user", user_text)
            
            # ═══ ЛОГИКА СТАРТОВОГО ЧАТА ═══
            # Если это стартовый чат и первое сообщение - помечаем что он больше не пустой
            if hasattr(self, 'startup_chat_id') and self.current_chat_id == self.startup_chat_id:
                self.startup_chat_has_messages = True
                print(f"[STARTUP_CHAT] Стартовый чат {self.startup_chat_id} теперь содержит сообщения")
            
            # ═══════════════════════════════════════════════════════════════════════════
            # ЗАПУСК ПОЭТАПНОГО STATUS PIPELINE В НИЖНЕМ ЛЕВОМ УГЛУ
            # ═══════════════════════════════════════════════════════════════════════════
            # ЭТАП 1: Обработка запроса (немедленно)
            # ✅ КРИТИЧНО: Очищаем перед установкой нового текста
            self.status_label.clear()
            self.status_label.setText("обрабатываю запрос…")
            print(f"[STATUS_PIPELINE] Этап 1: обрабатываю запрос…")
            
            # ЭТАП 2: Анализ (через 300ms)
            QtCore.QTimer.singleShot(300, lambda: self._status_pipeline_analyzing())
            
            print("[SEND] Новое сообщение добавлено")
        else:
            # Режим редактирования - НЕ добавляем сообщение, оно уже было удалено
            self.input_field.clear()
            self.add_message_widget("Вы", user_text, add_controls=True,
                                     attached_files=[os.path.basename(f) for f in self.attached_files] if self.attached_files else None)
            self.chat_manager.save_message(self.current_chat_id, "user", user_text)
            
            # Запуск pipeline при регенерации
            # ✅ КРИТИЧНО: Очищаем перед установкой нового текста
            self.status_label.clear()
            self.status_label.setText("обрабатываю запрос…")
            print(f"[STATUS_PIPELINE] Регенерация - Этап 1: обрабатываю запрос…")
            QtCore.QTimer.singleShot(300, lambda: self._status_pipeline_analyzing())
            
            # Сбрасываем флаг редактирования
            self.is_editing = False
            self.editing_message_text = ""
            print("[SEND] Отредактированное сообщение отправлено")

        self.input_field.setEnabled(False)
        self.send_btn.setText("⏸")
        self.send_btn.setEnabled(True)
        self.is_generating = True

        # ═══════════════════════════════════════════════════════════
        # ДВУХФАЗНЫЙ РЕЖИМ ОТВЕТА
        # ═══════════════════════════════════════════════════════════
        
        # ФАЗА 1: Быстрый предварительный ответ (если НЕ используется поиск)
        if not actual_use_search and not self.deep_thinking:
            print("[SEND] 📝 ФАЗА 1: Предоставляем быстрый ответ без поиска")
        # Запускаем анимацию точек
        self.start_status_animation()
        
        # Запускаем таймер обдумывания
        self.thinking_start_time = time.time()

        # Запускаем воркер с ПРАВИЛЬНЫМИ флагами и режимом AI
        worker = AIWorker(user_text, self.current_language, actual_deep_thinking, actual_use_search, False, self.chat_manager, self.current_chat_id, self.attached_files, self.ai_mode)
        worker._cancelled = False  # Флаг отмены генерации
        worker.signals.finished.connect(self.handle_response)
        self.current_worker = worker  # Сохраняем ссылку на текущего воркера
        
        # ✅ ИСПРАВЛЕНИЕ: Сохраняем worker в список для предотвращения удаления signals
        self.active_workers.append(worker)
        # Очищаем список от завершённых workers (максимум 5)
        if len(self.active_workers) > 5:
            self.active_workers = self.active_workers[-5:]
        
        self.threadpool.start(worker)
        print(f"[SEND] Запущен воркер генерации (search={actual_use_search}, deep={actual_deep_thinking}, mode={self.ai_mode})")
        
        # Очищаем прикреплённые файлы после отправки
        if self.attached_files:
            print(f"[SEND] Файлы отправлены в модель: {', '.join([os.path.basename(f) for f in self.attached_files])}")
            self.clear_attached_file()  # Очищаем все файлы

    def handle_response(self, response: str):
        """Обработка ответа AI с полной защитой от ошибок (УЛУЧШЕНО: проверка отмены)"""
        try:
            # ✅ GUARD 1: СТРОГАЯ проверка - игнорируем сообщения для другого чата
            # Это предотвращает появление "чужих" сообщений при переключении чатов
            if hasattr(self, 'current_worker'):
                # Если воркер был отменён (current_worker = None), игнорируем его ответ
                if self.current_worker is None:
                    print(f"[HANDLE_RESPONSE] ⚠️ Игнорируем ответ отменённого воркера (current_worker = None)")
                    return
                
                # ✅ GUARD 1.5: Проверяем флаг отмены в worker
                if hasattr(self.current_worker, '_cancelled') and self.current_worker._cancelled:
                    print(f"[HANDLE_RESPONSE] ⚠️ Игнорируем ответ отменённого воркера (флаг _cancelled = True)")
                    return
                
                # ✅ GUARD 2: Проверяем что воркер принадлежит текущему чату
                if hasattr(self.current_worker, 'chat_id') and self.current_worker.chat_id != self.current_chat_id:
                    print(f"[HANDLE_RESPONSE] ⚠️ Игнорируем ответ от другого чата (воркер chat_id={self.current_worker.chat_id}, текущий={self.current_chat_id})")
                    return
            
            # ВАЖНО: Сбрасываем флаг генерации
            self.is_generating = False
            
            # Вычисляем время обдумывания с защитой
            thinking_time_to_show = 0
            try:
                if hasattr(self, 'thinking_start_time') and self.thinking_start_time:
                    self.thinking_elapsed_time = time.time() - self.thinking_start_time
                    print(f"[THINKING] Время обдумывания: {self.thinking_elapsed_time:.2f}s")
                    # Передаём время если был режим "думающий", "про" или "поиск"
                    show_timer = (self.ai_mode in [AI_MODE_THINKING, AI_MODE_PRO]) or self.use_search
                    thinking_time_to_show = self.thinking_elapsed_time if show_timer else 0
                else:
                    self.thinking_elapsed_time = 0
            except Exception as e:
                print(f"[HANDLE_RESPONSE] Ошибка расчёта времени: {e}")
                self.thinking_elapsed_time = 0
            
            # ═══════════════════════════════════════════════════════════════════════════
            # ✅ УНИВЕРСАЛЬНЫЙ ФИЛЬТР ТЕХНИЧЕСКИХ ОШИБОК
            # ═══════════════════════════════════════════════════════════════════════════
            
            # Проверка 1: Пустой или None ответ
            if not response or response is None:
                print(f"[ERROR_FILTER] ✗ Получен пустой ответ (None или пустая строка)")
                # НЕ создаём сообщение, полностью игнорируем
                return
            
            # Проверка 2: Не строка
            if not isinstance(response, str):
                print(f"[ERROR_FILTER] ✗ Ответ не является строкой: {type(response)}")
                # НЕ создаём сообщение
                return
            
            # Проверка 3: Признаки технических ошибок
            error_indicators = [
                "Traceback",
                "Exception",
                "Error:",
                "NoneType",
                "object is not iterable",
                "KeyError",
                "IndexError", 
                "TypeError",
                "AttributeError",
                "ValueError",
                "RuntimeError"
            ]
            
            error_prefixes = [
                "[Ошибка]",
                "Python",
                "File \"",
                "line ",
                "Traceback (most recent call last)"
            ]
            
            # Проверяем содержимое на технические ошибки
            response_lower = response.lower()
            has_error = False
            
            for indicator in error_indicators:
                if indicator in response or indicator.lower() in response_lower:
                    print(f"[ERROR_FILTER] ✗ Обнаружен индикатор ошибки: {indicator}")
                    has_error = True
                    break
            
            # Проверяем начало строки
            if not has_error:
                for prefix in error_prefixes:
                    if response.startswith(prefix):
                        print(f"[ERROR_FILTER] ✗ Ответ начинается с: {prefix}")
                        has_error = True
                        break
            
            # Если обнаружена техническая ошибка
            if has_error:
                print(f"[ERROR_FILTER] ✗ Техническая ошибка обнаружена, показываем нейтральное сообщение")
                print(f"[ERROR_FILTER] Оригинальный ответ (логируется): {response[:200]}...")
                
                # Заменяем на нейтральное сообщение
                if self.current_language == "russian":
                    response = "Не удалось обработать запрос. Попробуйте ещё раз."
                else:
                    response = "Failed to process request. Please try again."
            
            # ═══════════════════════════════════════════════════════════════════════════
            
            # Проверяем валидность ответа (дополнительная проверка)
            if not response:
                response = "[Ошибка] Пустой ответ от модели"
                print(f"[HANDLE_RESPONSE] ✗ Получен пустой ответ")
            elif not isinstance(response, str):
                response = str(response) if response else "[Ошибка] Некорректный ответ"
                print(f"[HANDLE_RESPONSE] ✗ Ответ не строка, конвертирован")
            
            # Формируем историю действий (для логики, без UI)
            action_history = []
            
            # Режим AI
            if self.ai_mode == AI_MODE_FAST:
                action_history.append("[✓] быстрый режим")
            elif self.ai_mode == AI_MODE_THINKING:
                action_history.append("[✓] думающий режим")
            elif self.ai_mode == AI_MODE_PRO:
                action_history.append("[✓] про режим")
            
            # Поиск
            if hasattr(self, 'last_message_use_search') and self.last_message_use_search:
                action_history.append("[✓] найдено в интернете")
            
            # Добавляем сообщение с защитой
            try:
                self.add_message_widget(ASSISTANT_NAME, response, add_controls=True, thinking_time=thinking_time_to_show, action_history=action_history)
            except Exception as e:
                print(f"[HANDLE_RESPONSE] ✗ Ошибка add_message_widget: {e}")
                try:
                    # Пробуем без thinking_time
                    self.add_message_widget(ASSISTANT_NAME, response, add_controls=True, thinking_time=0, action_history=action_history)
                except Exception as e2:
                    print(f"[HANDLE_RESPONSE] ✗ Критическая ошибка виджета: {e2}")
            
            # Сохраняем в БД с защитой
            try:
                if hasattr(self, 'chat_manager') and hasattr(self, 'current_chat_id'):
                    self.chat_manager.save_message(self.current_chat_id, "assistant", response)
                else:
                    print(f"[HANDLE_RESPONSE] ✗ Нет chat_manager или current_chat_id")
            except Exception as e:
                print(f"[HANDLE_RESPONSE] ✗ Ошибка сохранения в БД: {e}")
            
            # Сбрасываем таймер
            self.thinking_start_time = None
            
            # ═══════════════════════════════════════════════════════════════════════════
            # ОЧИСТКА СТАТУСА ПОСЛЕ ЗАВЕРШЕНИЯ
            # ═══════════════════════════════════════════════════════════════════════════
            # ✅ ИСПРАВЛЕНИЕ: Сбрасываем status_base_text чтобы не показывать "регенерация" постоянно
            if hasattr(self, 'status_base_text'):
                self.status_base_text = ""
            
            # Плавно очищаем статус через 500ms после получения ответа
            QtCore.QTimer.singleShot(500, lambda: self.status_label.setText(""))
            print(f"[STATUS_PIPELINE] Статус будет очищен через 500ms")
            
            # Автоматическое именование чата с защитой
            try:
                messages = self.chat_manager.get_chat_messages(self.current_chat_id, limit=5)
                if messages and len(messages) == 2:
                    first_user_msg = messages[0][1] if len(messages[0]) > 1 and messages[0][0] == "user" else ""
                    if first_user_msg and isinstance(first_user_msg, str) and len(first_user_msg) > 0:
                        chat_title = first_user_msg[:40]
                        if len(first_user_msg) > 40:
                            chat_title += "..."
                        chat_title = chat_title[0].upper() + chat_title[1:] if len(chat_title) > 0 else "Новый чат"
                        self.chat_manager.update_chat_title(self.current_chat_id, chat_title)
                        self.load_chats_list()
            except Exception as e:
                print(f"[HANDLE_RESPONSE] Ошибка автоименования: {e}")
            
        except Exception as e:
            print(f"[HANDLE_RESPONSE] ✗ Критическая ошибка: {e}")
            import traceback
            traceback.print_exc()
        finally:
            # ВСЕГДА восстанавливаем UI
            try:
                self.send_btn.setEnabled(True)
                self.send_btn.setText("→")
                self.input_field.setEnabled(True)
                self.input_field.setFocus()
                self.activateWindow()
                self.raise_()
                # Останавливаем анимацию точек
                if hasattr(self, 'stop_status_animation'):
                    self.stop_status_animation()
            except Exception as e:
                print(f"[HANDLE_RESPONSE] Ошибка восстановления UI: {e}")


    def regenerate_last_response(self):
        """Перегенерировать последний ответ ассистента
        
        ЛОГИКА:
        1. Проверяем, идёт ли генерация - если да, отменяем и запускаем новую
        2. Находим последнее сообщение ассистента в UI
        3. Получаем последнее сообщение пользователя из БД
        4. Удаляем последний ответ ассистента (из UI и БД)
        5. Перезапускаем генерацию с последним запросом пользователя
        """
        print("[REGENERATE] ▶ Начинаем регенерацию последнего ответа")
        
        # Если генерация идёт - останавливаем её
        if self.is_generating:
            self.is_generating = False
            if hasattr(self, 'current_worker'):
                self.current_worker = None
            print("[REGENERATE] Отменяем текущую генерацию для перезапуска")
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 1: НАХОДИМ ПОСЛЕДНИЙ ВИДЖЕТ АССИСТЕНТА В UI
        # ═══════════════════════════════════════════════════════════════
        last_assistant_widget = None
        for i in range(self.messages_layout.count() - 1, -1, -1):
            item = self.messages_layout.itemAt(i)
            if item and item.widget() and hasattr(item.widget(), 'speaker'):
                widget = item.widget()
                if widget.speaker != "Вы" and widget.speaker != "Система":
                    last_assistant_widget = widget
                    print(f"[REGENERATE] Найден последний виджет ассистента на позиции {i}")
                    break
        
        if not last_assistant_widget:
            print("[REGENERATE] ✗ Не найдено сообщение ассистента для регенерации")
            return
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 2: ПОЛУЧАЕМ ПОСЛЕДНЕЕ СООБЩЕНИЕ ПОЛЬЗОВАТЕЛЯ ИЗ БД
        # ═══════════════════════════════════════════════════════════════
        messages = self.chat_manager.get_chat_messages(self.current_chat_id, limit=50)
        
        last_user_msg = None
        for role, content, _ in reversed(messages):
            if role == "user":
                last_user_msg = content
                break
        
        if not last_user_msg:
            print("[REGENERATE] ✗ Нет сообщений пользователя в текущем чате")
            return
        
        print(f"[REGENERATE] Найдено последнее сообщение пользователя: {last_user_msg[:50]}...")
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 3: УДАЛЯЕМ ВИДЖЕТ ПОСЛЕДНЕГО ОТВЕТА
        # ═══════════════════════════════════════════════════════════════
        last_assistant_widget.deleteLater()
        print("[REGENERATE] ✓ Виджет последнего ответа удалён")
        
        # ═══════════════════════════════════════════════════════════════
        # ШАГ 4: УДАЛЯЕМ ПОСЛЕДНЕЕ СООБЩЕНИЕ АССИСТЕНТА ИЗ БД
        # ═══════════════════════════════════════════════════════════════
        conn = sqlite3.connect("chats.db")
        cur = conn.cursor()
        
        # Проверяем, что последнее сообщение - от ассистента
        cur.execute("""
            SELECT role FROM chat_messages 
            WHERE chat_id = ? 
            ORDER BY id DESC LIMIT 1
        """, (self.current_chat_id,))
        
        last_role = cur.fetchone()
        if last_role and last_role[0] == "assistant":
            cur.execute("""
                DELETE FROM chat_messages 
                WHERE chat_id = ? AND id = (
                    SELECT id FROM chat_messages 
                    WHERE chat_id = ? 
                    ORDER BY id DESC LIMIT 1
                )
            """, (self.current_chat_id, self.current_chat_id))
            conn.commit()
            print("[REGENERATE] ✓ Сообщение ассистента удалено из БД")
        else:
            print("[REGENERATE] ⚠️ Последнее сообщение в БД не от ассистента")
        
        conn.close()
        
        # Отправляем запрос заново
        self.input_field.setEnabled(False)
        self.send_btn.setText("⏸")
        self.send_btn.setEnabled(True)
        self.is_generating = True
        
        # Адаптируем deep_thinking в зависимости от режима AI (как в send_message)
        if self.ai_mode == AI_MODE_FAST:
            actual_deep_thinking = False
        elif self.ai_mode == AI_MODE_THINKING:
            actual_deep_thinking = True
        elif self.ai_mode == AI_MODE_PRO:
            actual_deep_thinking = True
        else:
            actual_deep_thinking = self.deep_thinking
        
        # Устанавливаем статус перегенерации с учётом режима
        if self.ai_mode == AI_MODE_PRO:
            self.status_base_text = "⏳ Перегенерация (режим Про)"
        elif self.ai_mode == AI_MODE_THINKING:
            self.status_base_text = "⏳ Перегенерация (режим Думающий)"
        elif self.ai_mode == AI_MODE_FAST:
            self.status_base_text = "⏳ Перегенерация (быстрый режим)"
        else:
            self.status_base_text = "⏳ Перегенерирую сообщение"
        
        self.status_label.setText(self.status_base_text)
        self.start_status_animation()
        
        # Запускаем таймер обдумывания
        self.thinking_start_time = time.time()
        
        self.current_user_message = last_user_msg
        
        # Используем actual_deep_thinking вместо self.deep_thinking и ai_mode
        worker = AIWorker(last_user_msg, self.current_language, actual_deep_thinking, 
                         self.use_search, False, self.chat_manager, self.current_chat_id, None, self.ai_mode)
        worker._cancelled = False  # Флаг отмены генерации
        worker.signals.finished.connect(self.handle_response)
        self.current_worker = worker
        
        # ✅ ИСПРАВЛЕНИЕ: Сохраняем worker в список
        self.active_workers.append(worker)
        if len(self.active_workers) > 5:
            self.active_workers = self.active_workers[-5:]
        
        self.threadpool.start(worker)
        print(f"[REGENERATE] Запущена новая генерация (режим: {self.ai_mode}, deep_thinking: {actual_deep_thinking}, search: {self.use_search})")
    
    # ═══════════════════════════════════════════════════════════════════════════
    # STATUS PIPELINE - ПОЭТАПНОЕ ОБНОВЛЕНИЕ СТАТУСА В НИЖНЕМ ЛЕВОМ УГЛУ
    # ═══════════════════════════════════════════════════════════════════════════
    
    def _status_pipeline_analyzing(self):
        """ЭТАП 2: Анализ запроса"""
        if not self.is_generating:
            # Генерация уже остановлена, не продолжаем pipeline
            return
        
        # ✅ КРИТИЧНО: Очищаем перед установкой нового текста
        self.status_label.clear()
        self.status_label.setText("анализирую…")
        print(f"[STATUS_PIPELINE] Этап 2: анализирую…")
        
        # Переходим к следующему этапу в зависимости от режима
        if self.current_deep_thinking or self.current_ai_mode in [AI_MODE_THINKING, AI_MODE_PRO]:
            # Если думающий или про режим - показываем этап "думаю"
            QtCore.QTimer.singleShot(400, lambda: self._status_pipeline_thinking())
        elif self.current_use_search or self.current_ai_mode == AI_MODE_PRO:
            # Если есть поиск или про режим - переходим к поиску
            QtCore.QTimer.singleShot(400, lambda: self._status_pipeline_searching())
        else:
            # Быстрый режим без поиска - сразу к формированию ответа
            QtCore.QTimer.singleShot(400, lambda: self._status_pipeline_generating())
    
    def _status_pipeline_thinking(self):
        """ЭТАП 3: Обдумывание (только для думающего/про режима)"""
        if not self.is_generating:
            return
        
        # ✅ КРИТИЧНО: Очищаем перед установкой нового текста
        self.status_label.clear()
        self.status_label.setText("думаю…")
        print(f"[STATUS_PIPELINE] Этап 3: думаю…")
        
        # Переходим к поиску или генерации
        if self.current_use_search or self.current_ai_mode == AI_MODE_PRO:
            QtCore.QTimer.singleShot(600, lambda: self._status_pipeline_searching())
        else:
            QtCore.QTimer.singleShot(600, lambda: self._status_pipeline_generating())
    
    def _status_pipeline_searching(self):
        """ЭТАП 4: Поиск информации (если активирован поиск или про режим)"""
        if not self.is_generating:
            return
        
        # ✅ КРИТИЧНО: Очищаем перед установкой нового текста
        self.status_label.clear()
        self.status_label.setText("ищу информацию…")
        print(f"[STATUS_PIPELINE] Этап 4: ищу информацию…")
        
        # Переходим к формированию ответа
        QtCore.QTimer.singleShot(800, lambda: self._status_pipeline_generating())
    
    def _status_pipeline_generating(self):
        """ЭТАП 5: Формирование ответа"""
        if not self.is_generating:
            return
        
        # ✅ КРИТИЧНО: Очищаем перед установкой нового текста
        self.status_label.clear()
        self.status_label.setText("формирую ответ…")
        print(f"[STATUS_PIPELINE] Этап 5: формирую ответ…")
        
        # После завершения статус будет очищен в handle_response
    
    def edit_last_message(self, old_text=None):
        """Редактировать последнее сообщение пользователя
        
        ЛОГИКА:
        1. Получить последний user-запрос из текущего чата
        2. Вернуть текст в поле ввода
        3. Удалить последние 2 сообщения (user + assistant) + ActionIndicatorRow из UI и БД
        4. Установить флаг режима редактирования
        5. При отправке сообщение заменится, а не добавится
        """
        if self.is_generating:
            print("[EDIT] ✗ Генерация идёт, редактирование невозможно")
            return
        
        # Получаем последнее сообщение пользователя из ТЕКУЩЕГО чата
        messages = self.chat_manager.get_chat_messages(self.current_chat_id, limit=50)
        
        last_user_msg = None
        for role, content, _ in reversed(messages):
            if role == "user":
                last_user_msg = content
                break
        
        if not last_user_msg:
            print("[EDIT] ✗ Нет сообщений пользователя для редактирования")
            return
        
        print(f"[EDIT] Редактируем последний запрос: {last_user_msg[:50]}...")
        
        # Удаляем последние 2 виджета (user + assistant)
        removed_count = 0
        while self.messages_layout.count() > 1 and removed_count < 2:
            last_item = self.messages_layout.itemAt(self.messages_layout.count() - 2)
            if last_item and last_item.widget():
                last_item.widget().deleteLater()
                removed_count += 1
        
        print(f"[EDIT] ✓ Удалено виджетов: {removed_count}")
        
        # Удаляем последние 2 сообщения из БД текущего чата
        conn = sqlite3.connect("chats.db")
        cur = conn.cursor()
        cur.execute("""
            DELETE FROM chat_messages 
            WHERE chat_id = ? AND id IN (
                SELECT id FROM chat_messages 
                WHERE chat_id = ? 
                ORDER BY id DESC LIMIT 2
            )
        """, (self.current_chat_id, self.current_chat_id))
        conn.commit()
        conn.close()
        print("[EDIT] ✓ Удалены последние 2 сообщения из БД")
        
        # УСТАНАВЛИВАЕМ РЕЖИМ РЕДАКТИРОВАНИЯ
        self.is_editing = True
        self.editing_message_text = last_user_msg
        
        # ВОССТАНАВЛИВАЕМ РЕЖИМЫ которые были при отправке сообщения
        if hasattr(self, 'last_message_deep_thinking') and hasattr(self, 'last_message_use_search'):
            self.deep_thinking = self.last_message_deep_thinking
            self.use_search = self.last_message_use_search
            self.think_toggle.setChecked(self.deep_thinking)
            self.search_toggle.setChecked(self.use_search)
            print(f"[EDIT] Восстановлены режимы: думать={self.deep_thinking}, поиск={self.use_search}")
        else:
            print(f"[EDIT] Текущие режимы: думать={self.deep_thinking}, поиск={self.use_search}")
        
        # ВОЗВРАЩАЕМ ТЕКСТ В ПОЛЕ ВВОДА И УСТАНАВЛИВАЕМ КУРСОР В КОНЕЦ
        self.input_field.setText(last_user_msg)
        self.input_field.setEnabled(True)
        self.input_field.setFocus()
        self.input_field.setCursorPosition(len(last_user_msg))
        print(f"[EDIT] ✓ Режим редактирования активирован")

    def clear_chat(self):
        """Очистка чата с кастомным окном подтверждения"""
        print("[CLEAR_CHAT] Метод вызван!")
        
        # Блокируем очистку если идёт генерация
        if self.is_generating:
            print("[CLEAR_CHAT] Генерация в процессе - очистка заблокирована")
            return
        
        # Проверяем, есть ли сообщения в чате (кроме системных)
        messages_count = 0
        for i in range(self.messages_layout.count() - 1):
            item = self.messages_layout.itemAt(i)
            if item and item.widget():
                widget = item.widget()
                if hasattr(widget, 'speaker') and widget.speaker != "Система":
                    messages_count += 1
        
        print(f"[CLEAR_CHAT] Найдено сообщений: {messages_count}")
        
        if messages_count == 0:
            print("[CLEAR_CHAT] Нет сообщений - выход")
            return
        
        # Получаем текущую тему
        is_dark = self.current_theme == "dark"
        
        # Создаём МОДАЛЬНОЕ окно (работает на Mac)
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("")
        dialog.setModal(True)
        dialog.setFixedSize(420, 220)
        
        # Убираем рамку окна
        dialog.setWindowFlags(QtCore.Qt.WindowType.FramelessWindowHint | QtCore.Qt.WindowType.Dialog)
        # Прозрачность работает плохо на Windows
        if not IS_WINDOWS:
            dialog.setAttribute(QtCore.Qt.WidgetAttribute.WA_TranslucentBackground)
        
        # Центрируем по ЭКРАНУ (не по родителю)
        screen_geo = QtWidgets.QApplication.primaryScreen().geometry()
        dialog.move(
            screen_geo.center().x() - 210,
            screen_geo.center().y() - 110
        )
        
        # Layout
        layout = QtWidgets.QVBoxLayout(dialog)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(20)
        
        # Стеклянный контейнер с адаптацией под тему
        frame = QtWidgets.QFrame()
        
        # КРИТИЧНО: Устанавливаем что фон НЕ должен рисоваться поверх дочерних элементов
        frame.setAttribute(QtCore.Qt.WidgetAttribute.WA_StyledBackground, True)
        
        if is_dark:
            # Тёмная тема - стеклянный фон БЕЗ дополнительных слоёв
            frame.setStyleSheet("""
                QFrame {
                    background-color: rgba(30, 30, 35, 0.92);
                    border: 1px solid rgba(60, 60, 70, 0.8);
                    border-radius: 20px;
                }
            """)
        else:
            # Светлая тема - стеклянный фон БЕЗ дополнительных слоёв
            frame.setStyleSheet("""
                QFrame {
                    background-color: rgba(255, 255, 255, 0.90);
                    border: 1px solid rgba(255, 255, 255, 0.95);
                    border-radius: 20px;
                }
            """)
        
        frame_layout = QtWidgets.QVBoxLayout(frame)
        frame_layout.setContentsMargins(35, 35, 35, 35)
        frame_layout.setSpacing(28)
        
        # Текст - КРИТИЧНО: убираем любые стили которые могут создать слой
        label = QtWidgets.QLabel("Вы уверены, что хотите\nочистить чат?")
        label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        label.setFont(QtGui.QFont("Inter", 16, QtGui.QFont.Weight.Medium))
        
        # ИСПРАВЛЕНИЕ: Минимальный стиль только для цвета текста
        # НЕ используем padding, background и другие свойства которые создают слои
        if is_dark:
            label.setStyleSheet("QLabel { color: #e6e6e6; background-color: none; border: none; }")
        else:
            label.setStyleSheet("QLabel { color: #2d3748; background-color: none; border: none; }")
        
        label.setWordWrap(True)
        
        # КРИТИЧНО: Поднимаем label поверх всех слоёв
        label.raise_()
        
        frame_layout.addWidget(label)
        
        # Кнопки
        buttons = QtWidgets.QHBoxLayout()
        buttons.setSpacing(15)
        
        no_btn = QtWidgets.QPushButton("НЕТ")
        no_btn.setFont(QtGui.QFont("Inter", 14, QtGui.QFont.Weight.Bold))
        no_btn.setFixedHeight(54)
        no_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        
        if is_dark:
            no_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(60, 60, 70, 0.7);
                    color: #c0c0c0;
                    border: 1px solid rgba(80, 80, 90, 0.8);
                    border-radius: 13px;
                    padding: 8px 18px;
                    text-align: center;
                }
                QPushButton:hover {
                    background: rgba(70, 70, 80, 0.85);
                    border: 1px solid rgba(90, 90, 100, 0.9);
                }
            """)
        else:
            no_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(200, 200, 200, 0.6);
                    color: #4a5568;
                    border: 1px solid rgba(200, 200, 200, 0.75);
                    border-radius: 13px;
                    padding: 8px 18px;
                    text-align: center;
                }
                QPushButton:hover {
                    background: rgba(200, 200, 200, 0.8);
                }
            """)
        
        yes_btn = QtWidgets.QPushButton("ДА")
        yes_btn.setFont(QtGui.QFont("Inter", 14, QtGui.QFont.Weight.Bold))
        yes_btn.setFixedHeight(54)
        yes_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        
        if is_dark:
            yes_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(220, 38, 38, 0.95);
                    color: #ffffff;
                    border: 1px solid rgba(220, 38, 38, 1.0);
                    border-radius: 13px;
                    padding: 8px 18px;
                    text-align: center;
                }
                QPushButton:hover {
                    background: rgba(185, 28, 28, 1.0);
                    border: 1px solid rgba(185, 28, 28, 1.0);
                }
            """)
        else:
            yes_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(239, 68, 68, 0.95);
                    color: white;
                    border: none;
                    border-radius: 13px;
                    padding: 8px 18px;
                    text-align: center;
                }
                QPushButton:hover {
                    background: rgba(220, 38, 38, 1.0);
                }
            """)
        
        buttons.addWidget(no_btn)
        buttons.addWidget(yes_btn)
        
        # КРИТИЧНО: Поднимаем кнопки поверх всех слоёв
        no_btn.raise_()
        yes_btn.raise_()
        
        frame_layout.addLayout(buttons)
        
        layout.addWidget(frame)
        
        # Обработчики
        no_btn.clicked.connect(dialog.reject)
        yes_btn.clicked.connect(dialog.accept)
        
        print("[CLEAR_CHAT] Показываю диалог...")
        result = dialog.exec()
        
        if result == QtWidgets.QDialog.DialogCode.Accepted:
            print("[CLEAR_CHAT] Пользователь подтвердил очистку")
            self.perform_clear_chat()
        else:
            print("[CLEAR_CHAT] Пользователь отменил очистку")
    
    def perform_clear_chat(self):
        """Выполнить очистку чата с плавной iOS-style анимацией"""
        print("[PERFORM_CLEAR] Начинаем плавную очистку...")
        
        # Собираем все виджеты сообщений для удаления
        widgets = []
        for i in range(self.messages_layout.count()):
            item = self.messages_layout.itemAt(i)
            if item and item.widget():
                widget = item.widget()
                # Удаляем все виджеты сообщений
                if hasattr(widget, 'speaker'):
                    widgets.append(widget)
        
        print(f"[PERFORM_CLEAR] Виджетов для удаления: {len(widgets)}")
        
        if len(widgets) == 0:
            print("[PERFORM_CLEAR] Нет виджетов для удаления")
            self.finalize_clear()
            return
        
        # Блокируем UI во время анимации
        self.input_field.setEnabled(False)
        self.send_btn.setEnabled(False)
        
        # ПЛАВНАЯ iOS-style анимация для ВСЕХ платформ
        # Удаляем сообщения снизу вверх с небольшой задержкой
        total_duration = 0
        for idx, widget in enumerate(reversed(widgets)):  # Снизу вверх
            delay = idx * 40  # Меньше задержка = быстрее
            total_duration = delay + 300  # 300ms на саму анимацию
            QtCore.QTimer.singleShot(delay, lambda w=widget: self.smooth_fade_and_remove(w))
        
        # После завершения всех анимаций - финализируем
        QtCore.QTimer.singleShot(total_duration + 100, self.finalize_clear)
    
    def smooth_fade_and_remove(self, widget):
        """
        Плавное удаление виджета через fade-out анимацию.
        
        ВАЖНО: Только fade-out прозрачности, БЕЗ изменения размеров.
        После удаления виджета layout автоматически пересчитывается.
        """
        try:
            if not widget or not widget.isVisible():
                return
            
            # Создаём эффект прозрачности если его нет
            if not widget.graphicsEffect():
                opacity_effect = QtWidgets.QGraphicsOpacityEffect(widget)
                widget.setGraphicsEffect(opacity_effect)
            else:
                opacity_effect = widget.graphicsEffect()
            
            # Fade-out анимация
            fade_anim = QtCore.QPropertyAnimation(opacity_effect, b"opacity")
            fade_anim.setDuration(300)
            fade_anim.setStartValue(1.0)
            fade_anim.setEndValue(0.0)
            fade_anim.setEasingCurve(QtCore.QEasingCurve.Type.OutCubic)
            
            # Удаляем виджет после завершения анимации
            def cleanup():
                try:
                    # КРИТИЧНО: Сначала останавливаем анимацию
                    if hasattr(widget, '_cleanup_anim'):
                        widget._cleanup_anim.stop()
                        widget._cleanup_anim = None
                    
                    # Затем удаляем эффект
                    if widget.graphicsEffect():
                        widget.setGraphicsEffect(None)
                    
                    # Удаляем ссылку на эффект
                    if hasattr(widget, '_opacity_effect'):
                        widget._opacity_effect = None
                    
                    # И только после этого удаляем виджет
                    self.messages_layout.removeWidget(widget)
                    widget.deleteLater()
                    # Layout обновится автоматически
                except RuntimeError:
                    # Объект уже удалён - игнорируем
                    pass
                except Exception as e:
                    print(f"[CLEANUP] Ошибка при удалении виджета: {e}")
            
            fade_anim.finished.connect(cleanup)
            fade_anim.start()
            
            # Сохраняем ссылку на анимацию И на эффект прозрачности
            widget._cleanup_anim = fade_anim
            widget._opacity_effect = opacity_effect
            
        except Exception as e:
            print(f"[SMOOTH_FADE] Ошибка: {e}")
            # В случае ошибки - просто удаляем виджет
            try:
                if widget.graphicsEffect():
                    widget.setGraphicsEffect(None)
                self.messages_layout.removeWidget(widget)
                widget.deleteLater()
                # Layout обновится автоматически
            except:
                pass
    
    
    def finalize_clear(self):
        """Завершение очистки чата после анимации"""
        try:
            print("[FINALIZE] Очищаем БД и восстанавливаем UI...")
            
            # ✅ Удаляем все оставшиеся виджеты сообщений (на случай если анимация не завершилась)
            # Оставляем только stretch в конце
            items_to_remove = []
            for i in range(self.messages_layout.count()):
                item = self.messages_layout.itemAt(i)
                if item and item.widget():
                    widget = item.widget()
                    # Удаляем только виджеты с атрибутом speaker (сообщения)
                    if hasattr(widget, 'speaker'):
                        items_to_remove.append(widget)
            
            for widget in items_to_remove:
                self.messages_layout.removeWidget(widget)
                widget.deleteLater()
            
            print(f"[FINALIZE] Удалено оставшихся виджетов: {len(items_to_remove)}")
            
            # Очищаем БД
            self.chat_manager.clear_chat_messages(self.current_chat_id)
            self.chat_manager.update_chat_title(self.current_chat_id, "Новый чат")
            self.load_chats_list()
            
            # Добавляем системное сообщение (автоскролл произойдет автоматически)
            self.add_message_widget("Система", "Чат очищен", add_controls=False)
            
            # Восстанавливаем UI
            self.input_field.setEnabled(True)
            self.send_btn.setEnabled(True)
            self.input_field.setFocus()
            
            print("[FINALIZE] Готово!")
        except Exception as e:
            print(f"[FINALIZE] Ошибка: {e}")
            import traceback
            traceback.print_exc()
            # В случае ошибки - всё равно восстанавливаем UI
            self.input_field.setEnabled(True)
            self.send_btn.setEnabled(True)
    
    def confirm_delete_all_chats(self):
        """Показать диалог подтверждения удаления ВСЕХ чатов"""
        print("[DELETE_ALL_CHATS] Запрос подтверждения удаления всех чатов")
        
        # Получаем текущую тему
        is_dark = self.current_theme == "dark"
        
        # Создаём модальное окно
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("")
        dialog.setModal(True)
        dialog.setFixedSize(450, 240)
        
        # Убираем рамку окна
        dialog.setWindowFlags(QtCore.Qt.WindowType.FramelessWindowHint | QtCore.Qt.WindowType.Dialog)
        if not IS_WINDOWS:
            dialog.setAttribute(QtCore.Qt.WidgetAttribute.WA_TranslucentBackground)
        
        # Центрируем по экрану
        screen_geo = QtWidgets.QApplication.primaryScreen().geometry()
        dialog.move(
            screen_geo.center().x() - 225,
            screen_geo.center().y() - 120
        )
        
        # Layout
        layout = QtWidgets.QVBoxLayout(dialog)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(20)
        
        # Стеклянный контейнер
        frame = QtWidgets.QFrame()
        frame.setAttribute(QtCore.Qt.WidgetAttribute.WA_StyledBackground, True)
        
        if is_dark:
            frame.setStyleSheet("""
                QFrame {
                    background-color: rgba(30, 30, 35, 0.92);
                    border: 1px solid rgba(60, 60, 70, 0.8);
                    border-radius: 20px;
                }
            """)
        else:
            frame.setStyleSheet("""
                QFrame {
                    background-color: rgba(255, 255, 255, 0.90);
                    border: 1px solid rgba(255, 255, 255, 0.95);
                    border-radius: 20px;
                }
            """)
        
        frame_layout = QtWidgets.QVBoxLayout(frame)
        frame_layout.setContentsMargins(35, 35, 35, 35)
        frame_layout.setSpacing(28)
        
        # Заголовок
        title = QtWidgets.QLabel("⚠️ Удалить все чаты?")
        title.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        title.setFont(QtGui.QFont("Inter", 18, QtGui.QFont.Weight.Bold))
        
        if is_dark:
            title.setStyleSheet("QLabel { color: #e89999; background-color: none; border: none; }")
        else:
            title.setStyleSheet("QLabel { color: #c85555; background-color: none; border: none; }")
        
        frame_layout.addWidget(title)
        
        # Текст предупреждения
        warning = QtWidgets.QLabel("Это действие невозможно отменить.\nВсе чаты будут удалены безвозвратно.")
        warning.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        warning.setFont(QtGui.QFont("Inter", 13, QtGui.QFont.Weight.Normal))
        warning.setWordWrap(True)
        
        if is_dark:
            warning.setStyleSheet("QLabel { color: #b0b0b0; background-color: none; border: none; }")
        else:
            warning.setStyleSheet("QLabel { color: #64748b; background-color: none; border: none; }")
        
        frame_layout.addWidget(warning)
        
        # Кнопки
        buttons = QtWidgets.QHBoxLayout()
        buttons.setSpacing(15)
        
        no_btn = QtWidgets.QPushButton("Отмена")
        no_btn.setFont(QtGui.QFont("Inter", 14, QtGui.QFont.Weight.Medium))
        no_btn.setMinimumHeight(48)
        no_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        
        if is_dark:
            no_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(60, 60, 70, 0.70);
                    color: #e6e6e6;
                    border: none;
                    border-radius: 13px;
                    padding: 8px 18px;
                }
                QPushButton:hover {
                    background: rgba(70, 70, 80, 0.85);
                }
            """)
        else:
            no_btn.setStyleSheet("""
                QPushButton {
                    background: rgba(226, 232, 240, 0.90);
                    color: #334155;
                    border: none;
                    border-radius: 13px;
                    padding: 8px 18px;
                }
                QPushButton:hover {
                    background: rgba(203, 213, 225, 1.0);
                }
            """)
        
        yes_btn = QtWidgets.QPushButton("Удалить все")
        yes_btn.setFont(QtGui.QFont("Inter", 14, QtGui.QFont.Weight.Bold))
        yes_btn.setMinimumHeight(48)
        yes_btn.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        yes_btn.setStyleSheet("""
            QPushButton {
                background: rgba(239, 68, 68, 0.95);
                color: white;
                border: none;
                border-radius: 13px;
                padding: 8px 18px;
                text-align: center;
            }
            QPushButton:hover {
                background: rgba(220, 38, 38, 1.0);
            }
        """)
        
        buttons.addWidget(no_btn)
        buttons.addWidget(yes_btn)
        
        no_btn.raise_()
        yes_btn.raise_()
        
        frame_layout.addLayout(buttons)
        layout.addWidget(frame)
        
        # Обработчики
        no_btn.clicked.connect(dialog.reject)
        yes_btn.clicked.connect(dialog.accept)
        
        print("[DELETE_ALL_CHATS] Показываю диалог...")
        result = dialog.exec()
        
        if result == QtWidgets.QDialog.DialogCode.Accepted:
            print("[DELETE_ALL_CHATS] Пользователь подтвердил удаление всех чатов")
            self.perform_delete_all_chats()
        else:
            print("[DELETE_ALL_CHATS] Пользователь отменил удаление")
    
    def perform_delete_all_chats(self):
        """Удалить все чаты и создать новый — напрямую через SQL"""
        print("[DELETE_ALL_CHATS] ▶ Начинаю полное удаление...")
        
        try:
            import sqlite3 as _sqlite3
            
            # ШАГ 1: Напрямую чистим БД — гарантированно удаляем всё
            # Берём путь из модуля chat_manager
            import chat_manager as _cm_module
            db_path = _cm_module.CHATS_DB
            conn = _sqlite3.connect(db_path)
            cur = conn.cursor()
            
            cur.execute("DELETE FROM chat_messages")
            cur.execute("DELETE FROM chats")
            
            # Сбрасываем автоинкремент
            cur.execute("DELETE FROM sqlite_sequence WHERE name='chats'")
            cur.execute("DELETE FROM sqlite_sequence WHERE name='chat_messages'")
            
            # Создаём один чистый чат
            from datetime import datetime as _dt
            now = _dt.utcnow().isoformat()
            cur.execute(
                "INSERT INTO chats (title, created_at, updated_at, is_active) VALUES (?, ?, ?, ?)",
                ("Новый чат", now, now, 1)
            )
            new_chat_id = cur.lastrowid
            conn.commit()
            conn.close()
            
            print(f"[DELETE_ALL_CHATS] ✓ БД очищена. Новый чат ID={new_chat_id}")
            
            # ШАГ 2: Обновляем все внутренние ID
            self.current_chat_id = new_chat_id
            self.startup_chat_id = new_chat_id
            
            # ШАГ 3: Если в настройках — возвращаемся к чату плавно
            if self.content_stack.currentIndex() == 1:
                self._animate_stack_transition(from_index=1, to_index=0,
                                               callback=self._after_close_settings)
                QtWidgets.QApplication.processEvents()
            
            # ШАГ 4: Очищаем виджеты сообщений
            to_remove = []
            for i in range(self.messages_layout.count()):
                item = self.messages_layout.itemAt(i)
                if item and item.widget() and hasattr(item.widget(), 'speaker'):
                    to_remove.append(item.widget())
            for w in to_remove:
                self.messages_layout.removeWidget(w)
                w.deleteLater()
            print(f"[DELETE_ALL_CHATS] ✓ Удалено виджетов: {len(to_remove)}")
            
            # ШАГ 5: Обновляем список чатов в сайдбаре
            self.chats_list.clear()
            chats = self.chat_manager.get_all_chats()
            print(f"[DELETE_ALL_CHATS] Чатов в БД после удаления: {len(chats)}")
            for chat in chats:
                item = QtWidgets.QListWidgetItem(chat['title'])
                item.setData(QtCore.Qt.ItemDataRole.UserRole, chat['id'])
                self.chats_list.addItem(item)
                if chat['is_active']:
                    self.chats_list.setCurrentItem(item)
            self.chats_list.repaint()
            
            # ШАГ 6: Показываем приветствие
            self.add_message_widget("Система", "Привет! Готов к работе.", add_controls=False)
            
            # ШАГ 7: Скроллим вниз
            QtCore.QTimer.singleShot(100, lambda: self.scroll_area.verticalScrollBar().setValue(
                self.scroll_area.verticalScrollBar().maximum()
            ))
            
            print("[DELETE_ALL_CHATS] ✓ Всё готово!")
            
        except Exception as e:
            print(f"[DELETE_ALL_CHATS] ✗ Ошибка: {e}")
            import traceback
            traceback.print_exc()


    # ═══════════════════════════════════════════════════════════════
    # DRAG-AND-DROP: Обработка перетаскивания файлов
    # ═══════════════════════════════════════════════════════════════
    
    def dragEnterEvent(self, event):
        """Обработка входа файла в окно (при перетаскивании)"""
        if event.mimeData().hasUrls():
            # Проверяем что это файлы
            urls = event.mimeData().urls()
            has_files = any(url.isLocalFile() for url in urls)
            
            if has_files:
                event.acceptProposedAction()
                print(f"[DRAG-DROP] ▶ Файлы вошли в зону: {len(urls)} шт.")
                
                # Визуальная подсказка - меняем курсор или подсвечиваем
                self.setStyleSheet(self.styleSheet() + """
                    QMainWindow {
                        border: 3px dashed #667eea;
                    }
                """)
            else:
                event.ignore()
        else:
            event.ignore()
    
    def dragMoveEvent(self, event):
        """Обработка движения файла над окном"""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            event.ignore()
    
    def dragLeaveEvent(self, event):
        """Обработка выхода файла из окна"""
        print("[DRAG-DROP] ✗ Файлы покинули зону")
        # Убираем визуальную подсказку
        self.apply_styles(self.current_theme, self.current_liquid_glass)
    
    def dropEvent(self, event):
        """Обработка сброса файлов в окно"""
        print("[DRAG-DROP] ✓ Файлы сброшены!")
        
        # Убираем визуальную подсказку
        self.apply_styles(self.current_theme, self.current_liquid_glass)
        
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            dropped_files = []
            
            for url in urls:
                if url.isLocalFile():
                    file_path = url.toLocalFile()
                    dropped_files.append(file_path)
                    print(f"[DRAG-DROP] Файл: {file_path}")
            
            if dropped_files:
                # Добавляем файлы в список прикреплённых
                for file_path in dropped_files:
                    # Проверяем лимит (максимум 5 файлов)
                    if len(self.attached_files) >= 5:
                        print(f"[DRAG-DROP] ⚠️ Достигнут лимит (5 файлов)")
                        # Показываем уведомление
                        QtWidgets.QMessageBox.warning(
                            self,
                            "Лимит файлов",
                            "Можно прикрепить максимум 5 файлов одновременно.",
                            QtWidgets.QMessageBox.StandardButton.Ok
                        )
                        break
                    
                    # Проверяем что файл существует
                    if os.path.exists(file_path):
                        print(f"[DRAG-DROP] ════════════════════════════════════════")
                        print(f"[DRAG-DROP] Обработка файла: {file_path}")
                        
                        # Копируем файл в хранилище чата
                        copied_path = self.copy_file_to_chat_dir(file_path, self.current_chat_id)
                        
                        if copied_path and 'chat_files' in copied_path and os.path.exists(copied_path):
                            if copied_path not in self.attached_files:
                                self.attached_files.append(copied_path)
                                print(f"[DRAG-DROP] ✅ Файл добавлен в attached_files:")
                                print(f"[DRAG-DROP]    Путь: {copied_path}")
                                print(f"[DRAG-DROP]    Существует: {os.path.exists(copied_path)}")
                            else:
                                print(f"[DRAG-DROP] ⚠️ Файл уже прикреплён: {os.path.basename(file_path)}")
                        else:
                            # Если копирование не удалось - НЕ добавляем файл!
                            print(f"[DRAG-DROP] ✗ ОШИБКА: Копирование не удалось или неправильный путь!")
                            if copied_path:
                                print(f"[DRAG-DROP]    Путь: {copied_path}")
                                print(f"[DRAG-DROP]    Содержит chat_files: {'chat_files' in copied_path}")
                                print(f"[DRAG-DROP]    Существует: {os.path.exists(copied_path)}")
                            QtWidgets.QMessageBox.warning(
                                self,
                                "Ошибка прикрепления",
                                f"Не удалось прикрепить файл {os.path.basename(file_path)}.\n\nПроверьте права доступа.",
                                QtWidgets.QMessageBox.StandardButton.Ok
                            )
                        
                        print(f"[DRAG-DROP] ════════════════════════════════════════")
                    else:
                        print(f"[DRAG-DROP] ✗ Файл не найден: {file_path}")
                
                # Обновляем UI - показываем прикреплённые файлы
                if self.attached_files:
                    self.update_file_chips()
                    print(f"[DRAG-DROP] ✅ Прикреплено файлов: {len(self.attached_files)}")
                
                event.acceptProposedAction()
            else:
                event.ignore()
        else:
            event.ignore()

def main():
    """Главная функция запуска приложения с обработкой ошибок"""
    try:
        print("[MAIN] Инициализация базы данных...")
        init_db()
        
        print("[MAIN] Создание приложения Qt...")
        app = QtWidgets.QApplication(sys.argv)
        
        # Для Windows - устанавливаем явно стиль
        if IS_WINDOWS:
            print("[MAIN] Применение стиля для Windows...")
            app.setStyle('Fusion')
        
        print("[MAIN] Создание иконки приложения...")
        app_icon = create_app_icon()
        app.setWindowIcon(QtGui.QIcon(app_icon))
        
        print("[MAIN] Создание главного окна...")
        window = MainWindow()
        
        print("[MAIN] Отображение окна...")
        window.show()
        
        print("[MAIN] Запуск главного цикла...")
        sys.exit(app.exec())
        
    except Exception as e:
        print(f"[MAIN] КРИТИЧЕСКАЯ ОШИБКА при запуске: {e}")
        import traceback
        traceback.print_exc()
        
        # Пытаемся показать сообщение об ошибке
        try:
            error_app = QtWidgets.QApplication(sys.argv)
            QtWidgets.QMessageBox.critical(
                None,
                "Ошибка запуска",
                f"Не удалось запустить приложение:\n\n{str(e)}\n\nПроверьте:\n1. Установлены ли все зависимости\n2. Доступна ли база данных\n3. Запущена ли Ollama",
                QtWidgets.QMessageBox.StandardButton.Ok
            )
        except:
            pass
        
        sys.exit(1)

if __name__ == "__main__":
    main()